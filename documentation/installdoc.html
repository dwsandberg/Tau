<!doctype html> <meta charset =" UTF-8" ><style>
<!--span.avoidwrap {display:inline-block ;} span.keyword {color:blue ;}
span.literal {color:red ;} span.comment {color:green ;}
span.block {padding:0px 0px 0px 0px ; margin:0px 0px 0px 20px ; display:block ;}
--> </style> <p><br><a href ="#1" > The Tau Enviorment</a><span class=block><a href ="#2" > Installing Tau</a><br><a href ="#3" > HelloWorld</a><br><a href ="#4" > Commands</a><span class=block><a href ="#5" > Command Syntax</a> </span><a href ="#6" > taubuild.sh</a><span class=block><a href ="#7" > Command PEGdebug</a><br><a href ="#8" > Command buildhelp</a><br><a href ="#9" > Command entrypoint</a><br><a href ="#10" > Command front</a><br><a href ="#11" > Command makeScript</a><br><a href ="#12" > Command makebitcode</a><br><a href ="#13" > Command prettyScript</a><br><a href ="#14" > Command tau?</a><br><a href ="#15" > Command transform</a><br><a href ="#16" > Command unusedsymbols</a><br><a href ="#17" > Command usegraph</a> </span><a href ="#18" > Using PEG in Tau</a><span class=block><a href ="#19" > Using the PEG module</a><br><a href ="#20" > Using PEGgen</a><span class=block><a href ="#21" > Using a symbol table</a><br><a href ="#22" > Adding Error Recover</a> </span> </span> </span><a href ="#23" > Example of Renaming Function</a><br><a href ="#24" > Profiling</a><br><a href ="#25" > enumexample</a><span class=block><a href ="#26" > oldstuff</a><br><a href ="#27" > Introduction to intermediate code produced by compiler</a><br><a href ="#28" > HelloWorld with dynamic libraries</a><br><a href ="#29" > section Installing Web Assembly Cross Compiler</a><br><a href ="#30" > Documentation below is not complete.</a> </span><p><a id ="1" /><h1>The Tau Enviorment</h1><p><p><strong>x</strong>. k<p><p><a id ="2" /><h2>Installing Tau</h2><p><p>Make sure clang is installed. For Mac OS Clang is available if the command line tools are installed.<p><p>Down load the zip file from GitHub (Repository is dwsandberg/Tau)<p><p>Unzip to a directory which we will call &lt;Tau>. This directory will become the working directory for tau. You are free to choose another name. <p><p>Modify &lt; PATH > environment variable to include absolute path to &lt;Tau>/bin. <p><p>Open terminal and change directory to &lt;Tau>.<p><p>Run" bash bin/taubuild.sh release.bld". This is likely to generate a warning message about the llvm spec. <p><p><a id ="3" /><h2>HelloWorld</h2><p><p>Here are the basics for creating a program the prints "HelloWorld!".<p><p>Make sure you are in the &lt;Tau> directory. First create a sub-directory of the &lt;Tau> directory and name it <em>hello</em>. The hello directory will contain the parts of the program.<p><p>In the hello directory create a text file name text.ls containing the following five lines two of which are blank:<span class=block>Module hello<br><br>use standard<br><br>Function hello seq.word {COMMAND} "HelloWorld!" </span>This is the source for the program. By convention the name of Module is the same as the name of the file. <p><p>Next create a file name hello.bld with the following lines:<span class=block>define makelib taubc makebitcode<br><br>makelib taubc.libinfo+hello hello.ls<br>output:hello.lib<br><br>define hello hello<br><br>hello output: hello.html<br><br>define open shell open input:<br><br>open input: hello.html output: hello.txt </span>This file tells how to build and run the program. <p><p>Now run the follow command in the &lt;Tau> directory<span class=block>bash taubuild.sh hello/hello.bld </span><p><p>Running the above command does the following<span class=block><br>1. Create an executable with the name of &lt;Tau>/built/hello.lib from the source code.(Paragraphs one and two of the build file.)<br>2. The program is executed and the output is placed in &lt;Tau>/built/hello.html. (Paragraphs three and four of the build file.)<br>3. A web browser is opened on the file &lt;Tau>/built/hello.html.(Last two paragraph of the build file.)<br>4. An tar archive of the source files is created in the directory ~/taubackups/hello/. (An archive is created on successful completion of the build file.) </span><p><p>With additional steps typing hello at the command prompt will run the program.One of the commands need to do this is buildhelp which is supplied in the release. To gain access to all the commands in the release, type: <span class=block>source built/taucommands.sh </span><p><p>Now type<span class=block>buildhelp hello.libsrc shellscript:  </span>which will bring up a shell function definition for hello in a web browser.Copy this command and run as a shell command. Now typing <em>hello </em> at the command prompt will run the program.<p><p><a id ="4" /><h2>Commands</h2><p><p>The following assumes that" source built/taucommands.sh" has been executed in the command shell. <p><p>In langauges such as C a function main provides the single entry point into a program. In Tau there can be many entry points and are specified by including the word <em>COMMAND </em> in a comment of a function that meets the following conditions:<span class=block>Is a valid function<br>Define with Function<br>Has parameter types of seq.word, seq.file, or boolean. <br>Has a return type of seq.word or seq.file.<br>the word COMMAND is in comment immediately following the return type. </span><p><p><a id ="5" /><h3>Command Syntax</h3><p><p>Tau documentation of the commands provided in the release is given by the command tau?. This command was defined with<span class=block>Function tau?(cmd:seq.word, %:seq.word) seq.word {COMMAND... }...  </span>Removing from the definition the paraenthesis and commas, and replacing the types of the arguments actual values will give the syntax for calling the function on the command line.<span class=block>tau? cmd: %:full </span>Run the command gives<a href ="../documentation/cmddoc.html" > this result</a> <p><p>The order the parameters are specified does not matter. An omitted parameter of type seq.word is given an empty value. So the following will all give the same result: <span class=block><br>tau? cmd: %:full<br>tau? %:full cmd: <br>tau? %:full </span><p><p>If a value is supplied for cmd, only documentation for that command is given. Since cmd is both the the first argument given and the first argumentin the defining procedure, the cmd can be omitted. Hence the following will give the same result:<span class=block>tau? cmd: usegraph %: full<br>tau? usegraph %: full </span><p><p>For parameters of boolean type the value is false if the parameter is omitted or if the value <em>false</em>. Any other value for a boolean parameter is interpreted as <em>true</em>. <p><p>Parameters of type seq.file also are replaced with a string.The string is processed as filenames and the file from the filing system is fetched.Multiple formats are allowed for file names. <span class=block>directory/file1.ls directory/file2.ls directory/file3.ls </span>The directory does not need to be specified for every file:<span class=block>+directory file1.ls file2.ls file3.ls </span>The file extension also does not need to be repeated:<span class=block>+directory file1.ls file2 file3 </span>The file extension can be before the first file:<span class=block>+directory.ls file1 file2 file3 </span>All the above forms are specifiy the same files. If There is no directory use:<span class=block>+.ls file1 file2 file3 </span>The following three string all represent the same file<span class=block>directory/directory/file1.ls<br>+directory directory/file1.ls<br>+directory/directory file1.ls </span><p><p>Below is documentation for commands in the Tau release. <p><p><a id ="6" /><h2>taubuild.sh</h2><p><p>The <em>taubuild </em> determines how to build a program from the instructions in .bld files. The .bld file contains commands. Every command relates a set of input files to output files.The input files must be distinct from the output files. <p><p>The first output forms a node in a graph. Additional output files are predecessors and input files are successors. The command is define in some library file. This library file is also a successor. <p><p>This forms a DAG. All the source files can be construct one by one starting with the sources of the graph and working toward the sinks. Thus a bash script is constructed that will build all the output files. This bash script also contains a list of shasum of the sources in the DAG. The script used in the last successful run of the build is retained. By comparing this shasum between the current shasums with the previous shasums the files that need to be rebuilt can be determined.<p><p>The last successful run of the hello.bld will produce a file &lt;Tau>/built/build_helloold.sh. A new bash script is created named &lt;Tau>/built/build_hello.sh.This file contains shasum of all the source files used to build the program. The new script is run. If there are no errors the build_hello.sh file is renamed to build_helloold.sh and a tar archive is created. <p><p>The.bld file is sequence of paragraphs of words. <p><p>The first word of the paragraph is a command.There are two predefined commands: #, define.The#command treats the paragraph as a comment.<p><p>The define introduces a user defined command. The second word in the paragraph is the name of the command. The third word is the name of the executable where the command is defined and the fourth word is the name of the command in the executable. The command to reference the command to invoke the Tau complier that produces an executable would be<span class=block>define makelib taubc makebitcode </span><p><p>The definition of user defined command must occur before it's use. The paragraphs can be reorder as long as this constraint is maintained. <p><p>An alternate form for the makelib command in the hello.bld file is<span class=block>makelib output: +built hello.lib input: +built taubc.libinfo+hello hello.ls </span>The order of paramters does not matter so this command is equivalent:<span class=block>makelib input: +built taubc.libinfo+hello hello.ls output: +built hello.lib </span>If input: follows the command it can be omitted. A"+built" is always added to the input and output so it can also be omitted to get<span class=block>makelib tau.libinfo+hello hello.ls output: hello.lib </span><p><p>if <em>shell </em> is the third word of a define the remainder of the paragraph will be included as a command in the bash script with the input: and output: replaced by the corresponding file names specified in the use of the file. For example, the lines from the hello.bld file<span class=block>define open shell open input:<br><br>open input: hello.html output: hello.txt </span>will produce the bash script line<span class=block>open hello.html </span><p><p><a id ="7" /><h3>Command PEGdebug</h3><p><p><strong>PEGdebug </strong> displays trace of running a PEG. <br>-<strong>input </strong> Expected first paragraph of input to be input and second paragraph to be the grammar.<br>-<strong>steps </strong> from to. Only display steps between from and to.<br>-<strong>notable</strong>. Do not display parse table or grammar.<p><p><a id ="8" /><h3>Command buildhelp</h3><p><p><strong>buildhelp </strong> update helpdata in module. <br><strong>input </strong> files from which to extract the help data.<br><strong>target </strong> file to update help data in<br><strong>shellscript </strong> produces shell script to define commands.<br><strong>doc </strong> format for command documentation source file.<p><p><a id ="9" /><h3>Command entrypoint</h3><p><p><strong>entrypoint </strong> For seeing the Module the compiler generates to define the entry point. <br>Options:<br><strong>entryUses </strong> addition use clause added to module when building entry point. <br><strong>core </strong> Only show core of Module. <p><p><a id ="10" /><h3>Command front</h3><p><p>The <strong>front </strong> is a multiple purpose command. It outputs data from various stages of the compiler. <p>One use is to figure out what functions are used between modules. The usegraph of the core functions indicates there are dependences between the modules texio, file and bits. To see the dependences use<span class=block>front +built core.libsrc mods: textio file bits format </span>A graph will be display with the dependences between the modules. The nodes in the graph are the procedure names. Since a name does not uniquely identify a function hovering over the beginning of the name will pop up a more complete discription beginning with the name of the function. <p>The dependence on the module bits will not be displayed. If an earilier pass of the compiler is specified like this<span class=block>front  +built taubc.libsrc mods = textio file bits format pass = text </span>then it will be displayed. <p>The dependence with in the module textio can be seen with<span class=block>front  +built taubc.libsrc mods = textio pass = text within = </span><p>To see all the functions that call functions named <em>breakparagraph </em> in the library use<span class=block>front  +built taubc.libsrc n = breakparagraph pass = text out = calledby </span><p>This will list the function definitions in a package<span class=block>front  +built taubc.libsrc mods = textio out = symdef </span>The format is the function followed by a post order transversal of the call tree. <p>The front command takes several parameters that control which functions are considered.<br>○ <strong>n </strong> a list of names of functions to include<br>○ <strong>~n </strong> a list of names to exclude<br>○ <strong>mods </strong> a list of modules to include<br>○ <strong>~mods </strong> a list of modules to exculde<br>○ <strong>pass </strong> The option pass determines how much processing is done before looking at the symbols. <span class=block>• <strong>library </strong> Only report on functions imported from libraries. <br>• <strong>text </strong> Parse the input in such a way that the source code can be reconstructed.<br>• <strong>pass1 </strong> Output from first stage of processing. All bindings of text to symbols have been done.<br>• <strong>pass1a </strong> Like pass1 with Compiler options on Export statements added. <br>• <strong>pass2 </strong> After some optimization<br>• <strong>all </strong> Just before code generation.  </span><br>○ <strong>% </strong> The option % determines the format of the output. <span class=block>• <strong>sym </strong> Just the symbol names<br>• <strong>symdef </strong> The symbol definitions. The format is the symbol followed by a post order transversal of the call tree.<br>• <strong>symdefgraph </strong> For each symbol definition, the definition is presented as a call tree graph.<br>• <strong>calledby </strong> The option n is ignored in building a call graph. Then only the symbols that • call symbols in n directly or indirectly are included in the graph<br>• <strong>calls </strong> The option n is ignored in building a call graph. Then only the symbols that • are called (directly or indirectly) from symbols in n are included in the graph.<br>• <strong>txt </strong> Instead of producing a SVG graph print the args of the graph.<br>• <strong>baseTypeCheck </strong><br>• <strong>resultCheck </strong> </span><p><p><a id ="11" /><h3>Command makeScript</h3><p><p><strong>makeScript </strong> creates shell script for building code.<br>The commands' primary is is in the shell script taubuild.<br><strong>input </strong> build files<br><strong>builddir </strong> build directory, usually"+built".<br><strong>hashes </strong> two files with one containing lines from the unix command shasum. The two files are compared looking for identical lines which is used to determine which files have not be changed since the last build.<p><p><a id ="12" /><h3>Command makebitcode</h3><p><p><strong>makebitcode </strong> compiler<br>Options:<br><strong>entryUses </strong> addition use clause added to module when building entry point. <br><strong>profile </strong> generates information for profiling<br><strong>showllvm </strong> show text form of llvm code generated for the names of procedure given.<br>/info show text form of code info<br>/exports list of packes to show. <p><p><a id ="13" /><h3>Command prettyScript</h3><p><p><strong>prettyScript </strong> pretty prints .bld script.<br><strong>% </strong> format of output. <span class=block><br><strong>pretty </strong> ?<br><strong>full </strong> Graph of dependences between files.<br><strong>outdated </strong> like full but only include outdated files in graph<br><strong>script </strong> shell script for updating without the file hashes.  </span><p>options used for formats other than pretty.<br><strong>roots </strong> only include the filenames list and their descendants in graph. <br><strong>hashes </strong> ?<br><strong>builddir </strong> build target directory. Defaults to"+built"<p><p><a id ="14" /><h3>Command tau?</h3><p><p><strong>tau? </strong> Help documentation for commands. <br>This information is extracted from the comment in the source code for the command. If no option is supplied a description of the commands are printed.<br><strong>cmd </strong> restrict what is displayed. <br>" cmd: help1" will display documentation for tau? only and" cmd: help1 out" will display only the documentation of the out option of the tau? command. <br>Options:<span class=block><strong>% </strong> format of output. <br><strong>shellscript </strong> creates a shell script for commands.<br><strong>full </strong> Full documentations of commands<br><strong>brief </strong> Show extract of documentations </span><p><p><a id ="15" /><h3>Command transform</h3><p><p>The <strong>transform </strong> cmd takes a list of input source files. For each module in the input a pretty printed file is created in the directory &lt;Tau>/tmp Addition parameters allows for different variants. <span class=block>transform+tests profileExample.ls helloworld.ls<br>transform+tests profileExample.ls reorguse:<br>transform  +built profileExample.libsrc	 taubc.libinfo bind:<br>transform  +built profileExample.libsrc	 taubc.libinfo bind: reorguse:  </span><p>This first variant does not require the source to be semantically correct but the syntax must be correct. It does not change the order of the paragraphs. <p>The second is like the first except that it moves the use paragraphs to the beginning of the module, removes duplicates, and sorts them.<p>The third is like the first but requires correct semantics. This allows some additional transformations such as" not (a = b)" to become" a /ne b"<br>○ <strong>target </strong> overides default target directory tmp<br>○ <strong>bind </strong> Does further processing of input to bind id's to symbols.<br>○ <strong>reorguse </strong> Reorganizes use clauses. If <em>bind </em> is also specified unnecessary use clauses are removed.<br>○ <strong>link </strong><br>○ <strong>html </strong> An html file is produced with an index of modules. This option is useful for examining source code Useful for producing documentation with imbedded Tau code.<br>○ <strong>modrename </strong> List of modules to rename in form: oldname1 newname1 oldname2 newname2... <br>○ <strong>patternmods </strong> List of modules that contains patterns. <br>See<a href ="#patterns" > Example</a><br>○ <strong>cleanexports </strong> Remove exports for exports in module or if Export is from another module add comment to indicate where it comes from.<br>○ <strong>moveexports </strong> Move all exports to just after use clauses.<p>The <span class=keyword>transform </span> command treats the function genEnum as magic and will generate code in a module for enumeration types instead of creating the code by hand. <a href ="#enum" > genEnum Example</a><p><p><a id ="16" /><h3>Command unusedsymbols</h3><p><p><strong>unusedsymbols </strong> cmd analyzes code looking for unused functions. <p>It forms the function call graph for the program. <br>It then looks for any any sources in the call graph that are not the entry point of the program and lists them. Any functions that are generated from type definitions are also removed. <p>Here is an example<span class=block>tau tools unusedsymbols +built tools.libsrc taubc.libinfo </span><p>The behavior can be modified with flags. <br>-<strong>all </strong> list all unused functions--not just the roots. <br>-<strong>generated </strong> the symbols generated from type definitions are included. <br>-<strong>excessExports </strong> list symbols exported from a module but only used internally to that module.<br>-<strong>ignore </strong> Symbols with these names are not listed in output. Default value is genEnum genPEG<p><p><a id ="17" /><h3>Command usegraph</h3><p><p><strong>usegraph </strong> graphs <em>use </em> releationship between modules in source code. <br><br>options: <br><strong>exclude </strong> lists the modules to ignore in the use clauses. <br><strong>include </strong> restricts the modules considered to those listed.<p>Examples:<span class=block>> usegraph +built core.libsrc<a href ="../documentation/Ex1usegraph.html" > Result</a> <br>> usegraph +built core.libsrc exclude: seq standard<a href ="../documentation/Ex2usegraph.html" > Result</a> <br>> usegraph +built core.libsrc include: UTF8 words standard textio exclude: seq standard<a href ="../documentation/Ex3usegraph.html" > Result</a> <br>> usegraph +core UTF8.ls textio words standard encoding xxhash exclude = seq standard </span><p>The last two examples give the same result. The first excludes modules from consideration and the second only includes source files of modules that should be included. <p><p><a id ="18" /><h2>Using PEG in Tau</h2><p><p>This document describes how to use Tau to create PEG grammars to parse the following seq of words:<p><p><span class=keyword>function </span> Example1 int<br><span class=keyword>let </span> a = 1 + 2,<br>a + (3 + 4)<p>We assume the reader understands basic grammar terms such as parse tree, and non-terminal, terminal.<p><p>A PEG grammar to parses the above is<span class=block>G1 ← function any int E<br>E ← Sum<br>Sum ← Atom Sum'<br>* Sum' ← + Atom<br>Atom ← (E)<br>/ let any = E, E<br>/ any </span><p><p><a id ="19" /><h3>Using the PEG module</h3><p><p>Tau provides a module PEG for use a PEG grammar to transform a sequence of words into another sequence of words.An attribute will be passed in a post order transversal of the parse tree. An action will be associated with each rule that specifies how to combined the attributes for each of the non-terminals in the rule to form a new rule. The attributes of the non-terminals will be specified with $.1 $.2 $.3... <p><p>Rules that are repeated such as * Sum' above also may use $.0 which represents the return attribute of the last application of the rule. It will be empty for the first interation of the rule. <p><p>The PEG module uses a string of words to specify the action and $.n is replaced with the attribute of the coresponding non-terminal. <p><p>The first example will produce the list of rules use in a post order transveral of the parse tree. Here is what the output should look like<span class=block>Example1 a Atom ← any {1}<br>Atom ← any {2}<br>* Sum' ←+Atom<br>Sum ← Atom Sum'<br>E ← Sum<br>Atom ← any {a}<br>Atom ← any {3}<br>Atom ← any {4}<br>* Sum' ←+Atom<br>Sum ← Atom Sum'<br>E ← Sum<br>Atom ← (E)<br>* Sum' ←+Atom<br>Sum ← Atom Sum'<br>E ← Sum<br>Atom ← let any = E, E<br>Sum ← Atom Sum'<br>E ← Sum<br>G1 ← function any int E </span>The last line of this output will be produced by the action of the first rule of the grammar whoses action will be<span class=block>$.1 $.2 G1 ← function any int E //br </span>The any is treated as an non-terminal so $.1 refers to the word that any matches and $.2 refers to the attribute of E. Since <em>/br </em> will be used as a meta symbol in specifying the grammar <em>//br </em> with represent <em>/br</em>. <p><p><span class=keyword>Module </span> PEGEx<p><p><span class=keyword>use </span> standard<p><p><span class=keyword>use </span> PEG<p><p><span class=keyword>function </span> input seq.word <span class=literal>"function Example1 int let a = 1+2, a+(3+4)" </span><p>The PEG grammar above was transform into the string literal in postOrder function below by adding addint a <em>/br </em> before each line removing the arrow and adding an action.<p><p><span class=keyword>Function </span> postOrder seq.word<br>run(<span class=block>maketable.<span class=literal>"G1 function any int E /action $.1 $.2 G1 ← function any int E //br<br>/br E Sum /action $.1 E ← Sum //br<br>/br Sum Atom Sum' /action $.1 $.2 Sum ← Atom Sum' //br<br>/br * Sum'+Atom /action $.0 $.1 * Sum' ←+Atom //br<br>/br Atom (E) /action $.1 Atom ← (E) //br<br>/br / let any = E, E /action $.1 $.2 $.3 Atom ← let any = E, E //br<br>/br / any /action Atom ← any {$.1} //br" </span><br>, input </span>)<br>&lt;&lt; 1<p>The &lt;&lt; 1 in the last line above removes the status returned by the run function.<p><p>The function below is very similar to the above procedure but reverses the order of the lines in the output. <p><p><span class=keyword>Function </span> ReversePostOrder seq.word<br>run(<span class=block>maketable.<span class=literal>"G1 function any int E /action G1 ← functionR any int E //br $.2 //br $.1<br>/br E Sum /action E ← Sum //br $.1<br>/br Sum Atom Sum' /action Sum ← Atom Sum' //br $.2 $.1<br>/br * Sum'+Atom /action * Sum' ←+Atom //br $.1 $.0<br>/br Atom (E) /action Atom ← (E) //br $.1<br>/br / let any = E, E /action Atom ← let any = E, //br $.3 $.2 $.1<br>/br / any /action Atom ← any {$.1} //br" </span><br>, input </span>)<br>&lt;&lt; 1<p>By adding indentation to the ReversePostOrder we can represent theparse tree. The level of indentation indicates the level of the node in the parse. One detail is that the <em>/br </em> after the <em>*> </em> ends up creating unwanted blank lines. To address this we use a second PEG grammar to remore the <em>/br's </em> after the <em>*> </em>.<p><p><span class=keyword>Function </span> parseTree seq.word<br><span class=keyword>let </span> a =<span class=block>run(<span class=block>maketable.<span class=literal>"G1 function any int E /action G1 ← functionR any int E &lt;* block $.2 //br $.1 *><br>/br E Sum /action E ← Sum &lt;* block $.1 *><br>/br Sum Atom Sum' /action Sum ← Atom Sum' &lt;* block $.2 //br $.1 *><br>/br * Sum'+Atom /action * Sum' ←+Atom &lt;* block $.1 //br $.0 *><br>/br Atom (E) /action Atom ← (E) &lt;* block $.1 *><br>/br / let any = E, E /action Atom ← let any = E, E &lt;* block $.3 //br $.2 //br $.1 *><br>/br / any /action Atom ← any {$.1}" </span><br>, input </span>), </span>run(<span class=block>maketable.<span class=literal>"* S *> B /action $.0 *><br>/br / any /action $.0 $.1<br>/br * B //br /action" </span><br>, a </span>)<br>&lt;&lt; 2<p>The output of the parseTree is: <p><p>G1 ← functionR any int E<span class=block>E ← Sum<span class=block>Sum ← Atom Sum'<span class=block><br>Atom ← let any = E, E<span class=block>E ← Sum<span class=block>Sum ← Atom Sum'<span class=block>* Sum' ←+Atom<span class=block>Atom ← (E)<span class=block>E ← Sum<span class=block>Sum ← Atom Sum'<span class=block>* Sum' ←+Atom<span class=block>Atom ← any {4}<br> </span>Atom ← any {3} </span> </span> </span> </span>Atom ← any {a} </span> </span>E ← Sum<span class=block>Sum ← Atom Sum'<span class=block>* Sum' ←+Atom<span class=block>Atom ← any {2}<br> </span>Atom ← any {1} </span> </span>a </span> </span> </span>Example1 </span><p><p>The stkCode function below creates postfix code for a simple stack machine. The output is<span class=block>1 2 Add Store a a 3 4 Add Add </span><p><p><span class=keyword>Function </span> stkCode seq.word<br>run(<span class=block>maketable.<span class=literal>"G1 function any int E /action $.2<br>/br E Sum /action $.1<br>/br Sum Atom Sum' /action $.1 $.2<br>/br * Sum'+Atom /action $.0 $.1 Add<br>/br Atom (E) /action $.1<br>/br / let any = E, E /action $.2 Store $.1 $.3<br>/br / any /action $.1" </span><br>, input </span>)<br>&lt;&lt; 1<p>A PEGdebug tool is provide that will give the detail steps in the parse using the PEG module. The output of the debug tool for the parse in postfix function is provided here but no explanation of the output is provided here. <p><p><a id ="20" /><h3>Using PEGgen</h3><p><p>The transform tool can generate code for a function <em>parse </em> that allows allows code to be written equivalent to the stkCode function above.<p><p><span class=keyword>Function </span> stkCode2 seq.word result.parse(input, {initail Attribute} <span class=literal>"" </span>)<p>Below is a function PEGgen that the transform tool replaces any code after that procedure will auto generated code. One function that will be generated is<span class=block>Function parse (input:seq.seqElementType, attributeType) runresultType </span>In this case the seqElementType is word and the attributeType is seq.word. The parse function executes that actions of the rules in the order of the post order trasversal of the parse tree. Each action comibines the attributes matching the Non-terminals of the rule into a single attribute. <p><p>We need to supply a couple of functions before giving the PEGgen procedure. <p><p><span class=keyword>function </span> endMark word<br><span class=comment>{Specifies the seqElement that marks the end of the input. For UTF8 input we use an illegal byte in UTF8 format. } </span><br>encodeword.[char.254]<p><span class=keyword>function </span> toAttribute(attribute:seq.word, seqElement:seq.word) seq.word<br><span class=comment>{This is used to form the attribute for the" any" in a rule by calling toAttribute (&lt;current attribute>, [&lt;the element" any" matches>].<br>/br This function is also call when starting a * or+Non-terminal. In this case the seqElement is the empty sequence} </span><br>seqElement<p><span class=keyword>use </span> seq.word<p><p>Since any code after the PEGgen procedure is replace with auto generated code we also give a procedure that allows us to see the output of the examples above.<p><p><span class=keyword>Function </span> PEGex seq.word<br><span class=comment>{COMMAND} </span><br>stkCode2<br> + <span class=literal>"/br" </span><br> + stkCode<br> + <span class=literal>"/tag &lt;hr>" </span><br> + postOrder<br> + <span class=literal>"/tag &lt;hr>" </span><br> + ReversePostOrder<br> + <span class=literal>"/tag &lt;hr>" </span><br> + parseTree<p>The body of the PEGprocedure is formed taking the string in the stkCode procedure and making the folowing changes:<br>quote each rule and action,<br>change /action to =, change <em>/br </em> to a comma<br>change $.1 to^($.1) and do the same for the other $ expressions. <p><p><span class=keyword>function </span> PEGgen(seqElementType:word, attributeType:seq.word) seq.boolean<br><span class=comment>{wordmap: dq dq, //br<br>/br, 1#" $"} </span><br>[<span class=block><span class=literal>"G1 function any int E" </span> = <span class=literal>"^($.2)" </span><br>, <span class=literal>"E Sum" </span> = <span class=literal>"^($.1)" </span><br>, <span class=literal>"Sum Atom Sum'" </span> = <span class=literal>"^($.1)^($.2)" </span><br>, <span class=literal>"* Sum'+Atom" </span> = <span class=literal>"^($.0)^($.1)Add" </span><br>, <span class=literal>"Atom (E)" </span> = <span class=literal>"^($.1)" </span><br>, <span class=literal>"/ let any = E, E" </span> = <span class=literal>"^($.2)Store^($.1)^($.3)" </span><br>, <span class=literal>"/ any" </span> = <span class=literal>"^($.1)" </span> </span>]<p>The comment in the PEGgen procedure is significate as it sepecifies how to map a word in a rule into the attributeType. Following the = is a comma seperated list. if the word of the rule matches first word of the element in the list it will be replaced with the remainer of the words in the element. The last element of the list is the default case and is used if word of the rule does not match any of the other elements. In the default case the whole element is used and the $ is replaced with the word of the rule. <p><p><a id ="21" /><h4>Using a symbol table</h4><p><p>Next we will add a check to see that all references are define. The following should produce an error<span class=block>function Example1 int let a = 1+2, b+(3+4) </span>since <em>b </em> is not defined.<p><p>We start fresh with a new module.<p><p><span class=keyword>Module </span> PEGEx2<p><p><span class=keyword>use </span> standard<p><p><span class=keyword>use </span> set.word<p><p><span class=keyword>use </span> UTF8<p><p><span class=keyword>use </span> seq.word<p><p><span class=keyword>function </span> input seq.word <span class=literal>"function Example1 int let a = 1+2, b+(3+4)" </span><p><span class=keyword>function </span> endMark word encodeword.[char.254]<p>Instead of using seq.word as the attributeType we use<p><p>type attribute is symbols:set.word, code:seq.word<p><p><span class=keyword>function </span> toAttribute(a:attribute, b:seq.word) attribute attribute(symbols.a, b)<p>Notice that this passes allong the symbols of the previous attribute unlike the toAttribute in the last section which ignored the previous attribute. <p><p><span class=keyword>Function </span> stkCode3 seq.word<br><span class=comment>{COMMAND} </span><br><span class=keyword>let </span> initAttribute = attribute(asset.<span class=literal>"1 2 3 4" </span>, <span class=literal>"" </span>)<br><span class=keyword>let </span> finalAttribute = result.parse(input, initAttribute),<br>code.finalAttribute<p>A change is needed to modify the rule" / let any = E, E" as an action is needed to add a symbol to the symbol table before the symbol is referenced. Below this rule is replaced with" / Declare, E" and" Declare any = E" is added. The action of the second rule will add a value to the symbol table. Also, check in action of the" / any" rule is added to raise an error if the symbol is not define.<p><p>These changes have been made to the PEGgen below. Calling stkCode3 will now raise the error<span class=block>Not defined b </span><p><p><span class=keyword>function </span> PEGgen(seqElementType:word, attributeType:attribute) seq.boolean<br><span class=comment>{wordmap: 1#" $"} </span><br>[<span class=block><span class=literal>"G1 function any int E" </span> = $.2<br>, <span class=literal>"E Sum" </span> = $.1<br>, <span class=literal>"Sum Atom Sum'" </span> = attribute(symbols.$.0, code.$.1 + code.$.2)<br>, <span class=literal>"* Sum'+Atom" </span> = attribute(symbols.$.0, code.$.0 + code.$.1 + <span class=literal>"Add" </span>)<br>, <span class=literal>"Atom (E)" </span> = $.1<br>, <span class=literal>"/ Declare E" </span> = attribute(symbols.$.0, code.$.1 + code.$.2)<br>, <span class=literal>"/ any" </span><br>= <span class=keyword>assert </span> 1#code.$.1 ∈ symbols.$.1 <span class=keyword>report </span> <span class=literal>"Not defined^(code.$.1)", </span><br>attribute(symbols.$.0, code.$.0 + code.$.1)<br>, <span class=literal>"Declare let any = E," </span><br>= attribute(symbols.$.0 + 1^code.$.1, code.$.2 + <span class=literal>"Store" </span> + code.$.1) </span>]<p><a id ="22" /><h4>Adding Error Recover</h4><p><p>This section describes how to locate the location of the error where a parse fails. The same grammar is used as in the section above with an rule added for if-then-else. The module in this section runs mulitple examples and traps any raised errors when processing the the example. <p><p>This example uses many options of genPEG. Here is a summary of what the options do: <p><p><table><tr><td> <strong>Option </strong><td> <strong>Value </strong><td> <strong>Purpose </strong><tr><td> seqElementType<td> type<td> the element type of the sequence to be parsed<tr><td> attributeType<td> type<td> the type of the attribute constructed by the parse.<tr><td> resultType: type<td> the tyoe name to be used for the results of the parse.commonType type<td> type of an immutable value that will be available through out the parse. This value is supplied in an parameter of the parse. <tr><td> commonName<td> word<td> The name to use in an action to reference the above immutable value. When using this option also include in the parameters of genPEG a parameter of the form commonName:commmonType<tr><td> wordmap<td> map value<td> How to map a terminal in rule to a element of the sequence to be parsed<tr><td> error<td> flag<td> include information for pin pointing where the parse failed.</table><p><p>An option may be specified in the parameter list of genPEG or in the first comment of genPEG<table><tr><td> <strong>Kind </strong><td> <strong>As </strong> <strong>parameter </strong><td> <strong>In </strong> <strong>comment </strong><tr><td> type<td> option:value<td> comment:type<tr><td> word<td><td> option = value<tr><td> flag<td> option:boolean<td> option =<tr><td> map value<td><td> option = comma seperated list.</table><p><p>The resultType may have the following fields:<span class=block><br>result: the final attribute<br>status: one of the words Match, MatchPrefix, or Failed.<br>place: the first unprocess element of the input. <br>input: the input sequence including the endMark.<br>recoveryEnding: On failure, a sequence of words that can be added to the input of the successfully parsed elements of the input to form a string that can be parsed.  </span><p><p>The recoveryEnding also provides a way to construct a input that can be parsed. In this section we use the same parser to parse it again. But to do a successful parse the semantic checking must not be done. This example use the commonName and commonType options to add a parameter to the parse to turn semantic checking on or off. In the Tau implementation instead of use the same parser a second parser is used that pretty prints the input. <p><p>Here are thedescription of the examples used the output they give.The first line of the ouput is the input to the parse<span class=block>Example of a successful parse.<span class=block>function Example1 int let a = 1+2, a+(3+4) status: Match place:18 code:1 2 Add Store a a 3 4 Add Add </span>Example of a parse with extra words at the end.<span class=block>function Example2 int let a = 1+2, a+(3+4) extra words status: MatchPrefix place:18 code:1 2 Add Store a a 3 4 Add Add </span>Example of a Failed parse that never executes an action.<span class=block>function Example3 int let status:Failed place:0 code: </span>Example of a semantic error:<span class=block>function Example4 int let a = 1+2, (((b)))+(3+4) Error at 15 message:b is not defined. To finish parse, ')))+(3+4) ' was replaced with '))) ' </span>Another example of a successful parse<span class=block>function Example5 int if 1 then 2+3 else 4 status: Match place:12 code:1 2 3 Add 4 If </span>Example of parse that failed and then backtrack ending up match none of the rule, The maxinum the maxium place in the input where a reduce was done was used as recovery point. In this example the recover point is a the reduction of 2+3.<span class=block>function Example6 int if 1 then 2+3 else Failed Error at 10 message:syntax error. To finish parse, ' else ' was replaced with ' else any ' </span> </span><p><p><span class=keyword>Module </span> PEGEx3<p><p><span class=keyword>use </span> standard<p><p><span class=keyword>use </span> set.word<p><p><span class=keyword>use </span> UTF8<p><p><span class=keyword>use </span> seq.word<p><p><span class=keyword>function </span> endMark word encodeword.[char.254]<p>type attribute is symbols:set.word, code:seq.word<p><p><span class=keyword>function </span> toAttribute(a:attribute, b:seq.word) attribute attribute(symbols.a, b)<p><span class=keyword>use </span> process.seq.word<p><p><span class=keyword>Function </span> stkCode4 seq.word<br><span class=comment>{COMMAND} </span><br><span class=keyword>let </span> data =<span class=block>[<span class=block><span class=literal>"function Example1 int let a = 1+2, a+(3+4)" </span><br>, <span class=literal>"function Example2 int let a = 1+2, a+(3+4) extra words" </span><br>, <span class=literal>"function Example3 int let" </span><br>, <span class=literal>"function Example4 int let a = 1+2, (((b)))+(3+4)" </span><br>, <span class=literal>"function Example5 int if 1 then 2+3 else 4" </span><br>, <span class=literal>"function Example6 int if 1 then 2+3 else" </span> </span>] </span><span class=keyword>for </span> acc = <span class=literal>"" </span>, in ∈ data<br><span class=keyword>do </span><span class=block><span class=keyword>let </span> p = process.parser.in,<br>acc + <span class=literal>"^(in)/br" </span> + <span class=keyword>if </span> aborted.p <span class=keyword>then </span> message.p + <span class=literal>"/br" </span> <span class=keyword>else </span> result.p + <span class=literal>"/br", </span> </span>acc<p><span class=keyword>function </span> parser(in:seq.word) seq.word<br><span class=keyword>let </span> initAttribute = attribute(asset.<span class=literal>"1 2 3 4" </span>, <span class=literal>"" </span>)<br><span class=keyword>let </span> p = parse(in, initAttribute, true)<br><span class=keyword>let </span> finalAttribute = result.p,<br><span class=keyword>if </span> status.p ∈ <span class=literal>"Failed" </span> ∧ place.p > 0 then <span class=literal>"Failed" </span> + errormessage(<span class=literal>"syntax error" </span>, recoverInfo(pop.stk.p, input.p, place.p))<br><span class=keyword>else </span> <span class=literal>"status:^(status.p)place:^(place.p)code:" </span> + code.finalAttribute<p><span class=keyword>function </span> errormessage(message:seq.word, rinfo:recoverInfo) seq.word<br><span class=comment>{provides a uniform way to generate an error message within an action} </span><br><span class=keyword>let </span> ending = recoveryEnding.rinfo<br><span class=keyword>let </span> corrected = subseq(input.rinfo, 1, place.rinfo - 1) + ending<br><span class=keyword>let </span> reparse = parse(corrected, attribute(empty:set.word, <span class=literal>"" </span>), false),<br><span class=keyword>if </span> status.reparse ∉ <span class=literal>"Match" </span> <span class=keyword>then </span> <span class=literal>"Failed reparse" </span> + corrected<br><span class=keyword>else </span> <span class=literal>"Error at^(place.rinfo)message:^(message). To finish parse, '^(subseq(input.rinfo, place.rinfo, n.input.rinfo - 1))' was replaced with '^(ending)'" </span><p><span class=keyword>function </span> PEGgen(<br><br>seqElementType:word<br><br>, attributeType:attribute<br><br>, resultType:recoverInfo<br><br>, rinfo:recoverInfo<br><br>, commonType:boolean<br><br>, checkSemantics:boolean<br><br>) seq.boolean<br><span class=comment>{commonName: checkSemantics error: wordmap: 1#" $"} </span><br>[<span class=block><span class=literal>"G1 function any int E" </span> = $.2<br>, <span class=literal>"E if E then E else E" </span> = attribute(symbols.$.0, code.$.1 + code.$.2 + code.$.3 + <span class=literal>"If" </span>)<br>, <span class=literal>"/ Sum" </span> = $.1<br>, <span class=literal>"Sum Atom Sum'" </span> = attribute(symbols.$.0, code.$.1 + code.$.2)<br>, <span class=literal>"* Sum'+Atom" </span> = attribute(symbols.$.0, code.$.0 + code.$.1 + <span class=literal>"Add" </span>)<br>, <span class=literal>"Atom (E)" </span> = $.1<br>, <span class=literal>"/ Declare E" </span> = attribute(symbols.$.0, code.$.1 + code.$.2)<br>, <span class=literal>"/ ! if ! let any" </span><br>= <span class=keyword>assert </span> not.checkSemantics ∨ 1#code.$.1 ∈ symbols.$.1 <span class=keyword>report </span> errormessage(<span class=literal>"^(code.$.1)is not defined" </span>, rinfo),<br>attribute(symbols.$.0, code.$.0 + code.$.1)<br>, <span class=literal>"Declare let any = E," </span><br>= attribute(symbols.$.0 + 1^code.$.1, code.$.2 + <span class=literal>"Store" </span> + code.$.1) </span>]<p><a id = patterns /><p><p><a id ="23" /><h1>Example of Renaming Function</h1><p><p><span class=keyword>Module </span> patterns<p><p><span class=keyword>use </span> standard<p><p><span class=keyword>use </span> seq.*<p><p><span class=keyword>use </span> set.*<p><p>The pattern3 transformation will change the value of orginal to look like the value of changed in the procedure below.<p><p><span class=keyword>function </span> example3(i:int, x:int) int<br><span class=keyword>let </span> original = [i + 1, x + 1, 3 + 1, 3 * 1 + 1, i + x + 1]<br><span class=keyword>let </span> changed = [inc.i, inc.x, inc.3, inc(3 * 1), inc(i + x)],<br>0<p>To specify this transformation we must first define the inc function.<p><p><span class=keyword>function </span> inc(i:int) int i + 1<p>We will use a single parameterized pattern specified with the function below. <p><p><span class=keyword>Function </span> pattern3(t:int) seq.int [t + 1, inc.t]<p>The result type of the function is the sequence of the type of the expression being translated. It this case the expression type is type int so the result type of pattern3 is seq.int. The parameter t of pattern3 will match any expression of type int. the pattern3 will be applied five times and t will take on the values i, x, 3, 3 * 1 /and i+x. <p><p>The body of pattern3 is of the form [old, new] where old is the old expression and new is the new expression. The t in the new expression will be replace with what t matches in the old expression. <p><p>Expressions can also be transform for function in parameterized modules. To do this one must define the type * to represent the parametized type T. <p><p>type * is a:seq.int<p><p><span class=keyword>Function </span> pattern4(s:seq.*) seq.*<br><span class=comment>{use a separate function to get the first element of a sequence} </span><br>[1#s, first.s]<p><span class=keyword>Function </span> pattern5(s:seq.*, i:int) seq.*<br><span class=comment>{switches order of parameters} </span><br>[i#s, s#i]<p>The parameterized module <em>firstop </em> defines the first function and the function that uses a different parameter order. The definition is below. <p><p>Some use's are need to make the function and types used in the pattern4 and pattern5 available in the module.<p><p><span class=keyword>use </span> seq.*<p><p><span class=keyword>use </span> firstop.*<p><p>Pattern5 and pattern6 transformation will change the value of orginal to look like the value of changed in the procedure below. <p><p><span class=keyword>function </span> example4 int<br><span class=keyword>let </span> original = 2#[1, 2, 3] + 1#[3, 4, 5]<br><span class=keyword>let </span> changed = [1, 2, 3]#2 + first.[3, 4, 5],<br>0<p>The use below isincluded so example4 will compile. <p><p><span class=keyword>use </span> firstop.int<p><p><span class=keyword>Module </span> firstop.T<p><p><span class=keyword>use </span> seq.T<p><p><span class=keyword>Function </span> first(s:seq.T) T 1#s<p><span class=keyword>Function </span> #(s:seq.T, i:int) T s#1<p><a id ="24" /><h1>Profiling</h1><p><p>Profiling works by adding code to the procedure that tracks how much time is spent in each subprocedure that is called. When the results are display the largest time is found and normalized to 100. All other calls are in 100th's of the largest time. <p><p><a href =./profileExample.html > Result of run profileExample defined below. </a><p><p><span class=keyword>Module </span> profileExample<p><p><span class=keyword>use </span> seq.file<p><p><span class=keyword>use </span> file<p><p><span class=keyword>use </span> standard<p><p><span class=keyword>use </span> profile<p><p><span class=keyword>use </span> process.seq.word<p><p>To add profiling to the functions in this Module the follow steps were taken:<br>1. To the function to be profiled add {OPTION PROFILE} NOINLINE was also include for these small function since if a procedure is expaned inline, no profile results will be shown for that procedure.<br>2. Add a use clause "use profile"<br>3. Add profileresults. "time" to make the profile results visible<br>4. In the.bld file add to the makelib command the option profile =<br>5. In the sources for the makelib command also+tests profile+common graphcode<br>6. Make sure the uses option of the makelib command includes commmon. <p><p><span class=keyword>Function </span> profileExample seq.word<br><span class=comment>{OPTION PROFILE NOINLINE COMMAND /strong profile Example} </span><br><span class=keyword>let </span> p = process.processtest(2^2 + 3)<br><span class=keyword>let </span> p2 = subtest(2^2 + 3),<br><span class=literal>"test^({subtest.4+} result.p)^(profileresults.<span class=literal>"time" </span>)" </span><p><span class=keyword>function </span> subtest(i:int) seq.word<br><span class=comment>{OPTION PROFILE NOINLINE} </span><br>%(i^10 + tr.i)<p><span class=keyword>function </span> tr(n:int) int<br><span class=comment>{OPTION PROFILE NOINLINE} </span><br><span class=keyword>let </span> a = %.n,<br><span class=keyword>if </span> n &lt; 3 <span class=keyword>then </span> n <span class=keyword>else </span> tr(n - 1) + tr(n - 2)<p><span class=keyword>function </span> processtest(i:int) seq.word<br><span class=comment>{OPTION PROFILE NOINLINE} </span><br>subtest.i<p><a id = enum /><p><p><a id ="25" /><h1>enumexample</h1><p><p><span class=keyword>Module </span> enumexample<p><p><span class=keyword>use </span> bits<p><p><span class=keyword>use </span> standard<p><p>The function name genEnum is treated as magic by the transform command. It auto generates the code to implement enumeration types. This example implements two enumeration types. In the first enumeration type Each word in the value list is given a value starting with 0. <p><p>In the first example The question mark is a place holder for numbers that with not be include in the type.<p><p>The second example uses an existing data type byte. <p><p><span class=keyword>function </span> genEnum seq.seq.word<br>[<span class=block><span class=literal>"newType: numbers values: ? two0 two1 ? two2 ? ? ? two3" </span><br>, <span class=literal>"existingType: byte decodeName: twodecode values: Two0 1 Two1 2 Two2 4 Two3 0x08" </span> </span>]<p>&lt;&lt;&lt;&lt; Below is auto generated code >>>><p><p>type numbers is toint:int<p><p><span class=keyword>Export </span> toint(numbers) int<p><span class=keyword>Export </span> numbers(i:int) numbers<p><span class=keyword>Export </span> type:numbers<p><span class=keyword>Function </span> =(a:numbers, b:numbers) boolean toint.a = toint.b<p><span class=keyword>Function </span> two0 numbers numbers.1<p><span class=keyword>Function </span> two1 numbers numbers.2<p><span class=keyword>Function </span> two2 numbers numbers.4<p><span class=keyword>Function </span> two3 numbers numbers.8<p><span class=keyword>Function </span> decode(code:numbers) seq.word<br><span class=keyword>let </span> discard = [two0, two1, two2, two3]<br><span class=keyword>let </span> i = toint.code,<br>if<p><span class=keyword>Function </span> Two0 byte tobyte.1<p><span class=keyword>Function </span> Two1 byte tobyte.2<p><span class=keyword>Function </span> Two2 byte tobyte.4<p><span class=keyword>Function </span> Two3 byte tobyte.8<p><span class=keyword>Function </span> twodecode(code:byte) seq.word<br><span class=keyword>let </span> discard = [Two0, Two1, Two2, Two3]<br><span class=keyword>let </span> i = toint.code,<br>if<p><a id ="26" /><h2>oldstuff</h2><p><p>alias usegraph =" tau tools usegraph"<p><p>alias transform =" tau tools transform"<p><p>A function can be profiled to see where the time is being spent in a program. An example of doing this is given<a href ="./profileExampleSrc.html" >here. </a>Which produces the output<a href ="./profileExample.html" >here. </a><p><p>The <span class=keyword>htmlcode </span> cmd create html from source files pretty prints the file and adds syntax highlighting and a module index. It is useful for examining source code. For example block htmlcode+built core.libsrc<p><p><a id ="27" /><h2>Introduction to intermediate code produced by compiler</h2><p><p>This section provides a brief explanation of the control structure used in the intermediate code. The follow function for calculating factorials is used as an example.<p><p><span class=keyword>Function </span> fact2(a:int, result:int) int<br><span class=keyword>if </span> a = 1 <span class=keyword>then </span> result <span class=keyword>else </span> if a = 0 <span class=keyword>then </span> result <span class=keyword>else </span> fact2(a - 1, result * a)<p>The intermediate code is represented by a sequence of symbols. The text representation of a symbol does not contain all the information in a symbol. The function fact2 is represented by the text. " helloworld:test2 (int, int) int" The module of the symbol is represented but not the library. Each type also has module and library but only the name of the type is given. <p><p>The local variables are represented by % followed by a number, for example %2. Local variables also have name associated with them that is not in the text representation. <p><p>The body of fact2 can be rewritten as a sequence of statments using explicit gotos. All the statements are wrap up in a block. <span class=block>Block (<br>if a = 1 then goto (+1) else goto (+2)<br>, Exit (result)<br>, if a = 0 then goto (+1) else goto (+2)<br>, Exit (result)<br>, Exit (fact2 (a-1, result * a))) </span> 