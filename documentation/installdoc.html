<!doctype html> <html lang="en"> <meta charset="utf-8"> <head> <link rel="stylesheet" href="../daws/codeExample.css"></head><body> <p> <p> <br> <h1>The Tau Enviorment</h1> <p> <h2>Installing Tau</h2> <p> <p>Make sure clang is installed. On macOS, Clang is available if the command-line tools are installed. <p>Download the zip file from GitHub(Repository is dwsandberg/Tau) <p>Unzip to a directory which we will call &lt;Tau>. This directory will serve as tau's working directory. You are free to choose another name. <p>Modify &lt; PATH > environment variable to include the absolute path to &lt;Tau>/bin. <p>Open a terminal and change to the &lt;Tau> directory. <p>Run"bash bin/taubuild.sh release.bld". This is likely to generate a warning message about the llvm spec. <h2>HelloWorld</h2> <p> <p>Here are the basics for creating a program that prints"Hello World!". <p>Make sure you are in the &lt;Tau> directory. First, create a subdirectory in the &lt;Tau> directory named <em>hello</em>. The hello directory will contain the program's components. <p>In the hello directory, create a text file named text.ls containing the following five lines, two of which are blank: <span class="block">Module hello <br> <br>use standard <br> <br>Function hello seq.word{COMMAND}"Hello World!"</span> This is the source for the program. By convention, the name of the Module is the same as the name of the file. <p>Next, create a file named hello.bld which describes with how to build and run the program. Its contents are the following lines: <span class="block">define makelib taubc makebitcode <br> <br>makelib taubc.libinfo+hello hello.ls <br>output: hello.lib <br> <br>define hello hello <br> <br>hello output: hello.html <br> <br>define open shell open input: <br> <br>open input: hello.html output: hello.txt</span> <p>Now run the following command in the &lt;Tau> directory <span class="block">bash taubuild.sh hello/hello.bld</span> <ol> <li>Running the above command does the following Create an executable with the name of &lt;Tau>/built/hello.lib from the source code. (Paragraphs one and two of the build file.) <li>The program is executed and the output is placed in &lt;Tau>/built/hello.html. (Paragraphs three and four of the build file.) <li>A web browser opens the file &lt;Tau>/built/hello.html.(Last two paragraphs of the build file.) <li>A tar archive of the source files is created in the directory ~/taubackups/hello/. (An archive is created on successful completion of the build file.)</ol> <p> <p>With additional steps, typing <em>hello</em> at the command prompt will run the program. One of the commands needed to do this is buildhelp, which is supplied in the release. To gain access to all the commands in the release, type: <span class="block">source built/taucommands.sh</span> <p>Now type <span class="block">buildhelp hello.libsrc shellscript: </span> which will bring up a shell function definition for hello in a web browser. Copy this command and run it as a shell command. Now typing <em>hello</em> at the command prompt will run the program. <h2>Commands</h2> <p> <p>The following assumes that"source built/taucommands.sh"has been executed in the command shell. <ul> <li>In languages such as C, a function main provides the single entry point into a program. In Tau, there can be many entry points, and they are specified by including the word <em>COMMAND</em> in a comment of a function that meets the following conditions: Is a valid function <li>Define with Function <li>Has parameter types of seq.word, seq.file, or boolean. <li>Has a return type of seq.word, seq.byte, seq.UTF8, or seq.file <li>the word COMMAND is in a comment immediately following the return type. </ul> <p> <h3>Command Syntax</h3> <p> <p>Tau documentation of the commands provided in the release is given by the command tauhelp. This command was defined with <span class="block">Function tauhelp(cmd:seq.word, %:seq.word)seq.word{COMMAND... }... </span> Removing from the definition the paraenthesis and commas, and replacing the types of the arguments actual values will give the syntax for calling the function on the command line. <span class="block">tauhelp cmd: %:full</span> Run the command gives <a href="../documentation/cmddoc.html">this result</a> <p>The order the parameters are specified does not matter. An omitted parameter of type seq.word is given an empty value. So the following will all give the same result: <span class="block"> <br>tauhelp cmd: %:full <br>tauhelp %:full cmd: <br>tauhelp %:full</span> <p>If a value is supplied for cmd, only documentation for that command is given. Since cmd is both the first argument given and the first argument in the defining procedure, the cmd can be omitted. Hence the following will give the same result: <span class="block"> <br>tauhelp cmd: usegraph %: full <br>tauhelp usegraph %: full</span> <p>For boolean parameters, the value is false if the parameter is omitted or if the value is <em>false</em>. All other values for a boolean parameter are interpreted as <em>true</em>. <p>For parameters of type seq.file in the defining procedure, The string in the command is processed as filenames and the file from the filing system is fetched. Multiple formats are allowed for file names. For example the usegraph command takes multiple file names as the argument. <span class="block">usegraph core/standard.ls core/word.ls core/sort.ls</span> The directory does not need to be specified for every file: <span class="block">+core standard.ls word.ls sort.ls</span> The file extension also does not need to be repeated: <span class="block">+core standard.ls word sort</span> The file extension can be before the first file: <span class="block">+directory.ls standard word sort</span> If There is no directory use: <span class="block">+.ls standard word sort</span> The following three string all represent the same file <span class="block">directory/directory/file1.ls <br>+directory directory/file1.ls <br>+directory/directory file1.ls</span> <h2>taubuild.sh</h2> <p> <p>The <em>taubuild</em> bash script determines how to build a program from the instructions in .bld files. The .bld file contains commands. Every command maps a set of input files to a set of output files. The input files must be distinct from the output files. <p>The first output forms a node in a graph. Additional output files are predecessors, and input files are successors. The command is defined in a library file. This library file is also a successor. <p>This forms a DAG. All the source files can be constructed one by one, starting from the graph's sources and working toward its sinks. Thus, a bash script is constructed to build all the output files. This bash script also contains a list of shasum of the sources in the DAG. The script used in the last successful build run is retained. By comparing the current shasums with the previous shasums, the files that need to be rebuilt can be determined. <p>The last successful run of the hello.bld will produce a file &lt;Tau>/built/build_helloold.sh. A new bash script is created named &lt;Tau>/built/build_hello.sh. This file contains shasums of all the source files used to build the program. The new script is run. If there are no errors, the build_hello.sh file is renamed to build_helloold.sh. A tar archive is created. <p>The.bld file is a sequence of paragraphs of words. <p>The first word of the paragraph is a command. There are two predefined commands: #, and define. The # command treats the paragraph as a comment. <p>The define command introduces a user-defined command. The second word in the paragraph is the name of the command. The third word is the name of the executable where that command is defined. The fourth word is the name of the command in the executable. The command to reference the command to invoke the Tau compiler that produces an executable would be <span class="block">define makelib taubc makebitcode</span> <p>A user-defined command must occur before its use. The paragraphs can be reordered as long as this constraint is maintained. <p>An alternate form for the makelib command in the hello.bld file is <span class="block">makelib output: +built hello.lib input: +built taubc.libinfo+hello hello.ls</span> The order of parameters does not matter, so this command is equivalent: <span class="block">makelib input: +built taubc.libinfo+hello hello.ls output: +built hello.lib</span> If input: follows the command it can be omitted. A"+built"is always added to the input and output, so it can also be omitted to get <span class="block">makelib tau.libinfo+hello hello.ls output: hello.lib</span> <p>If <em>shell</em> is the third word of a define, the remainder of the paragraph will be included as a command in the bash script, with the input: and output: replaced by the corresponding file names specified in the use of the file. For example, the lines from the hello.bld file <span class="block">define open shell open input: <br> <br>open input: hello.html output: hello.txt</span> will produce the bash script line <span class="block">open hello.html</span> <h2>Using PEG in Tau</h2> <p> <p>This document describes how to use Tau to create PEG grammars to parse the following seq of words: <p> <a id="Example1" href="#/br">function</a> Example1 int <br> <span class="keyword">let</span> a = 1 + 2, <br>a + (3 + 4) <p>We assume the reader understands basic grammar terms such as parse tree, and non-terminal, terminal. <p>A PEG grammar to parses the above is <span class="block">G1 ← function any int E <br>E ← Sum <br>Sum ← Atom Sum' <br>* Sum' ←+Atom <br>Atom ←(E) <br>/ let any = E, E <br>/ any</span> <h3>Using the PEG module</h3> <p> <p>Tau provides a module PEG for using a PEG grammar to transform a sequence of words into another sequence of words. An attribute will be passed in a post-order traversal of the parse tree. An action will be associated with each rule that specifies how to combine the attributes for each of the non-terminals in the rule to form a new rule. The attributes of the non-terminals will be specified as $.1, $.2, $.3,... <p>Rules that are repeated, such as * Sum' above, also may use $.0 which represents the return attribute of the last application of the rule. It will be empty for the first iteration of the rule. <p>The PEG module uses a string of words to specify the action, and $.n is replaced with the attribute of the corresponding non-terminal. <p>The first example will produce the list of rules used in a post-order traversal of the parse tree. Here is what the output should look like <span class="block">Example1 a Atom ← any{1} <br>Atom ← any{2} <br>* Sum' ←+Atom <br>Sum ← Atom Sum' <br>E ← Sum <br>Atom ← any{a} <br>Atom ← any{3} <br>Atom ← any{4} <br>* Sum' ←+Atom <br>Sum ← Atom Sum' <br>E ← Sum <br>Atom ←(E) <br>* Sum' ←+Atom <br>Sum ← Atom Sum' <br>E ← Sum <br>Atom ← let any = E, E <br>Sum ← Atom Sum' <br>E ← Sum <br>G1 ← function any int E</span> <p>The last line of this output will be produced by the action of the first rule of the grammar whoses action will be <span class="block">$.1 $.2 G1 ← function any int E //br</span> The any is treated as an non-terminal so $.1 refers to the word that any matches and $.2 refers to the attribute of E. Since '/br' will be used as a meta symbol in specifying the grammar '//br' with represent '/br'. <p> <span class="keyword" id="PEGEx">Module</span> PEGEx <p>use standard <p>use PEG <p> <a id="input.word" href="#PEGEx">function</a> input seq.word <span class="literal">"function Example1 int let a = 1+2, a+(3+4)"</span> <p>The PEG grammar above was transformed into the string literal in the postOrder function below by adding adding a '/br' before each line, removing the arrow and adding an action. <p> <a id="postOrder.word" href="#PEGEx">Function</a> postOrder seq.word <br>run( <span class="block">maketable. <span class="literal">"G1 function any int E /action $.1 $.2 G1 ← function any int E //br /br<br>E Sum /action $.1 E ← Sum //br /br<br>Sum Atom Sum' /action $.1 $.2 Sum ← Atom Sum' //br /br<br>* Sum'+Atom /action $.0 $.1 * Sum' ←+Atom //br /br<br>Atom(E)/action $.1 Atom ←(E)//br /br<br>/ let any = E, E /action $.1 $.2 $.3 Atom ← let any = E, E //br /br<br>/ any /action Atom ← any{$.1}//br"</span> <br>, input</span>) <br> &lt;&lt; 1 <p>The &lt;&lt; 1 in the last line above removes the status returned by the run function. <p>The function below is very similar to the above procedure, but reverses the order of the lines in the output. <p> <a id="ReversePostOrder.word" href="#PEGEx">Function</a> ReversePostOrder seq.word <br>run( <span class="block">maketable. <span class="literal">"G1 function any int E /action G1 ← functionR any int E //br $.2 //br $.1 /br<br>E Sum /action E ← Sum //br $.1 /br<br>Sum Atom Sum' /action Sum ← Atom Sum' //br $.2 $.1 /br<br>* Sum'+Atom /action * Sum' ←+Atom //br $.1 $.0 /br<br>Atom(E)/action Atom ←(E)//br $.1 /br<br>/ let any = E, E /action Atom ← let any = E, //br $.3 $.2 $.1 /br<br>/ any /action Atom ← any{$.1}//br"</span> <br>, input</span>) <br> &lt;&lt; 1 <p>By adding indentation to the ReversePostOrder, we can represent the parse tree. The level of indentation indicates the node's position in the parse. One detail is that <em>the</em> <br>after the <em>'*></em> ends up creating unwanted blank lines. To address this we use a second PEG grammar to remore the <em>/br's</em> after the <em>'*></em>. <p> <a id="parseTree.word" href="#PEGEx">Function</a> parseTree seq.word <br> <span class="keyword">let</span> a = <span class="block">run( <span class="block">maketable. <span class="literal">"G1 function any int E /action G1 ← functionR any int E // $.2 //br $.1 /block /br<br>E Sum /action E ← Sum // $.1 /block /br<br>Sum Atom Sum' /action Sum ← Atom Sum' // $.2 //br $.1 /block /br<br>* Sum'+Atom /action * Sum' ←+Atom // $.1 //br $.0 /block> /br<br>Atom(E)/action Atom ←(E)// $.1/block /br<br>/ let any = E, E /action Atom ← let any = E, E // $.3 //br $.2 //br $.1 /block /br<br>/ any /action Atom ← any{$.1}"</span> <br>, input</span>),</span> run( <span class="block">maketable. <span class="literal">"* S B /action $.0 /block /br<br>/ any /action $.0 $.1 /br<br>* B //br /action"</span> <br>, a</span>) <br> &lt;&lt; 2 <p>The output of the parseTree is: <p>G1 ← functionR any int E <span class="block">E ← Sum <span class="block">Sum ← Atom Sum' <span class="block"> <br>Atom ← let any = E, E <span class="block">E ← Sum <span class="block">Sum ← Atom Sum' <span class="block">* Sum' ←+Atom <span class="block">Atom ←(E) <span class="block">E ← Sum <span class="block">Sum ← Atom Sum' <span class="block">* Sum' ←+Atom <span class="block">Atom ← any{4} <br></span> Atom ← any{3}</span></span></span></span> Atom ← any{a}</span></span> E ← Sum <span class="block">Sum ← Atom Sum' <span class="block">* Sum' ←+Atom <span class="block">Atom ← any{2} <br></span> Atom ← any{1}</span></span> a</span></span></span> Example1</span> <p>The stkCode function below creates postfix code for a simple stack machine. The output is <span class="block">1 2 Add Store a a 3 4 Add Add</span> <p> <a id="stkCode.word" href="#PEGEx">Function</a> stkCode seq.word <br>run( <span class="block">maketable. <span class="literal">"G1 function any int E /action $.2 /br<br>E Sum /action $.1 /br<br>Sum Atom Sum' /action $.1 $.2 /br<br>* Sum'+Atom /action $.0 $.1 Add /br<br>Atom(E)/action $.1 /br<br>/ let any = E, E /action $.2 Store $.1 $.3 /br<br>/ any /action $.1"</span> <br>, input</span>) <br> &lt;&lt; 1 <p>A PEGdebug tool is provided that will give the detailed steps in the parse using the PEG module. The output of the debug tool for the parse in the postfix function is provided here, but no explanation of the output is provided. <h3>Using genPEG</h3> <p> <p>The transform tool can generate code for a function <em>parse</em> that allows code to be written equivalent to the stkCode function above. <p> <a id="stkCode2.word" href="#PEGEx">Function</a> stkCode2 seq.word result.parse(input, {initail Attribute} <span class="literal">""</span>) <p>Below is a function genPEG that the transform tool replaces any code after that procedure with auto-generated code. One function that will be generated is <span class="block">Function parse(input:seq.seqElementType, attributeType)runresultType</span> In this case, the seqElementType is word and the attributeType is seq.word. The parse function executes the actions of the rules in the order of the post-order traversal of the parse tree. Each action combines the attributes matching the Non-terminals of the rule into a single attribute. <p>We need to supply a couple of functions before giving the genPEG procedure. <p> <a id="endMark" href="#PEGEx">function</a> endMark word <br> <span class="comment">{Specifies the seqElement that marks the end of the input. For UTF8 input we use an illegal byte in UTF8 format. }</span> <br>encodeword.[char.254] <p> <a id="toAttribute:seq.word:seq.word:seq.word" href="#PEGEx">function</a> toAttribute(attribute:seq.word, seqElement:seq.word) seq.word <br> <span class="comment">{This is used to form the attribute for the"any"in a rule by calling toAttribute(&lt;current attribute>,[&lt;the element"any"matches>].This function is also called when starting a * or+Non-terminal. In this case, the seqElement is the empty sequence}</span> <br>seqElement <p>use seq.word <p>Since any code after the genPEG procedure is replaced with auto-generated code, we also provide a procedure that shows the output of the examples above. <p> <a id="PEGex.word" href="#PEGEx">Function</a> PEGex seq.word <br> <span class="comment">{COMMAND}</span> <br>stkCode2 <br> + <span class="literal">""</span> <br> + stkCode <br> + <span class="literal">"&lt;hr>"</span> <br> + postOrder <br> + <span class="literal">"&lt;hr>"</span> <br> + ReversePostOrder <br> + <span class="literal">"&lt;hr>"</span> <br> + parseTree <p>The body of the PEGprocedure is formed by taking the string in the stkCode procedure and making the following changes: <br>quote each rule and action, <br>change /action to =, <em>change</em> <br>to a comma <br>change $.1 to:($.1)and do the same for the other $ expressions. <p> <a id="genPEG:word:seq.word:seq.boolean" href="#PEGEx">function</a> genPEG(seqElementType:word, attributeType:seq.word) seq.boolean <br> <span class="comment">{wordmap: dq dq, //br,"$"sub 1}</span> <br>[ <span class="block"> <span class="literal">"G1 function any int E"</span> = <span class="literal">":($.2)"</span> <br>, <span class="literal">"E Sum"</span> = <span class="literal">":($.1)"</span> <br>, <span class="literal">"Sum Atom Sum'"</span> = <span class="literal">":($.1):($.2)"</span> <br>, <span class="literal">"* Sum'+Atom"</span> = <span class="literal">":($.0):($.1)Add"</span> <br>, <span class="literal">"Atom(E)"</span> = <span class="literal">":($.1)"</span> <br>, <span class="literal">"/ let any = E, E"</span> = <span class="literal">":($.2)Store:($.1):($.3)"</span> <br>, <span class="literal">"/ any"</span> = <span class="literal">":($.1)"</span></span>] <p>The comment in the genPEG procedure is significant as it specifies how to map a word in a rule into the attributeType. Following the = is a comma-separated list. If the word of the rule matches the first word of the element in the list, it will be replaced with the remainder of the words in the element. The last element of the list is the default case and is used if the word of the rule does not match any of the other elements. In the default case, the entire element is used, and $ is replaced with the rule's word. <p>&lt;h4> Using a symbol table&lt;/h4> <p>Next, we will add a check to see that all references are defined. The following should produce an error <span class="block">function Example1 int let a = 1+2, b+(3+4)</span> since <em>b</em> is not defined. <p>We start fresh with a new module. <p> <span class="keyword" id="PEGEx2">Module</span> PEGEx2 <p>use standard <p>use set.word <p>use UTF8 <p>use seq.word <p> <a id="input.word" href="#PEGEx2">function</a> input seq.word <span class="literal">"function Example1 int let a = 1+2, b+(3+4)"</span> <p> <a id="endMark" href="#PEGEx2">function</a> endMark word encodeword.[char.254] <p>Instead of using seq.word as the attributeType we use <p>type attribute is symbols:set.word, code:seq.word <p> <a id="toAttribute:attribute:seq.word:attribute" href="#PEGEx2">function</a> toAttribute(a:attribute, b:seq.word) attribute attribute(symbols.a, b) <p>Notice that this passes along the symbols of the previous attribute, unlike the toAttribute in the last section, which ignored the previous attribute. <p> <a id="stkCode3.word" href="#PEGEx2">Function</a> stkCode3 seq.word <br> <span class="comment">{COMMAND}</span> <br> <span class="keyword">let</span> initAttribute = attribute(asset. <span class="literal">"1 2 3 4"</span>, <span class="literal">""</span>) <br> <span class="keyword">let</span> finalAttribute = result.parse(input, initAttribute), <br>code.finalAttribute <p>A change is needed to modify the rule"/ let any = E, E"as an action is needed to add a symbol to the symbol table before the symbol is referenced. Below this rule,"/ Declare, E"is replaced with"Declare any = E", and"Declare any = E"is added. The action of the second rule will add a value to the symbol table. Also, check in action of the"/ any"rule is added to raise an error if the symbol is not defined. <p>These changes have been made to the genPEG below. Calling stkCode3 will now raise the error <span class="block">Not defined b</span> <p> <a id="genPEG:word:attribute:seq.boolean" href="#PEGEx2">function</a> genPEG(seqElementType:word, attributeType:attribute) seq.boolean <br> <span class="comment">{wordmap: "$"sub 1}</span> <br>[ <span class="block"> <span class="literal">"G1 function any int E"</span> = $.2 <br>, <span class="literal">"E Sum"</span> = $.1 <br>, <span class="literal">"Sum Atom Sum'"</span> = attribute(symbols.$.0, code.$.1 + code.$.2) <br>, <span class="literal">"* Sum'+Atom"</span> = attribute(symbols.$.0, code.$.0 + code.$.1 + <span class="literal">"Add"</span>) <br>, <span class="literal">"Atom(E)"</span> = $.1 <br>, <span class="literal">"/ Declare E"</span> = attribute(symbols.$.0, code.$.1 + code.$.2) <br>, <span class="literal">"/ any"</span> <br> = <span class="keyword">assert</span>(code.$.1) sub 1 ∈ symbols.$.1 <span class="keyword">report</span> <span class="literal">"Not defined:(code.$.1)"</span>, <br>attribute(symbols.$.0, code.$.0 + code.$.1) <br>, <span class="literal">"Declare let any = E,"</span> <br> = attribute(symbols.$.0 + (code.$.1) sub n.code.$.1, code.$.2 + <span class="literal">"Store"</span> + code.$.1)</span>] <p>&lt;h4> Adding Error Recover&lt;/h4> <p>This section describes how to locate the location of the error where a parse fails. The same grammar is used as in the section above with an rule added for if-then-else. The module in this section runs mulitple examples and traps any raised errors when processing the the example. <p>This example uses many options of genPEG. Here is a summary of what the options do: <table> <tr> <td></td></tr> <tr> <td> <strong>Option</strong></td> <td> <strong>Value</strong></td> <td> <strong>Purpose</strong></td></tr> <tr> <td>seqElementType</td> <td>type</td> <td>the element type of the sequence to be parsed</td></tr> <tr> <td>attributeType</td> <td>type</td> <td>the type of the attribute constructed by the parse.</td></tr> <tr> <td>resultType: type</td> <td>the type name to be used for the results of the parse.commonType type</td> <td>type of an immutable value that will be available throughout the parse. This value is supplied as a parameter of the parse. </td></tr> <tr> <td>commonName</td> <td>word</td> <td>The name to use in an action to reference the above immutable value. When using this option also include in the parameters of genPEG a parameter of the form commonName: commonType</td></tr> <tr> <td>wordmap</td> <td>map value</td> <td>How to map a terminal in rule to an element of the sequence to be parsed</td></tr> <tr> <td>error</td> <td>flag</td> <td>include information for pinpointing where the parse failed.</td></tr></table> <p>An option may be specified in the parameter list of genPEG or in the first comment of genPEG <table> <tr> <td></td></tr> <tr> <td> <strong>Kind</strong></td> <td> <strong>As</strong> <strong>parameter</strong></td> <td> <strong>In</strong> <strong>comment</strong></td></tr> <tr> <td>type</td> <td>option:value</td> <td>comment:type</td></tr> <tr> <td>word</td> <td></td> <td>option = value</td></tr> <tr> <td>flag</td> <td>option:boolean</td> <td>option =</td></tr> <tr> <td>map value</td> <td></td> <td>option = comma seperated list.</td></tr></table> <p> <p>The resultType may have the following fields: <span class="block"> <br>result: the final attribute <br>status: one of the words Match, MatchPrefix, or Failed. <br>place: the first unprocessed element of the input. <br>input: the input sequence including the endMark. <br>recoveryEnding: On failure, a sequence of words that can be added to the input of the successfully parsed elements of the input to form a string that can be parsed. </span> <p>The recoveryEnding also provides a way to construct an input that can be parsed. In this section, we use the same parser to parse it again. But to do a successful parse, the semantic checking must not be done. This example uses the commonName and commonType options to add a parameter to the parse to turn semantic checking on or off. In the Tau implementation, instead of using the same parser, a second parser is used to pretty-print the input. <p>Here is the description of the examples used, and the output they give. The first line of the output is the input to the parser// Example of a successful parse. <span class="block">function Example1 int let a = 1+2, a+(3+4)status: Match place:18 code:1 2 Add Store a a 3 4 Add Add</span> Example of a parse with extra words at the end. <span class="block">function Example2 int let a = 1+2, a+(3+4)extra words status: MatchPrefix place:18 code:1 2 Add Store a a 3 4 Add Add</span> Example of a Failed parse that never executes an action. <span class="block">function Example3 int let status:Failed place:0 code:</span> Example of a semantic error: <span class="block">function Example4 int let a = 1+2,(((b)))+(3+4)Error at 15 message:b is not defined. To finish parse, ')))+(3+4)' was replaced with ')))'</span> Another example of a successful parse <span class="block">function Example5 int if 1 then 2+3 else 4 status: Match place:12 code:1 2 3 Add 4 If</span> Example of parse that failed and then backtrack ending up match none of the rule, The maxinum the maxium place in the input where a reduce was done was used as recovery point. In this example the recover point is a the reduction of 2+3. <span class="block">function Example6 int if 1 then 2+3 else Failed Error at 10 message:syntax error. To finish parse, ' else ' was replaced with ' else any '/sp<span class="block">&lt;/span></span> <p> <span class="keyword" id="PEGEx3">Module</span> PEGEx3 <p>use standard <p>use set.word <p>use UTF8 <p>use seq.word <p> <a id="endMark" href="#PEGEx3">function</a> endMark word encodeword.[char.254] <p>type attribute is symbols:set.word, code:seq.word <p> <a id="toAttribute:attribute:seq.word:attribute" href="#PEGEx3">function</a> toAttribute(a:attribute, b:seq.word) attribute attribute(symbols.a, b) <p>use process.seq.word <p> <a id="stkCode4.word" href="#PEGEx3">Function</a> stkCode4 seq.word <br> <span class="comment">{COMMAND}</span> <br> <span class="keyword">let</span> data = <span class="block">[ <span class="block"> <span class="literal">"function Example1 int let a = 1+2, a+(3+4)"</span> <br>, <span class="literal">"function Example2 int let a = 1+2, a+(3+4)extra words"</span> <br>, <span class="literal">"function Example3 int let"</span> <br>, <span class="literal">"function Example4 int let a = 1+2,(((b)))+(3+4)"</span> <br>, <span class="literal">"function Example5 int if 1 then 2+3 else 4"</span> <br>, <span class="literal">"function Example6 int if 1 then 2+3 else"</span></span>]</span> <span class="keyword">for</span> acc = <span class="literal">""</span>, in ∈ data <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> p = process.parser.in, <br>acc + <span class="literal">":((in)"</span> + <span class="keyword">if</span> aborted.p <span class="keyword">then</span> message.p + <span class="literal">""</span> <span class="keyword">else</span> result.p + <span class="literal">""</span>,</span> acc <p> <a id="parser:seq.word:seq.word" href="#PEGEx3">function</a> parser(in:seq.word) seq.word <br> <span class="keyword">let</span> initAttribute = attribute(asset. <span class="literal">"1 2 3 4"</span>, <span class="literal">""</span>) <br> <span class="keyword">let</span> p = parse(in, initAttribute, true) <br> <span class="keyword">let</span> finalAttribute = result.p, <br> <span class="keyword">if</span> status.p ∈ <span class="literal">"Failed"</span> ∧ place.p > 0 <span class="keyword">then</span> <span class="literal">"Failed"</span> + errormessage( <span class="literal">"syntax error"</span>, recoverInfo(pop.stk.p, input.p, place.p, faili.p)) <br> <span class="keyword">else</span> <span class="literal">"status::(status.p)place::(place.p)code:"</span> + code.finalAttribute <p> <a id="errormessage:seq.word:recoverInfo:seq.word" href="#PEGEx3">function</a> errormessage(message:seq.word, rinfo:recoverInfo) seq.word <br> <span class="comment">{provides a uniform way to generate an error message within an action}</span> <br> <span class="keyword">let</span> ending = recoveryEnding.rinfo <br> <span class="keyword">let</span> corrected = subseq(input.rinfo, 1, place.rinfo - 1) + ending <br> <span class="keyword">let</span> reparse = parse(corrected, attribute(empty:set.word, <span class="literal">""</span>), false), <br> <span class="keyword">if</span> status.reparse ∉ <span class="literal">"Match"</span> <span class="keyword">then</span> <span class="literal">"Failed reparse"</span> + corrected <br> <span class="keyword">else</span> <span class="literal">"Error at:(place.rinfo)message::(message). To finish parse, ':(subseq(input.rinfo, place.rinfo, n.input.rinfo - 1))' was replaced with ':(ending)'"</span> <p> <a id="genPEG:word:attribute:recoverInfo:recoverInfo:boolean:boolean:seq.boolean" href="#PEGEx3">function</a> genPEG( <br> <br>seqElementType:word <br> <br>, attributeType:attribute <br> <br>, resultType:recoverInfo <br> <br>, rinfo:recoverInfo <br> <br>, commonType:boolean <br> <br>, checkSemantics:boolean <br> <br>) seq.boolean <br> <span class="comment">{commonName: checkSemantics error: wordmap: "$"sub 1}</span> <br>[ <span class="block"> <span class="literal">"G1 function any int E"</span> = $.2 <br>, <span class="literal">"E if E then E else E"</span> = attribute(symbols.$.0, code.$.1 + code.$.2 + code.$.3 + <span class="literal">"If"</span>) <br>, <span class="literal">"/ Sum"</span> = $.1 <br>, <span class="literal">"Sum Atom Sum'"</span> = attribute(symbols.$.0, code.$.1 + code.$.2) <br>, <span class="literal">"* Sum'+Atom"</span> = attribute(symbols.$.0, code.$.0 + code.$.1 + <span class="literal">"Add"</span>) <br>, <span class="literal">"Atom(E)"</span> = $.1 <br>, <span class="literal">"/ Declare E"</span> = attribute(symbols.$.0, code.$.1 + code.$.2) <br>, <span class="literal">"/ ! if ! let any"</span> <br> = <span class="keyword">assert</span> not.checkSemantics ∨ (code.$.1) sub 1 ∈ symbols.$.1 <span class="keyword">report</span> errormessage( <span class="literal">":(code.$.1)is not defined"</span>, rinfo), <br>attribute(symbols.$.0, code.$.0 + code.$.1) <br>, <span class="literal">"Declare let any = E,"</span> <br> = attribute(symbols.$.0 + (code.$.1) sub n.code.$.1, code.$.2 + <span class="literal">"Store"</span> + code.$.1)</span>] <p id="patterns">/scan <h1>Example of Renaming Function</h1> <p> <p> <span class="keyword" id="patterns">Module</span> patterns <p>precedence sub for # <p>use standard <p>use seq.* <p>use set.* <p>The pattern3 transformation will change the value of the original to look like the value of changed in the procedure below. <p> <a id="example3:int:int:int" href="#patterns">function</a> example3(i:int, x:int) int <br> <span class="keyword">let</span> original = [i + 1, x + 1, 3 + 1, 3 * 1 + 1, i + x + 1] <br> <span class="keyword">let</span> changed = [inc.i, inc.x, inc.3, inc(3 * 1), inc(i + x)], <br>0 <p>To specify this transformation, we must first define the inc function. <p> <a id="inc:int:int" href="#patterns">function</a> inc(i:int) int i + 1 <p>We will use a single parameterized pattern specified with the function below. <p> <a id="pattern3:int:seq.int" href="#patterns">Function</a> pattern3(t:int) seq.int [t + 1, inc.t] <p>The result type of the function is the sequence of the type of the expression being translated. It this case the expression type is type int so the result type of pattern3 is seq.int. The parameter t of pattern3 will match any expression of type int. the pattern3 will be applied five times and t will take on the values i, x, 3, 3 * 1 ∧ i+x. <p>The body of pattern3 is of the form[old, new]where old is the old expression and new is the new expression. The t in the new expression will be replaced with what t matches in the old expression. <p>Expressions can also be transformed for a function in parameterized modules. To do this, one must define the type * to represent the parameterized type T. <p>type * is a:seq.int <p> <a id="pattern4:seq.*:seq.*" href="#patterns">Function</a> pattern4(s:seq.*) seq.* <br> <span class="comment">{use a separate function to get the first element of a sequence}</span> <br>[s sub 1, first.s] <p> <a id="pattern5:seq.*:int:seq.*" href="#patterns">Function</a> pattern5(s:seq.*, i:int) seq.* <br> <span class="comment">{switches order of parameters}</span> <br>[i # s, s sub i] <p>The parameterized <em>module</em> firstop defines the first function and the function that uses a different parameter order. The definition is below. <p>Some uses are needed to make the functions and types used in patterns and 5 available in the module. <p>use seq.* <p>use firstop.* <p>Pattern5 and pattern6 transformation will change the value of the original to look like the value of changed in the procedure below. <p> <a id="example4" href="#patterns">function</a> example4 int <br> <span class="keyword">let</span> original = 2 # [1, 2, 3] + 1 # [3, 4, 5] <br> <span class="keyword">let</span> changed = [1, 2, 3] sub 2 + first.[3, 4, 5], <br>0 <p>The use below is included so example4 will compile. <p>use firstop.int <p> <span class="keyword" id="firstop">Module</span> firstop.T <p>use seq.T <p> <a id="first:seq.T:T" href="#firstop">Function</a> first(s:seq.T) T s sub 1 <p>/Function sub(s:seq.T, i:int)T sub(s, i) <p> <a id="#:int:seq.T:T" href="#firstop">Function</a> #(i:int, s:seq.T) T s sub i <h1>Profiling</h1> <p> <p>Profiling works by adding code to the procedure that tracks how much time is spent in each subprocedure that is called. When the results are displayed, the largest time is found and normalized to 100. All other calls are in 100th's of the largest time. <p> <a href="./profileExample.html">Result of run profileExample defined below. </a> <p> <span class="keyword" id="profileExample">Module</span> profileExample <p>use seq.file <p>use file <p>use standard <p>use profile <p>use process.seq.word <p>To add profiling to the functions in this Module the follow steps were taken: <br>1. To the function to be profiled add{OPTION PROFILE}NOINLINE was also include for these small function since if a procedure is expaned inline, no profile results will be shown for that procedure. <br>2. Add a use clause"use profile" <br>3. Add profileresults. "time"to make the profile results visible <br>4. In the.bld file add to the makelib command the option profile = <br>5. In the sources for the makelib command also+tests profile+common graphcode <br>6. Make sure the uses option of the makelib command includes commmon. <p> <a id="profileExample.word" href="#profileExample">Function</a> profileExample seq.word <br> <span class="comment">{OPTION PROFILE NOINLINE COMMAND /strong profile Example}</span> <br> <span class="keyword">let</span> p = process.processtest(2 sup 2 + 3) <br> <span class="keyword">let</span> p2 = subtest(2 sup 2 + 3), <br> <span class="literal">"test:({subtest.4+}result.p):(profileresults. <span class="literal">"time"</span>)"</span> <p> <a id="subtest:int:seq.word" href="#profileExample">function</a> subtest(i:int) seq.word <br> <span class="comment">{OPTION PROFILE NOINLINE}</span> <br>%(i sup 10 + tr.i) <p> <a id="tr:int:int" href="#profileExample">function</a> tr(n:int) int <br> <span class="comment">{OPTION PROFILE NOINLINE}</span> <br> <span class="keyword">let</span> a = %.n, <br> <span class="keyword">if</span> n &lt; 3 <span class="keyword">then</span> n <span class="keyword">else</span> tr(n - 1) + tr(n - 2) <p> <a id="processtest:int:seq.word" href="#profileExample">function</a> processtest(i:int) seq.word <br> <span class="comment">{OPTION PROFILE NOINLINE}</span> <br>subtest.i <h1 id="enum">enumexample/tag &lt;/h1> <p> <p> <span class="keyword" id="enumexample">Module</span> enumexample <p>use bits <p>use standard <p>The function name genEnum is treated as magic by the transform command. It auto generates the code to implement enumeration types. This example implements two enumeration types. In the first enumeration type Each word in the value list is given a value starting with 0. <p>In the first example The question mark is a place holder for numbers that with not be include in the type. <p>The second example uses an existing data type byte. <p> <a id="genEnum.seq.word" href="#enumexample">function</a> genEnum seq.seq.word <br>[ <span class="block"> <span class="literal">"newType: numbers names: ? two0 two1 ? two2 ? ? ? two3"</span> <br>, <span class="literal">"existingType: byte decodeName: twodecode valueName: Two0 1 Two1 2 Two2 4 Two3 0x08"</span></span>] <p>&lt;&lt;&lt;&lt; Below is auto generated code >>>> <p>type numbers is toint:int <p> <span class="keyword">Export</span> toint(numbers) int <p> <span class="keyword">Export</span> numbers(i:int) numbers <p> <span class="keyword">Export</span> type:numbers <p> <a id="=:numbers:numbers:boolean" href="#enumexample">Function</a> =(a:numbers, b:numbers) boolean toint.a = toint.b <p> <a id="two0" href="#enumexample">Function</a> two0 numbers numbers.1 <p> <a id="two1" href="#enumexample">Function</a> two1 numbers numbers.2 <p> <a id="two2" href="#enumexample">Function</a> two2 numbers numbers.4 <p> <a id="two3" href="#enumexample">Function</a> two3 numbers numbers.8 <p> <a id="decode:numbers:seq.word" href="#enumexample">Function</a> decode(code:numbers) seq.word <br> <span class="keyword">let</span> discard = [two0, two1, two2, two3] <br> <span class="keyword">let</span> i = toint.code, <br> <span class="keyword">if</span> between(i + 1, 1, 9) <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> r = [ <span class="literal">"? two0 two1 ? two2 ? ? ? two3"</span>] sub (i + 1), <br> <span class="keyword">if</span> r ≠ <span class="literal">"?"</span> <span class="keyword">then</span> r <span class="keyword">else</span> <span class="literal">"numbers."</span> + toword.i</span> <span class="keyword">else</span> <span class="literal">"numbers."</span> + toword.i <p> <a id="Two0" href="#enumexample">Function</a> Two0 byte tobyte.1 <p> <a id="Two1" href="#enumexample">Function</a> Two1 byte tobyte.2 <p> <a id="Two2" href="#enumexample">Function</a> Two2 byte tobyte.4 <p> <a id="Two3" href="#enumexample">Function</a> Two3 byte tobyte.8 <p> <a id="twodecode:byte:seq.word" href="#enumexample">Function</a> twodecode(code:byte) seq.word <br> <span class="keyword">let</span> discard = [Two0, Two1, Two2, Two3] <br> <span class="keyword">let</span> i = toint.code, <br> <span class="keyword">if</span> between(i + 1, 1, 9) <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> r = [ <span class="literal">"? Two0 Two1 ? Two2 ? ? ? Two3"</span> sub (i + 1)], <br> <span class="keyword">if</span> r ≠ <span class="literal">"?"</span> <span class="keyword">then</span> r <span class="keyword">else</span> <span class="literal">"byte."</span> + toword.i</span> <span class="keyword">else</span> <span class="literal">"byte."</span> + toword.i <h2>oldstuff</h2> <p> <p>alias usegraph ="tau tools usegraph" <p>alias transform ="tau tools transform" <p>A function can be profiled to see where the time is being spent in a program. An example of doing this is given <a href="./profileExampleSrc.html">here. </a> Which produces the output <a href="./profileExample.html">here. </a> <p> <span class="keyword">The</span> htmlcode cmd create html from source files pretty prints the file and adds syntax highlighting and a module index. It is useful for examining source code. For example block htmlcode+built core.libsrc <h2>Introduction to intermediate code produced by compiler</h2> <p> <p>This section provides a brief explanation of the control structure used in the intermediate code. The follow function for calculating factorials is used as an example. <p> <a id="fact2:int:int:int" href="#enumexample">Function</a> fact2(a:int, result:int) int <br> <span class="keyword">if</span> a = 1 <span class="keyword">then</span> result <span class="keyword">else</span> if a = 0 <span class="keyword">then</span> result <span class="keyword">else</span> fact2(a - 1, result * a) <p>The intermediate code is represented by a sequence of symbols. The text representation of a symbol does not contain all the information in a symbol. The function fact2 is represented by the text. "helloworld:test2(int, int)int"The module of the symbol is represented but not the library. Each type also has module and library but only the name of the type is given. <p>The local variables are represented by % followed by a number, for example %2. Local variables also have name associated with them that is not in the text representation. <p>The body of fact2 can be rewritten as a sequence of statements using explicit gotos. All the statements are wrapped up in a block. <span class="block">Block( <br>if a = 1 then goto(+1)else goto(+2) <br>, Exit(result) <br>, if a = 0 then goto(+1)else goto(+2) <br>, Exit(result) <br>, Exit(fact2(a-1, result * a)))</span> <p> <em>????/sp<strong>&lt;/em></strong> at beginning of line causes <strong>problem</strong> goto(+n)means do not execute the next n-1 statements and continue with the following statement <strong>. </strong> Exit means skip executing all the follow statements in the block. <p>A further rewrite gets closer to the intermediate code. The rewrite starts the block with Start(&lt;type of value returned by block>). Each statement is expressed in postfix notation. The /ldq if &lt;exp> then goto(a)else goto(b)"becomes /ldq &lt;postfix exp> Br2(a, b)". The end of the block is indicated by EndBlock The parameter names become %1 and %2 <span class="block"> <br>Start(int) <br>%1 1 = Br2(1, 2) <br>%2 Exit <br>%1 0 = Br2(1, 2) <br>%2 Exit <br>%1 1-%2 %1 * fact2 Exit <br>EndBlock</span> <p>This function is tail recursive and the recursion can be removed by using a loop. The values that change each time through the loop are capture in loop variables. The loop will use two additon symbols called Loop and Continue. <p>The first step in calling a function is to assign its arguments to new locals. If one considers the symbol &lt;* block loop:3(int, int)int *> to be a function declaration &lt;* block function loop(%3:int, %4:int)*>, then the first step is same as the first step in calling a function. Also <strong>the</strong> <strong>Continue</strong> 2 can be consider a function call <p>The Start(int)is replaced <strong>with</strong> Loop and the"fact2 Exit"is replaced with <strong>a</strong> CONTINE 2 to get <span class="block"> <br>%1 %2 Loop:3(int, int)int <br>%3 1 = Br2(1, 2) <br>%4 Exit <br>%3 0 = Br2(1, 2) <br>%4 Exit <br>%3 %3 1-%4 %3 * Continue 2 <br>EndBlock</span> <p>Finally by replacing function names with the full symbol description, the text representation of the intermediate code is &lt;* block %1 %2 Loop:3(int, int)int <br>%3 1 =(int, int)boolean Br2(1, 2) <br>%4 Exit <br>%3 0 =(int, int)boolean Br2(1, 2) <br>%4 Exit <br>%3 1-(int, int)int %4 %3 *(int, int)int Continue 2 <br>EndBlock *> <h2>/ HelloWorld with dynamic libraries/tag &lt;/h2> <p> <p>The Mac OS X implementation also allows dynamic libraries to be created instead of programs.The command is &lt;* block ltau stdlib HelloWorld x *> <p>In this <em>command</em> ltau refers to a script in &lt;tau>/bin. The next word <em>,</em> stdlib, refers to a dynamic library &lt;tau>/stdlib.dylib which tau will load and pass the rest of the command line as an argument to stdlib. <p>The library stdlib <em>takes</em>"HelloWorld"and creates another dynamic library &lt;tau>/Helloworld.dylib from the src in &lt;tau>/HelloWorld. Helloworld.dylib is then loaded and the entrypoint function is call with any remaining arguments, which in this case is"x"If no args are present, then execute stops with the creation of HelloWorld.dylib. <p>Once HelloWorld.dylib is created, the program can be run with &lt;* block ltau HelloWorld arg *> without any compiling taking place. <p>4. Many text editors allow scripts to be run. To change HelloWorld into a script add as the first line of the HelloWorld.ls, the line &lt;* block #!/bin/sh tau stdlib HelloWorld *> followed by a blank line. Your text editor may run HelloWorld as a script without setting the execute bit. To set the execute bit, use &lt;* block chmod+x HelloWorld/HelloWorld.ls *> <h2>section Installing Web Assembly Cross Compiler</h2> <p> <p>Since wasm files cannot be served from a filesystem, a web server is required. OSX has an Apache web server pre-installed. The details of how to configure the Apache web server is not hard but the details vary with OS so only the gist of what needs to be done is given here. <p>Set up a virtual host Below is an example configuretion. The quotes strings will need to be updated with absolute path of you &lt;Tau> directory.&lt;* block &lt;VirtualHost *:80> ServerName myhost.local <br>DocumentRoot"/Users/david/Tau" <br>&lt;Directory"/Users/david/Tau"> &lt;* block Options FollowSymLinks Multiviews <br>MultiviewsMatch Any <br>AllowOverride None <br>Require all granted *> &lt;/Directory> <br>ScriptAliasMatch ^/cgi-bin/((?!(?i:webobjects)).*$)"/Users/david/Tau/bin/$1" <br>ErrorLog"/private/var/log/apache2/myhost-error_log" <br>CustomLog"/private/var/log/apache2/myhost-access_log"common <br>&lt;/VirtualHost> *> <p>To avoid file permission problems add the group of the web server as one of your groups. Make that your default group.Change the user to your user name to avoid permission problems.An alternative is to run the web server under you user. <p>Since files are cached by the browse change cache control to retrieve new copy when file is changed on server. To do this add the directive &lt;* block set Cache-Control no-cache *> to the &lt;IfModule headers_module> section of the configuration file. <p>The &lt;Tau>/bin/putfile.cgi is needed to write files back to the server. <p>Restart the Apache web server. <p>To see if all is working properly open a web browser on &lt;* block https://myhost.local/built/Bcubic.html *> The actual url may vary depending on how the virtual host name in your configuration. <hr> <p> <h2>Documentation below is not complete.</h2> <p> <p>section vhost <p>edit vhost and duplicate the localhost line, and change localhost to myhost.test <p>uncomment vhost line in httpd.conf <p>edit httpd-vhosts.conf <p>--- <p>sudo ssh-keygen-f server.key-m PEM <p>section security <p>Is the user who he claims to be? <p>Is the user authorized for action provided ? <p>Token createdate user action signature <p>hour*60+10*second of time of creation--gives 4 digit decimal number <p>Authenticator table of user(key)password(hashed)email phone <p>table of user tempkey <p>table of user action <p>Login <p>user presents user password tempkey Authenticator <p>Authenticator: if password matches sends email with random code(saving randome code user tempkey and time send) <p>Users: presents user password tempkey code <p>Authenticator sends token to user with action"create token" <p>User request for token sends temp key and code <p>Request for signature verification just send token  