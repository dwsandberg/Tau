<!doctype html> <html lang="en"> <meta charset="utf-8"> <p> <link rel="stylesheet" href="../daws/codeExample.css"> <p> <a href="#bits">Module bits</a> <a href="#encoding">encoding.T</a> <a href="#classinfo">classinfo</a> <a href="#markup">markup</a> <a href="#format1a">format1a</a> <a href="#format4">format4</a> <a href="#graph">graph.T</a> <a href="#arc">arc.T</a> <a href="#process">process.T</a> <a href="#real">real</a> <a href="#seq">seq.T</a> <a href="#set">set.T</a> <a href="#sparseseq">sparseseq.T</a> <a href="#stack">stack.T</a> <a href="#standard">standard</a> <a href="#toWords">toWords</a> <a href="#UTF8">UTF8</a> <a href="#word">word</a> <a href="#xxhash">xxhash</a> <a href="#seq1">seq1.T</a> <a href="#sort">sort.T</a> <a href="#textio">textio</a> <a href="#file">file</a> <a href="#ptr">ptr</a> <a href="#indirect">indirect.T</a> <a href="#PEGrules">PEGrules</a> <a href="#kernal">kernal</a> <a href="#brandeskopf">brandeskopf</a> <a href="#uniqueids">uniqueids</a> <a href="#layernode">layernode</a> <a href="#orderNodes">orderNodes.T</a> <a href="#timestamp">timestamp</a> <a href="#drawGraph">drawGraph.&lt;&lt;.T</a> <a href="#svg">svg</a> <a href="#stateFunctions">stateFunctions/sp<span class="block">&lt;/a></span> <p> <span class="keyword" id="bits">Module</span> bits <p>use seq.bits <p>use seq.int <p>use kernal <p> <span class="keyword">Export</span> type:bits <p> <span class="keyword">Export</span> toint(bits) int <p> <span class="keyword">Export</span> type:byte <p> <span class="keyword">Export</span> bits(int) bits <p>type bits is toint:int <p> <a id="tobits:int:bits" href="#bits">Function</a> tobits(a:int) bits bits.a <span class="keyword">Builtin</span> <p>∨ <span class="keyword">Builtin</span> <p>∧ <span class="keyword">Builtin</span> <p>>> <span class="keyword">Builtin</span> <p>&lt;&lt; <span class="keyword">Builtin</span> <p>⊻ <p> <a id="=:bits:bits:boolean" href="#bits">Function</a> =(a:bits, b:bits) boolean toint.a <a href="#=:int:int:boolean">=</a> toint.b <p> <a id="mask:int:bits" href="#bits">Function</a> mask(n:int) bits <br> <span class="comment">{returns mask of n 1s in right bits. }</span> <br> <a href="#tobits:int:bits">tobits</a>.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> n) <p> <a id=">1:byte:byte:ordering" href="#bits">Function</a> >1(a:byte, b:byte) ordering <br> <a href="#toint:byte:int">toint</a>.a <a href="#>1:int:int:ordering">>1</a> <a href="#toint:byte:int">toint</a>.b <p> <a id="floorLog2:int:int" href="#bits">Function</a> floorLog2(a:int) int <br> <span class="keyword">let</span> d64 = <a href="#tobits:int:bits">tobits</a>.a <br> <span class="keyword">let</span> b32 = d64 <a href="#>>:bits:int:bits">>></a> 32 <br> <span class="keyword">let</span> t32 = <span class="keyword">if</span> b32 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 32 <br> <span class="keyword">let</span> d32 = <span class="keyword">if</span> b32 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFFFFFFFF <a href="#∧:bits:bits:bits">∧</a> d64 <span class="keyword">else</span> b32 <br> <span class="keyword">let</span> b16 = d32 <a href="#>>:bits:int:bits">>></a> 16 <br> <span class="keyword">let</span> t16 = <span class="keyword">if</span> b16 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 16 <br> <span class="keyword">let</span> d16 = <span class="keyword">if</span> b16 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFFFF <a href="#∧:bits:bits:bits">∧</a> d32 <span class="keyword">else</span> b16 <br> <span class="keyword">let</span> b8 = d16 <a href="#>>:bits:int:bits">>></a> 8 <br> <span class="keyword">let</span> t8 = <span class="keyword">if</span> b8 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 8 <br> <span class="keyword">let</span> d8 = <span class="keyword">if</span> b8 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFF <a href="#∧:bits:bits:bits">∧</a> d16 <span class="keyword">else</span> b8 <br> <span class="keyword">let</span> b4 = d8 <a href="#>>:bits:int:bits">>></a> 4 <br> <span class="keyword">let</span> t4 = <span class="keyword">if</span> b4 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 4 <br> <span class="keyword">let</span> d4 = <span class="keyword">if</span> b4 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xF <a href="#∧:bits:bits:bits">∧</a> d8 <span class="keyword">else</span> b4, <br>t32 <br> <a href="#+:int:int:int">+</a> t16 <br> <a href="#+:int:int:int">+</a> t8 <br> <a href="#+:int:int:int">+</a> t4 <br> <a href="#+:int:int:int">+</a> [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3] <a href="#sub:seq.T:int:T">sub</a> (toint.d4 <a href="#+:int:int:int">+</a> 1) <p>type byte is rep:int <p> <a id="=:byte:byte:boolean" href="#bits">Function</a> =(a:byte, b:byte) boolean <br> <a href="#toint:byte:int">toint</a>.a <a href="#=:int:int:boolean">=</a> <a href="#toint:byte:int">toint</a>.b <p> <a id="tobits:byte:bits" href="#bits">Function</a> tobits(a:byte) bits <br> <a href="#tobits:int:bits">tobits</a>. <a href="#toint:byte:int">toint</a>.a <span class="keyword">Builtin</span> <p>toint <p> <a id="tobyte:int:byte" href="#bits">Function</a> tobyte(a:int) byte byte.a <p> <a id="toseqbits:seq.byte:seq.bits" href="#bits">Function</a> toseqbits(a:seq.byte) seq.bits <br> <span class="keyword">for</span> acc = empty:seq.bits, current = bits.0, shift = 0, b ∈ a <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> shift <a href="#=:int:int:boolean">=</a> 64 <span class="keyword">then</span> next(acc <a href="#">+</a> current, bits. <a href="#toint:byte:int">toint</a>.b <a href="#∧:bits:bits:bits">∧</a> 0xFF, 8) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">acc <br>, current <br> <a href="#∨:bits:bits:bits">∨</a> (bits. <a href="#toint:byte:int">toint</a>.b <a href="#∧:bits:bits:bits">∧</a> 0xFF) <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> shift <br>, shift <a href="#+:int:int:int">+</a> 8</span>),</span></span> acc <a href="#">+</a> current <p> <span class="keyword" id="encoding">Module</span> encoding.T <p>use seq.encodingpair.T <p>use seq1.seq.encodingpair.T <p>use indirect.encodingstate.T <p>use seq.T <p>use bits <p>use kernal <p>use ptr <p>use word <p>use seq.word <p> <span class="keyword">Export</span> type:encoding.T <p> <span class="keyword">Export</span> valueofencoding(a:encoding.T) int <p> <span class="keyword">Export</span> type:encodingstate.T <p> <span class="keyword">Export</span> length(encodingstate.T) int <p> <span class="keyword">builtin</span> set(ptr, encodingstate.T) ptr <p>type encoding is valueofencoding:int <p> <a id="to::encoding.T:int:encoding.T" href="#encoding">Function</a> to:encoding.T(i:int) encoding.T encoding.i <p>type encodingstate is <br>all:seq.encodingpair.T <br>, length:int <br>, encodetable:seq.seq.encodingpair.T <br>, lastadd:encoding.T <p> <a id="startInParent::T:boolean" href="#encoding">Function</a> startInParent:T boolean <br> <span class="keyword">let</span> inst = getinstance3:T, <br> <span class="keyword">if</span> length.fromindirect.state.inst <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> false <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> discard = finishStart:T(encodingnumber.inst), <br>true</span> <p> <span class="keyword">builtin</span> finishStart:T(eno:int) einfo.T <p> <a id="empty::encodingstate.T:encodingstate.T" href="#encoding">Function</a> empty:encodingstate.T encodingstate.T <br> <span class="keyword">let</span> e = empty:seq.encodingpair.T, <br>encodingstate(e, 0, [e, e, e, e], <a href="#">to:encoding.T</a>(0)) <p>type encodingpair is data:T, code:encoding.T, hash:int <p> <a id="=:encodingpair.T:encodingpair.T:boolean" href="#encoding">function</a> =(a:encodingpair.T, b:encodingpair.T) boolean <br>hash.a <a href="#=:int:int:boolean">=</a> hash.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> valueofencoding.code.a <a href="#=:int:int:boolean">=</a> valueofencoding.code.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> data.a <a href="#">=</a> data.b <p> <span class="keyword">unbound</span> hash(T) int <p> <span class="keyword">unbound</span> =(T, T) boolean <p> <a id="lastadded:encodingstate.T:encoding.T" href="#encoding">Function</a> lastadded(h:encodingstate.T) encoding.T code.(all.h) <a href="#sub:seq.T:int:T">sub</a> n.all.h <p> <a id="notsamehash::T:int:int:bits:boolean" href="#encoding">function</a> notsamehash:T(a:int, b:int, mask:bits) boolean <br>(bits.a <a href="#∧:bits:bits:bits">∧</a> mask) ≠ (bits.b <a href="#∧:bits:bits:bits">∧</a> mask) <p> <span class="keyword">builtin</span> deepcopy(T) T <p> <a id="addencoding:encodingstate.T:T:encodingstate.T" href="#encoding">Function</a> addencoding(h:encodingstate.T, data:T) encodingstate.T <br> <span class="comment">{this is the add that is called by primitiveadd}</span> <br> <span class="keyword">let</span> datav = deepcopy.data <br> <span class="keyword">let</span> hashv = <a href="#">hash</a>.datav <br> <span class="keyword">let</span> tablesize = n.encodetable.h <br> <span class="keyword">let</span> mask = bits.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> <a href="#floorLog2:int:int">floorLog2</a>.tablesize) <br> <span class="keyword">let</span> dataindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>.hashv <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1</span> <span class="keyword">let</span> existingcode = <a href="#lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T">lookuprep2</a>(datav, (encodetable.h) <a href="#sub:seq.T:int:T">sub</a> dataindex), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.existingcode <span class="keyword">then</span> <span class="block">{already present} <br> <span class="keyword">let</span> c = code.existingcode <a href="#sub:seq.T:int:T">sub</a> 1, <br> <span class="keyword">if</span> lastadd.h <a href="#=:encoding.T:encoding.T:boolean">=</a> c <span class="keyword">then</span> h <span class="keyword">else</span> encodingstate(all.h, length.h, encodetable.h, c)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> code = <a href="#">to:encoding.T</a>(n.all.h <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> p = encodingpair(datav, code, hashv) <br> <span class="keyword">let</span> codeindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>.valueofencoding.code <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1</span> <span class="keyword">for</span> listencode = [p], e ∈ (encodetable.h) <a href="#sub:seq.T:int:T">sub</a> dataindex <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> data.e <a href="#">=</a> data.p <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#notsamehash::T:int:int:bits:boolean">notsamehash:T</a>(hash.p, hash.e, mask) <span class="keyword">then</span> listencode <br> <span class="keyword">else</span> listencode <a href="#">+</a> e</span> <span class="keyword">let</span> etable = encodetable.h <br> <span class="keyword">let</span> newencode = <a href="#">replace</a>(encodetable.h, dataindex, listencode), <br> <span class="comment">{subseq(etable, 1, dataindex-1)+listencode+subseq(etable, dataindex+1, n.etable)}</span> <br> <span class="keyword">if</span> 3 <a href="#*:int:int:int">*</a> length.h <a href="#>:int:int:boolean">></a> 2 <a href="#*:int:int:int">*</a> tablesize <span class="keyword">then</span> <span class="block">encodingstate( <span class="block">all.h <a href="#">+</a> p <br>, length.h <a href="#+:int:int:int">+</a> 1 <br>, newencode <a href="#">+</a> newencode <a href="#">+</a> newencode <a href="#">+</a> newencode <br>, code.p</span>)</span> <span class="keyword">else</span> encodingstate(all.h <a href="#">+</a> p, length.h <a href="#+:int:int:int">+</a> 1, newencode, code.p)</span> <p> <a id="addencodings:seq.T:int" href="#encoding">Function</a> addencodings(l:seq.T) int <br> <span class="keyword">let</span> inst = getinstance3:T <br> <span class="keyword">for</span> acc = <a href="#">to:encoding.T</a>(0), @e ∈ l <span class="keyword">do</span> primitiveadd(inst, @e), <br>0 <p> <a id="decode:encoding.T:T" href="#encoding">Function</a> decode(t:encoding.T) T <br> <span class="keyword">let</span> h = <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T <br> <span class="keyword">assert</span> <a href="#between:int:int:int:boolean">between</a>(valueofencoding.t, 1, n.all.h) <span class="keyword">report</span> <span class="literal">"no such encoding"</span> <a href="#">+</a> <a href="#toword:int:word">toword</a>.valueofencoding.t <a href="#">+</a> stacktrace, <br>data.(all.h) <a href="#sub:seq.T:int:T">sub</a> valueofencoding.t <p>type einfo is state:indirect.encodingstate.T, encodingnumber:int, allocatein:ptr <p> <a id="encodingstate:einfo.T:encodingstate.T" href="#encoding">function</a> encodingstate(e:einfo.T) encodingstate.T fromindirect.state.e <p> <span class="keyword">builtin</span> getinstance3:T einfo.T <p> <a id="add1encoding:ptr:T:encoding.T" href="#encoding">Function</a> add1encoding(p:ptr, data:T) encoding.T <br> <span class="comment">{ptr is used instead of einfo since einfo is also defined in encodingsupport}</span> <br> <span class="keyword">let</span> t = <a href="#addencoding:encodingstate.T:T:encodingstate.T">addencoding</a>(fromindirect.state.bitcast2:einfo.T(p), data) <br> <span class="keyword">let</span> discard = set(p, t), <br>lastadd.t <p> <span class="keyword">builtin</span> bitcast2:einfo.T(ptr) einfo.T <p> <span class="keyword">builtin</span> primitiveadd(e:einfo.T, s:T) encoding.T <p>type e3 is sequence, data:seq.encodingpair.T <p> <a id="sequenceIndex:e3.T:int:T" href="#encoding">function</a> sequenceIndex(a:e3.T, i:int) T data.(data.a) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="encodingdata::T:seq.T" href="#encoding">Function</a> encodingdata:T seq.T <br> <span class="keyword">let</span> t = all. <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T, <br>toseq.e3(n.t, t) <p> <a id="encode:T:encoding.T" href="#encoding">Function</a> encode(t:T) encoding.T <br> <span class="keyword">let</span> instance = getinstance3:T <br> <span class="keyword">let</span> r = <span class="block"> <a href="#lookuprep:T:encodingstate.T:seq.encodingpair.T">lookuprep</a>(t, <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.instance),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> primitiveadd(instance, t) <br> <span class="keyword">else</span> code.r <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="=:encoding.T:encoding.T:boolean" href="#encoding">Function</a> =(a:encoding.T, b:encoding.T) boolean valueofencoding.a <a href="#=:int:int:boolean">=</a> valueofencoding.b <p> <a id=">1:encoding.T:encoding.T:ordering" href="#encoding">Function</a> >1(a:encoding.T, b:encoding.T) ordering valueofencoding.a <a href="#>1:int:int:ordering">>1</a> valueofencoding.b <p> <a id="hash:encoding.T:int" href="#encoding">Function</a> hash(a:encoding.T) int valueofencoding.a <p> <a id="lookuprep:T:encodingstate.T:seq.encodingpair.T" href="#encoding">function</a> lookuprep(t:T, inst:encodingstate.T) seq.encodingpair.T <br> <span class="keyword">let</span> mask = bits.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> <a href="#floorLog2:int:int">floorLog2</a>.n.encodetable.inst) <br> <span class="keyword">let</span> dataindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>. <a href="#">hash</a>.t <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1,</span> <a href="#lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T">lookuprep2</a>(t, (encodetable.inst) <a href="#sub:seq.T:int:T">sub</a> dataindex) <p> <a id="lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T" href="#encoding">function</a> lookuprep2(t:T, s:seq.encodingpair.T) seq.encodingpair.T <br> <span class="keyword">for</span> acc = empty:seq.encodingpair.T, e ∈ s <br> <span class="keyword">do</span> <span class="keyword">if</span> t <a href="#">=</a> data.e <span class="keyword">then</span> acc <a href="#">+</a> e <span class="keyword">else</span> acc, <br>acc <p> <a id="findencode:T:seq.T" href="#encoding">Function</a> findencode(t:T) seq.T <br> <span class="keyword">let</span> r = <span class="block"> <a href="#lookuprep:T:encodingstate.T:seq.encodingpair.T">lookuprep</a>(t, <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> empty:seq.T <span class="keyword">else</span> [data.r <a href="#sub:seq.T:int:T">sub</a> 1] <p> <a id="addorder:T:int" href="#encoding">Function</a> addorder(t:T) int valueofencoding. <a href="#encode:T:encoding.T">encode</a>.t <p> <a id="analyze:encodingstate.T:seq.word" href="#encoding">function</a> analyze(t:encodingstate.T) seq.word <br> <span class="literal">"numele ="</span> <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>.n.all.t <br> <a href="#">+</a> <span class="literal">"encodecounts"</span> <br> <a href="#">+</a> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(encodetable.t, 1, 0, 0, 0) <p> <a id="counts:seq.seq.encodingpair.T:int:int:int:int:seq.word" href="#encoding">function</a> counts(s:seq.seq.encodingpair.T, i:int, one:int, two:int, big:int) seq.word <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> acc = <span class="literal">""</span>, @e ∈ [n.s, one, two, big] <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#toword:int:word">toword</a>.@e, <br>acc</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> t = n.s <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> t <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two, big) <br> <span class="keyword">else</span> if t <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one <a href="#+:int:int:int">+</a> 1, two, big) <br> <span class="keyword">else</span> if t <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two <a href="#+:int:int:int">+</a> 1, big) <br> <span class="keyword">else</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two, big <a href="#+:int:int:int">+</a> 1)</span> <p> <span class="keyword" id="classinfo">Module</span> classinfo <p>precedence > for >1 >2 <p>use bits <p>use seq.char <p>use seq.classinfo <p>use set.classinfo <p>use sort.classinfo <p>use standard <p> <span class="keyword">Export</span> type:classinfo <p> <span class="keyword">Export</span> type:tagorder <p> <span class="keyword">Export</span> key(classinfo) word <p> <span class="keyword">Export</span> baseon(classinfo) word <p> <span class="keyword">Export</span> def(classinfo) seq.word <p> <span class="keyword">Export</span> tag(classinfo) word <p> <span class="keyword">Export</span> toseq(tagorder) seq.classinfo <p>type classinfo is key:word, baseon:word, def:seq.word, tag:word, flags:bits <p>type tagorder is toseq:seq.classinfo <p>The set.classinfo will be ordered by key. The taginfo will be ordered by tag. <p> <a id="totagorder:seq.classinfo:tagorder" href="#classinfo">Function</a> totagorder(a:seq.classinfo) tagorder <br>tagorder. <a href="#sort>3:seq.T:seq.T">sort>3</a>.a <p> <a id="lookuptag:set.classinfo:word:seq.classinfo" href="#classinfo">Function</a> lookuptag(lst:set.classinfo, tag:word) seq.classinfo <br> <a href="#lookuptag:tagorder:word:seq.classinfo">lookuptag</a>( <a href="#totagorder:seq.classinfo:tagorder">totagorder</a>.toseq.lst, tag) <p> <a id="lookupkey:set.classinfo:word:seq.classinfo" href="#classinfo">Function</a> lookupkey(lst:set.classinfo, key:word) seq.classinfo <br>toseq. <a href="#lookup:set.T:T:set.T">lookup</a>(lst, classinfo(key, key, <span class="literal">""</span>, key, <a href="#tobits:int:bits">tobits</a>.0)) <p> <a id="lookuptag:tagorder:word:seq.classinfo" href="#classinfo">Function</a> lookuptag(s:tagorder, tag:word) seq.classinfo <br> <span class="keyword">let</span> j = <span class="block"> <a href="#">binarysearch>3</a>(toseq.s, classinfo(tag, tag, <span class="literal">""</span>, tag, <a href="#tobits:int:bits">tobits</a>.0)),</span> <span class="keyword">if</span> j <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> empty:seq.classinfo <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> low = j, high = j, up = true, down = true <br> <span class="keyword">while</span> up <a href="#∨:boolean:boolean:boolean">∨</a> down <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> newdown = <span class="block">low <a href="#>:int:int:boolean">></a> 1 <a href="#∧:boolean:boolean:boolean">∧</a> tag <a href="#=:word:word:boolean">=</a> tag.(toseq.s) <a href="#sub:seq.T:int:T">sub</a> (low <a href="#">-</a> 1)</span> <span class="keyword">let</span> newup = <span class="block">high <a href="#&lt;:int:int:boolean">&lt;</a> n.toseq.s <a href="#∧:boolean:boolean:boolean">∧</a> tag <a href="#=:word:word:boolean">=</a> tag.(toseq.s) <a href="#sub:seq.T:int:T">sub</a> (high <a href="#+:int:int:int">+</a> 1)</span> <span class="keyword">let</span> newlow = <span class="keyword">if</span> newdown <span class="keyword">then</span> low <a href="#">-</a> 1 <span class="keyword">else</span> low, <br> <span class="keyword">let</span> newhigh = <span class="keyword">if</span> newup <span class="keyword">then</span> high <a href="#+:int:int:int">+</a> 1 <span class="keyword">else</span> high, <br>next(newlow, newhigh, newup, newdown),</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.s, low, high)</span> <p> <a id="%:classinfo:seq.word" href="#classinfo">Function</a> %(a:classinfo) seq.word <br> <a href="#esc:seq.word:seq.word">esc</a>.[key.a, baseon.a, tag.a] <a href="#">+</a> def.a <p> <a id=">1:classinfo:classinfo:ordering" href="#classinfo">Function</a> >1(a:classinfo, b:classinfo) ordering key.a <a href="#">>1</a> key.b <p> <a id=">3:classinfo:classinfo:ordering" href="#classinfo">function</a> >3(a:classinfo, b:classinfo) ordering tag.a <a href="#">>1</a> tag.b <p> <a id="=:classinfo:classinfo:boolean" href="#classinfo">function</a> =(a:classinfo, b:classinfo) boolean key.a <a href="#=:word:word:boolean">=</a> key.b <p> <a id="tokey:word:word" href="#classinfo">Function</a> tokey(w:word) word <br> <span class="keyword">let</span> a = <a href="#decodeword:word:seq.char">decodeword</a>.w, <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> 2 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span> <span class="keyword">then</span> w <br> <span class="keyword">else</span> <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block">[ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>] <br> <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.w <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1</span>)</span> <p> <a id="esc:seq.word:seq.word" href="#classinfo">Function</a> esc(z:seq.word) seq.word <br> <span class="keyword">for</span> dd = <span class="literal">""</span>, e ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <br> <a href="#">∈</a> <span class="literal">"/p /br<br>/sp /tag /keyword &lt;* *>"</span> <span class="keyword">then</span> dd <a href="#">+</a> <span class="literal">"/sp /tag:(e)/sp"</span> <br> <span class="keyword">else</span> dd <a href="#">+</a> e,</span> dd <p> <a id="removeesc:seq.word:seq.word" href="#classinfo">Function</a> removeesc(z:seq.word) seq.word <br> <span class="keyword">for</span> dd = <span class="literal">""</span>, e ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <br> <a href="#">∈</a> <span class="literal">"/p /br<br>/sp /tag"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(dd, n.dd <a href="#">-</a> 1, n.dd) <br> <a href="#=:seq.T:seq.T:boolean">=</a> <span class="literal">"/sp /tag"</span> <span class="keyword">then</span> dd <a href="#>>:seq.T:int:seq.T">>></a> 2 <a href="#">+</a> e <br> <span class="keyword">else</span> dd <a href="#">+</a> e,</span> dd <p> <a id="classinfo2:set.classinfo:word:word:seq.word:seq.classinfo" href="#classinfo">Function</a> classinfo2( <br>base:set.classinfo <br>, ele:word <br>, class:word <br>, more:seq.word <br>) seq.classinfo <br> <span class="keyword">if</span> class <a href="#">∈</a> <span class="literal">"daws"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> key = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> flags = <a href="#">extractdef</a>(more, <span class="literal">"flags"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">for</span> acc = 0, w ∈ flags <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> str = <span class="literal">"mark noendtag define namedmark"</span> <br> <span class="keyword">let</span> i = <a href="#findindex:seq.T:T:int">findindex</a>(str, w), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.str <span class="keyword">then</span> acc <span class="keyword">else</span> acc <a href="#+:int:int:int">+</a> 2 <a href="#sup:int:int:int">sup</a> i</span> <span class="keyword">let</span> tag = <a href="#">merge</a>( <span class="literal">"&lt;"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> more1 = <span class="block"> <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(more, 1, 2) <a href="#=:seq.T:seq.T:boolean">=</a> <span class="literal">"flags: "</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> i = <span class="block"> <a href="#min:int:int:int">min</a>( <span class="block"> <a href="#findindex:seq.T:T:int">findindex</a>(more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 2, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br>, <a href="#findindex:seq.T:T:int">findindex</a>(more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 2, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1)</span>),</span> <span class="keyword">if</span> i <a href="#+:int:int:int">+</a> 2 <a href="#>:int:int:boolean">></a> n.more <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i</span> <span class="keyword">else</span> more,</span> <span class="keyword">let</span> a = classinfo(key, key, more1, tag, bits.acc), <br> <span class="keyword">if</span> <a href="#noendtag:classinfo:boolean">noendtag</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#isdefine:classinfo:boolean">isdefine</a>.a <span class="keyword">then</span>[a] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> endtag = <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block">[ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>] <br> <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.ele <br> <a href="#">+</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">">"</span></span>)</span> <span class="keyword">let</span> namedtag = <a href="#">merge</a>( <span class="literal">"//"</span> <a href="#">+</a> ele), <br> <span class="keyword">if</span> <a href="#ismark:classinfo:boolean">ismark</a>.a <span class="keyword">then</span>[a, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>(acc <a href="#+:int:int:int">+</a> 1))] <br> <span class="keyword">else</span> if <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.a <span class="keyword">then</span> <span class="block">[ <span class="block">a <br>, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>.1) <br>, classinfo(namedtag, key, <span class="literal">""</span>, namedtag, <a href="#tobits:int:bits">tobits</a>.16)</span>]</span> <span class="keyword">else</span> [a, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>.1)]</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> key = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> class) <br> <span class="keyword">let</span> basekey = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> info2 = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(base, basekey) <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.info2 <span class="keyword">report</span> <span class="block"> <a href="#esc:seq.word:seq.word">esc</a>. <span class="literal">"no base class key basekey:"</span> <br> <a href="#">+</a> basekey <br> <a href="#">+</a> <span class="literal">"key:"</span> <br> <a href="#">+</a> key <br> <a href="#">+</a> <span class="literal">"ele:"</span> <br> <a href="#">+</a> ele</span> <span class="keyword">let</span> baseclass = info2 <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">for</span> newdefs = <span class="literal">"class"</span>, last = <span class="literal">"?"</span>, e ∈ more <br> <span class="keyword">do</span> next( <span class="keyword">if</span> e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> newdefs <a href="#">+</a> last <span class="keyword">else</span> newdefs, [e]) <br> <span class="keyword">for</span> skip = false, basedefs = <span class="literal">""</span>, last1 = <span class="literal">""</span>, e ∈ def.baseclass <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e ∉ <span class="literal">": "</span> <span class="keyword">then</span> next(skip, <span class="keyword">if</span> skip <span class="keyword">then</span> basedefs <span class="keyword">else</span> basedefs <a href="#">+</a> last1, [e]) <br> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.last1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> last1 <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">∈</a> newdefs <span class="keyword">then</span> next(true, basedefs, <span class="literal">""</span>) <br> <span class="keyword">else</span> next(false, basedefs <a href="#">+</a> last1, [e])</span> <span class="comment">{assert class ∈"pic xx picC slide name"∨ basedefs+last1 = def.baseclass report":(class)more"+more+"/p<br>"+"base"+def.baseclass+"/p<br>"+"newbase"+basedefs+last1}</span> <br> <span class="keyword">let</span> y = <span class="block">classinfo( <span class="block">key <br>, basekey <br>, <span class="literal">"class: "</span> <a href="#">+</a> class <a href="#">+</a> more <a href="#">+</a> basedefs <a href="#">+</a> last1 <br>, tag.baseclass <br>, flags.baseclass</span>),</span> <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.info2 <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> namedtag = <a href="#">merge</a>( <span class="literal">"//"</span> <a href="#">+</a> class), <br>[y, classinfo(namedtag, basekey, <span class="literal">""</span>, namedtag, <a href="#tobits:int:bits">tobits</a>.16)]</span> <span class="keyword">else</span> [y]</span> <p> <a id="isendtag:classinfo:boolean" href="#classinfo">Function</a> isendtag(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.1) <a href="#=:bits:bits:boolean">=</a> bits.1 <p> <a id="ismark:classinfo:boolean" href="#classinfo">Function</a> ismark(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.2) <a href="#=:bits:bits:boolean">=</a> bits.2 <p> <a id="noendtag:classinfo:boolean" href="#classinfo">Function</a> noendtag(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.4) <a href="#=:bits:bits:boolean">=</a> bits.4 <p> <a id="isdefine:classinfo:boolean" href="#classinfo">Function</a> isdefine(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.8) <a href="#=:bits:bits:boolean">=</a> bits.8 <p> <a id="isnamedmark:classinfo:boolean" href="#classinfo">Function</a> isnamedmark(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.16) <a href="#=:bits:bits:boolean">=</a> bits.16 <p> <a id="print:seq.classinfo:seq.word" href="#classinfo">Function</a> print(t:seq.classinfo) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, e ∈ t <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#isendtag:classinfo:boolean">isendtag</a>.e <span class="keyword">then</span> acc <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> flags = <span class="block">( <span class="keyword">if</span> <a href="#ismark:classinfo:boolean">ismark</a>.e <span class="keyword">then</span> <span class="literal">"mark"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#noendtag:classinfo:boolean">noendtag</a>.e <span class="keyword">then</span> <span class="literal">"noendtag"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isdefine:classinfo:boolean">isdefine</a>.e <span class="keyword">then</span> <span class="literal">"define"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.e <span class="keyword">then</span> <span class="literal">"namedmark"</span> <span class="keyword">else</span> <span class="literal">""</span>)</span> <span class="keyword">let</span> flags1 = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.flags <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> <span class="literal">"flags: :(flags)"</span>,</span> acc <br> <a href="#">+</a> [ <a href="#encodeword:seq.char:word">encodeword</a>( <a href="#decodeword:word:seq.char">decodeword</a>.baseon.e <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1)] <br> <a href="#">+</a> <span class="literal">".daws{/* daws:(flags1):(def.e)*/}"</span> <br> <a href="#">+</a> <span class="literal">"/br"</span>,</span></span> acc <p> <a id="extractdef:seq.word:word:seq.word" href="#classinfo">Function</a> extractdef(defs:seq.word, name:word) seq.word <br> <span class="keyword">for</span> notdone = true, found = false, acc = <span class="literal">""</span>, e ∈ defs <a href="#">+</a> <span class="literal">"dummy:"</span> <br> <span class="keyword">while</span> notdone <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">if</span> e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> next(false, found, acc <a href="#>>:seq.T:int:seq.T">>></a> 1) <span class="keyword">else</span> next(notdone, found, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> if e <a href="#=:word:word:boolean">=</a> name <span class="keyword">then</span> next(notdone, found, [e]) <br> <span class="keyword">else</span> if e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> name <a href="#">∈</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, 1, 1) <span class="keyword">then</span> {found}next(notdone, true, <span class="literal">""</span>) <br> <span class="keyword">else</span> next(notdone, found, <span class="literal">": "</span>)</span> <span class="keyword">else</span> next(notdone, found, [e]),</span> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.found <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> acc <p> <a id="processCSS:seq.seq.word:seq.classinfo:seq.classinfo" href="#classinfo">Function</a> processCSS(z:seq.seq.word, dd:seq.classinfo) seq.classinfo <br> <span class="keyword">for</span> acc = dd, p ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc1 = acc <br>, idx = <a href="#findindex:seq.T:T:int">findindex</a>(p, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1)</span> <span class="keyword">while</span> idx ≤ n.p <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> new = <span class="block"> <span class="keyword">if</span> idx <a href="#>:int:int:boolean">></a> n.p <br> <a href="#∨:boolean:boolean:boolean">∨</a> idx <a href="#&lt;:int:int:boolean">&lt;</a> 4 <br> <a href="#∨:boolean:boolean:boolean">∨</a> p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 2) ∉ <span class="literal">"."</span> <br> <a href="#∨:boolean:boolean:boolean">∨</a> p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 3) <a href="#">∈</a> <span class="literal">"}*/"</span> <span class="keyword">then</span> acc1 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> <span class="block">p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 1) ∉ <span class="literal">"daws"</span> <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p, idx <a href="#+:int:int:int">+</a> 1, idx <a href="#+:int:int:int">+</a> 2) <br> <a href="#=:seq.T:seq.T:boolean">=</a> <span class="literal">"/* daws"</span></span> <span class="keyword">report</span> <span class="block"> <span class="literal">"In css file when defining how a new element:"</span> <br> + <span class="literal">"(subseq(p, idx-3, idx), daws requires instructions in a comment of form: /* daws... */"</span></span> <span class="keyword">let</span> more = <span class="block"> <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p, idx <a href="#+:int:int:int">+</a> 1, idx <a href="#+:int:int:int">+</a> 2) <br> <a href="#=:seq.T:seq.T:boolean">=</a> <span class="literal">"/* daws"</span> <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">p <br>, idx <a href="#+:int:int:int">+</a> 3 <br>, idx <a href="#+:int:int:int">+</a> <a href="#findindex:seq.T:T:int">findindex</a>(p <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> idx, <span class="literal">"*/"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <a href="#">-</a> 1</span>)</span> <span class="keyword">else</span> <span class="literal">""</span>,</span> acc1 <br> <a href="#">+</a> <a href="#classinfo2:set.classinfo:word:word:seq.word:seq.classinfo">classinfo2</a>( <span class="block"> <a href="#asset:seq.T:set.T">asset</a>.acc1 <br>, {ele}p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 3) <br>, {class}p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 1) <br>, more</span>),</span></span> next(new, idx <a href="#+:int:int:int">+</a> <a href="#findindex:seq.T:T:int">findindex</a>(p <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> idx, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1)),</span> acc1,</span> acc <p> <a id="defaults:seq.classinfo" href="#classinfo">Function</a> defaults seq.classinfo <br> <span class="keyword">let</span> data = <span class="block"> <span class="literal">"q.daws{/* daws flags: mark output: &lt;q class id > content &lt;/q> totxt: = content /mark = class */}/br<br>b.daws{/* daws flags: mark output: &lt;b class id > content &lt;/b> totxt: = content /mark = class */}/br<br>i.daws{/* daws flags: mark output: &lt;i class id > content &lt;/i> totxt: = content /mark = class */}/br<br>em.daws{/* daws flags: mark output: &lt;em class id > content &lt;/em> totxt: = content /mark = class */}/br<br>strong.daws{/* daws flags: mark output: &lt;strong class id > content &lt;/strong> totxt: = content /mark = t class */}/br<br>span.daws{/* daws flags: mark output: &lt;span class id > content &lt;/span> totxt: = content /mark = id class */}/br<br>caption.daws{/* daws flags: mark output: &lt;caption class id > content &lt;/caption> totxt: = content /mark = class */}/br<br>a.daws{/* daws flags: mark output: &lt;a class id href = href = > content &lt;/a> totxt: = content /mark = href class */}/br<br>sub.daws{/* daws flags: mark output: &lt;sub class id > content &lt;/sub> totxt: = content /mark = class */}/br<br>sup.daws{/* daws flags: mark output: &lt;sup class id > content &lt;/sup> totxt: = content /mark = class */}/br<br>!doctype.daws{/* daws flags: noendtag */}/br<br>meta.daws{/* daws flags: noendtag */}/br<br>!.daws{/* daws flags: noendtag */}/br<br>html.daws{/* daws */}/br<br>body.daws{/* daws */}/br<br>?xml.daws{/* daws flags: noendtag */}/br<br>head.daws{/* daws &lt;body>: /tag &lt;body> output: &lt;head > content &lt;/head> &lt;body> totxt: content */}/br<br>link.daws{/* daws flags: mark noendtag rel: stylesheet output: &lt;link rel href = content = /> totxt: = href /mark = class */}/br<br>base.daws{/* daws flags: mark noendtag output: &lt;base rel href = content = /> totxt: = href /mark = class */}/br<br>title.daws{/* daws output: &lt;title class > content &lt;/title> totxt: content class /br<br>*/}/br<br>hr.daws{/* daws flags: noendtag output: &lt;hr class /> totxt: /p<br>content class */}/br<br>br.daws{/* daws flags: noendtag output: content &lt;br class id /> totxt: content id class /br<br>*/}/br<br>img.daws{/* daws flags: mark noendtag alt: a picture output: &lt;img class id alt src = prefix content /pre postfix /post = /> totxt: = prefix src postfix /post /pre /mark = id class */}/br<br>style.daws{/* daws */}/br<br>p.daws{/* daws output: &lt;p class id > content &lt;/p> totxt: /p<br>content id class /p<br>*/}/br<br>h1.daws{/* daws output: &lt;h1 class id > content &lt;/h1> totxt: /p<br>content id class */}/br<br>h2.daws{/* daws output: &lt;h2 class id > content &lt;/h2> totxt: /p<br>content id class */}/br<br>h3.daws{/* daws output: &lt;h3 class id > content &lt;/h3> totxt: /p<br>content id class */}/br<br>h4.daws{/* daws output: &lt;h4 class id > content &lt;/h4> totxt: /p<br>content id class */}/br<br>h5.daws{/* daws output: &lt;h5 class id > content &lt;/h5> totxt: /p<br>content id class */}/br<br>h6.daws{/* daws output: &lt;h6 class id > content &lt;/h6> totxt: /p<br>content id class */}/br<br>table.daws{/* daws output: &lt;table class id > content &lt;/table> totxt: /p<br>content id class */}/br<br>li.daws{/* daws output: &lt;li class id > content &lt;/li> totxt: /p<br>content id class /p<br>*/}/br<br>ol.daws{/* daws flags: namedmark output: &lt;ol class id > content &lt;/ol> totxt: /p<br>content id class /p<br>*/}/br<br>ul.daws{/* daws flags: namedmark output: &lt;ul class id > content &lt;/ul> totxt: /p<br>content id class */}/br<br>div.daws{/* daws flags: namedmark output: &lt;div class id > content &lt;/div> totxt: /p<br>= content /mark = id class */}/br<br>tr.daws{/* daws output: &lt;tr class id > content &lt;/tr> totxt: content id class /br<br>*/}/br<br>td.daws{/* daws output: &lt;td class id > content &lt;/td> totxt: content id class */}/br<br>th.daws{/* daws output: &lt;th class id > content &lt;/th> totxt: content id class */}/br<br>href.daws{/* daws flags: define /href: href output: /href colon content */}/br<br>id.daws{/* daws flags: define /id: id output: /id colon content */}/br<br>rel.daws{/* daws flags: define /rel: rel output: /rel colon content */}/br<br>"</span>,</span> <a href="#processCSS:seq.seq.word:seq.classinfo:seq.classinfo">processCSS</a>([data], empty:seq.classinfo) <p> <span class="keyword" id="markup">Module</span> markup <p>use standard <p>use classinfo <p>use set.classinfo <p>use seq1.classinfo <p>use seq1.mark <p>use stack.mark <p>use UTF8 <p>use seq1.char <p>use stack.seq.word <p>use seq1.seq.word <p>use seq1.word <p>use format1a <p>/Export txt2html(z:seq.seq.word, replacements:set.classinfo, xhtml:boolean)seq.word <p> <span class="keyword">Export</span> textFormat1a(myinput:seq.word) UTF8 <p> <span class="keyword">Export</span> HTMLformat1a(myinput:seq.word) UTF8 <p> <span class="keyword">Export</span> type:classinfo <p> <span class="keyword">Export</span> esc(z:seq.word) seq.word <p> <a id="dawsextensions:word:stack.seq.word:stack.seq.word" href="#markup">Function</a> dawsextensions(op:word, argstk:stack.seq.word) stack.seq.word <br> <span class="comment">{???? show paramaterized markup so this function can be changed}</span> <br> <span class="comment">{return empty:stack.seq.word if not defined}</span> <br> <span class="comment">{if op ∈"/pretty"then push(pop.argstk, pretty.top.argstk)else}</span> <br> <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <p> <a id="stdCSS:seq.classinfo" href="#markup">Function</a> stdCSS seq.classinfo <br> <span class="keyword">let</span> data = <span class="block"> <span class="literal">"span.avoidwrap{display:inline-block ;}span.keyword{color:blue ;}span.literal{color:red ; transform: }span.comment{color:green ;}span.block{padding:0px 0px 0px 0px ; margin:0px 0px 0px 20px ; display:block ;}"</span>,</span> <a href="#processCSS:seq.seq.word:seq.classinfo:seq.classinfo">processCSS</a>([data], <a href="#defaults:seq.classinfo">defaults</a>) <p> <a id="processTXT:seq.seq.word:seq.classinfo:boolean:seq.word:UTF8" href="#markup">Function</a> processTXT( <br>z:seq.seq.word <br>, replacements:seq.classinfo <br>, xhtml:boolean <br>, lang:seq.word <br>) UTF8 <br> <span class="keyword">let</span> p1 = z <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">for</span> header = 0, idx = 1, w ∈ p1 <br> <span class="keyword">do</span> next( <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"/base /link /title"</span> <span class="keyword">then</span> idx <span class="keyword">else</span> header, idx <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> newz = <span class="block">[ <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p1, 1, header) <a href="#">+</a> <span class="literal">"/head"</span> <br>, p1 <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> header</span>] <br> <a href="#">+</a> z <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1</span> <span class="keyword">let</span> final = <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>( <span class="keyword">if</span> xhtml <span class="keyword">then</span> <span class="literal">"/tag &lt;/body>&lt;/html>"</span> <span class="keyword">else</span> <span class="literal">""</span>), <br> <a href="#header1:boolean:seq.word:UTF8">header1</a>(xhtml, lang) <br> <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#HTMLformat1a:seq.word:UTF8">HTMLformat1a</a>. <a href="#txt2html:seq.seq.word:set.classinfo:boolean:seq.word">txt2html</a>(newz, <a href="#asset:seq.T:set.T">asset</a>.replacements, xhtml) <br> <a href="#+:UTF8:UTF8:UTF8">+</a> final <p> <a id="header1:boolean:seq.word:UTF8" href="#markup">function</a> header1(xhtml:boolean, lang:seq.word) UTF8 <br> <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>( <span class="block"> <span class="keyword">if</span> xhtml <span class="keyword">then</span> <span class="literal">"&lt;?xml version =:( <a href="#">dq</a>. <span class="literal">"1.0"</span>)encoding =:( <a href="#">dq</a>. <span class="literal">"utf-8"</span>)?> &lt;html xmlns =:( <a href="#">dq</a>. <span class="literal">"http://www.w3.org/1999/xhtml"</span>)xmlns:epub =:( <a href="#">dq</a>. <span class="literal">"http://www.idpf.org/2007/ops"</span>)>"</span> <br> <span class="keyword">else</span> <span class="literal">"&lt;!doctype html> &lt;html lang /nsp =:( <a href="#">dq</a>. <span class="literal">":(lang)"</span>)> &lt;meta charset /nsp =:( <a href="#">dq</a>. <span class="literal">"utf-8"</span>)>"</span></span>) <p>type mark is kind:word, place:int <p> <a id="%:mark:seq.word" href="#markup">function</a> %(m:mark) seq.word <span class="literal">":(kind.m):(place.m)"</span> <p> <a id="push:stack.mark:int:stack.mark" href="#markup">function</a> push(s:stack.mark, i:int) stack.mark <br>push(s, mark( <span class="literal">"mark"</span> <a href="#sub:seq.T:int:T">sub</a> 1, i)) <p> <a id="txt2html:seq.seq.word:set.classinfo:boolean:seq.word" href="#markup">Function</a> txt2html(z:seq.seq.word, replacements:set.classinfo, xhtml:boolean) seq.word <br> <span class="comment">{covert paragraph to html}</span> <br> <span class="keyword">let</span> gdefatt = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, <span class="literal">"/global$defs"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">let</span> globaldefs = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.gdefatt <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> def.gdefatt <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">let</span> pdef = <span class="block">def. <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">for</span> <span class="block">acc0 = <span class="literal">""</span> <br>, mark0 = push( <span class="block"> <a href="#empty::stack.T:stack.T">empty:stack.mark</a> <br>, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, 0)</span>) <br>, p ∈ z</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">assert</span> place. <a href="#">top</a>.mark0 <a href="#=:int:int:boolean">=</a> n.acc0 <span class="keyword">report</span> <span class="literal">"check23:( <a href="#">top</a>.mark0):(n.acc0)"</span> <br> <span class="keyword">for</span> skip = false, defines = <span class="literal">""</span>, marks = mark0, acc = acc0, e ∈ p <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <a href="#=:word:word:boolean">=</a> <a href="#escapeformat:word">escapeformat</a> <span class="keyword">then</span> <span class="block">next( <span class="block"> <a href="#not:boolean:boolean">not</a>.skip <br>, defines <br>, marks <br>, acc <a href="#">+</a> <a href="#escapeformat:word">escapeformat</a></span>)</span> <span class="keyword">else</span> if skip <span class="keyword">then</span> next(skip, defines, marks, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> if e <a href="#">∈</a> <span class="literal">"//"</span> <span class="keyword">then</span> next(skip, defines, <a href="#">push</a>(marks, n.acc), acc) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> r = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, e), <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> next(skip, defines, marks, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> att = r <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">let</span> basedon = baseon.att, <br> <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.att <a href="#∧:boolean:boolean:boolean">∧</a> key.att <a href="#=:word:word:boolean">=</a> tag.att <span class="keyword">then</span> <span class="block">{marks beginning of tag} <br> <span class="keyword">let</span> newmarks = push(push( <a href="#">pop</a>.marks, mark(basedon, n.acc)), <a href="#">top</a>.marks), <br>next(skip, defines, newmarks, acc)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> acc1 = acc <br> <span class="keyword">let</span> marks1 = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/li"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> n.toseq.marks <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> new = <span class="block">push( <span class="block">push( <span class="block"> <a href="#">pop</a>.marks <br>, mark( <span class="literal">"/ul"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>) <br>, mark( <span class="literal">"/li"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>),</span> new</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> mark2 = <span class="block"> <a href="#advance:stack.mark:mark:stack.mark">advance</a>( <span class="block"> <a href="#">pop</a>.marks <br>, mark( <span class="literal">"/li"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>),</span> mark2</span></span> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/div"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> place. <a href="#">top</a>.marks <a href="#=:int:int:boolean">=</a> n.acc1 <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> marks2 = <span class="block"> <span class="keyword">if</span> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <a href="#∧:boolean:boolean:boolean">∧</a> place. <a href="#">top</a>.marks <a href="#=:int:int:boolean">=</a> n.acc1 <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> marks</span> <span class="keyword">assert</span> kind. <a href="#">top</a>.marks2 <a href="#">∈</a> <span class="literal">"/li"</span> <span class="keyword">report</span> <span class="literal">"problem 890:( <a href="#%n:seq.T:seq.word">%n</a>.toseq.marks):(p)"</span> <br> <span class="comment">{let acc2 = if place.top.marks2 = n.acc1 then acc1 else finishp(acc1, marks2, xhtml, replacements, defines+pdef),}</span> <br> <span class="comment">{???? should do more than just popstack doesnot assign class or and end tag}</span> <br> <a href="#">pop</a>.marks2</span> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/tr"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"/td"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/table"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"/tr"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> marks</span> <span class="keyword">assert</span> basedon ∉ <span class="literal">"/div"</span> <a href="#∨:boolean:boolean:boolean">∨</a> kind. <a href="#">top</a>.marks1 <a href="#=:word:word:boolean">=</a> basedon <span class="keyword">report</span> <span class="literal">":(key.att)does not have matching start"</span> <br> <span class="keyword">assert</span> basedon ∉ <span class="literal">"/ul /ol"</span> <a href="#∨:boolean:boolean:boolean">∨</a> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"/ul /ol /div"</span> <span class="keyword">report</span> <span class="literal">":(key.att)does not have matching start:( <a href="#%n:seq.T:seq.word">%n</a>.toseq.marks1)/p:(p)"</span> <br> <span class="keyword">let</span> lastplace = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/head"</span> <span class="keyword">then</span> 0 <br> <span class="keyword">else</span> if ( <a href="#ismark:classinfo:boolean">ismark</a>.att <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#isdefine:classinfo:boolean">isdefine</a>.att) <br> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks1 ∉ <span class="literal">"mark"</span> <span class="keyword">then</span> n.acc1 <a href="#">-</a> 1 <br> <span class="keyword">else</span> place. <a href="#">top</a>.marks1</span> <span class="keyword">let</span> smallacc = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc1, 1, lastplace) <br> <span class="keyword">let</span> content = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc1, lastplace <a href="#+:int:int:int">+</a> 1, n.acc1), <br> <span class="keyword">let</span> combinedDef = defines <a href="#">+</a> def.att <a href="#">+</a> globaldefs, <br> <span class="keyword">if</span> <a href="#isdefine:classinfo:boolean">isdefine</a>.att <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> eval = <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>( <span class="literal">""</span>, combinedDef, content, replacements, xhtml) <br> <span class="keyword">let</span> stk2 = <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"mark"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1, <br>next(skip, defines <a href="#">+</a> eval, stk2, smallacc)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> new = <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>(smallacc, combinedDef, content, replacements, xhtml) <br> <span class="keyword">let</span> stk2 = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/caption"</span> <span class="keyword">then</span> push(marks1, mark( <span class="literal">"/tr"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if <a href="#ismark:classinfo:boolean">ismark</a>.att <span class="keyword">then</span> <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"mark"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1 <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/br"</span> <span class="keyword">then</span> marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/tr"</span> <span class="keyword">then</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"/tr"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/td /th"</span> <span class="keyword">then</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"/td"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/div"</span> <span class="keyword">then</span> push( <a href="#">pop</a>.marks1, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> stk3 = <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1, <br> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.stk3 <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <span class="keyword">then</span> push( <a href="#">pop</a>.stk3, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)),</span></span> next(skip, <span class="literal">""</span>, stk2, new),</span></span></span></span></span> <span class="keyword">let</span> newacc = <a href="#finishp:seq.word:stack.mark:boolean:set.classinfo:seq.word:seq.word">finishp</a>(acc, marks, xhtml, replacements, defines <a href="#">+</a> pdef), <br> <span class="keyword">if</span> newacc <a href="#=:seq.T:seq.T:boolean">=</a> acc <span class="keyword">then</span> next(acc, marks) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">newacc <br>, push( <a href="#">pop</a>.marks, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.newacc))</span>)</span></span> <span class="comment">{assert false report"Final"+esc.acc0}</span> <br>acc0 <p> <a id="advance:stack.mark:mark:stack.mark" href="#markup">function</a> advance(stk:stack.mark, m:mark) stack.mark <br>push( <span class="block"> <span class="keyword">if</span> kind.m <a href="#=:word:word:boolean">=</a> kind. <a href="#">top</a>.stk <span class="keyword">then</span> <a href="#">pop</a>.stk <span class="keyword">else</span> stk <br>, m</span>) <p> <a id="finishp:seq.word:stack.mark:boolean:set.classinfo:seq.word:seq.word" href="#markup">function</a> finishp( <br>acc:seq.word <br>, marks:stack.mark <br>, xhtml:boolean <br>, replacements:set.classinfo <br>, defs:seq.word <br>) seq.word <br> <span class="keyword">if</span> n.acc <a href="#=:int:int:boolean">=</a> place. <a href="#">top</a>.marks <span class="keyword">then</span> acc <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> top = place. <a href="#">top</a>.marks <br> <span class="keyword">let</span> content = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, top <a href="#+:int:int:int">+</a> 1, n.acc) <br> <span class="keyword">let</span> new = <span class="block"> <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, 1, top) <br>, defs <br>, content <br>, replacements <br>, xhtml</span>),</span> <span class="comment">{assert"zzz"sub 1 ∉ acc report"HJK"+showZ.new}</span> <br>new</span> <p> <a id="evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word" href="#markup">function</a> evaldef( <br>smallacc:seq.word <br>, defs:seq.word <br>, content:seq.word <br>, replacements:set.classinfo <br>, xhtml:boolean <br>) seq.word <br> <span class="keyword">let</span> evalstr = <a href="#">extractdef</a>(defs, <span class="literal">"output"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">for</span> <span class="block">haveatt = <span class="literal">""</span> <br>, stk = <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc = smallacc <br>, intag = false <br>, e3 ∈ evalstr <a href="#">+</a> <span class="literal">"?"</span></span> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"="</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:stack.T:boolean">isempty</a>.stk <span class="keyword">then</span> next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>(stk, <span class="literal">"bottom"</span>), acc, intag) <br> <span class="keyword">else</span> if intag <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <span class="keyword">then</span> <span class="block">next( <span class="block"> <span class="literal">""</span> <br>, <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>( <a href="#">top</a>.stk, haveatt <a href="#sub:seq.T:int:T">sub</a> 1) <br>, intag</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block">haveatt <br>, <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc <a href="#">+</a> <a href="#">top</a>.stk <br>, intag</span>)</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> info = <a href="#lookuptag:set.classinfo:word:seq.classinfo">lookuptag</a>(replacements, e3), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.info <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isendtag:classinfo:boolean">isendtag</a>.info <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> new = <span class="keyword">if</span> xhtml <a href="#∨:boolean:boolean:boolean">∨</a> e3 ∉ <span class="literal">"&lt;/p> &lt;/li>"</span> <span class="keyword">then</span> acc <a href="#">+</a> <span class="literal">"/tag"</span> <a href="#">+</a> e3 <span class="keyword">else</span> acc, <br>next(haveatt, stk, new, intag)</span> <span class="keyword">else</span> <span class="block">{assert e3 ∈"&lt;titlex"report"here gg JKL:(e3):(intag)"+acc+"/p"+evalstr} <br> <span class="keyword">let</span> acc1 = <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"&lt;sub &lt;sup"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#last:seq.T:T">last</a>.acc <a href="#">∈</a> <span class="literal">"/tag"</span> <span class="keyword">then</span> acc <a href="#">+</a> e3 <br> <span class="keyword">else</span> acc <a href="#">+</a> <span class="literal">"/tag"</span> <a href="#">+</a> e3</span> <span class="keyword">else</span> acc <a href="#">+</a> <span class="literal">"/sp /tag"</span> <a href="#">+</a> e3,</span> next( <span class="literal">""</span>, stk, acc1, true)</span></span> <span class="keyword">else</span> if e3 <a href="#">∈</a> <span class="literal">"> />"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> end = <span class="keyword">if</span> xhtml <a href="#∧:boolean:boolean:boolean">∧</a> e3 <a href="#">∈</a> <span class="literal">"/>"</span> <span class="keyword">then</span> <span class="literal">"/tag /> /nsp"</span> <span class="keyword">else</span> <span class="literal">"/tag > /nsp"</span> <br> <span class="keyword">let</span> lastatt = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <br> <a href="#∧:boolean:boolean:boolean">∧</a> intag <span class="keyword">then</span> <span class="block">acc <br> <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>( <span class="block"> <a href="#">extractdef</a>(defs, haveatt <a href="#sub:seq.T:int:T">sub</a> 1, content) <br>, haveatt <a href="#sub:seq.T:int:T">sub</a> 1</span>)</span> <span class="keyword">else</span> acc,</span> next( <span class="literal">""</span>, stk, lastatt <a href="#">+</a> end, false)</span> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>. <a href="#isempty:stack.T:boolean">isempty</a>.stk <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"/post /pre"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">assert</span> n.toseq.stk <a href="#>:int:int:boolean">></a> 2 <span class="keyword">report</span> <span class="literal">"XXX B"</span> <br> <span class="keyword">let</span> second = <a href="#">top</a>.stk <br> <span class="keyword">let</span> first = <a href="#">top</a>. <a href="#">pop</a>.stk, <br> <span class="keyword">let</span> val = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.first <a href="#∧:boolean:boolean:boolean">∧</a> e3 <a href="#">∈</a> <span class="literal">"/pre"</span> <span class="keyword">then</span> second <br> <span class="keyword">else</span> first <a href="#">+</a> <span class="literal">"/nsp"</span> <a href="#">+</a> second,</span> next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>( <a href="#">pop</a>(stk, 2), val), acc, intag)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> result = <a href="#dawsextensions:word:stack.seq.word:stack.seq.word">dawsextensions</a>(e3, stk), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:stack.T:boolean">isempty</a>.result <span class="keyword">then</span> next(haveatt, result, acc, intag) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> value = <a href="#">extractdef</a>(defs, e3, content), <br>next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>(stk, value), acc, intag)</span></span></span> <span class="keyword">else</span> if intag <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <span class="keyword">then</span> next([e3], stk, acc, intag) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> val = <a href="#">extractdef</a>(defs, haveatt <a href="#sub:seq.T:int:T">sub</a> 1, content) <br> <span class="keyword">assert</span> haveatt <a href="#">∈</a> [ <span class="literal">"rel"</span>, <span class="literal">"class"</span>, <span class="literal">"id"</span>, <span class="literal">"alt"</span>] <span class="keyword">report</span> <span class="literal">"val att:(haveatt)this"</span> <a href="#">+</a> e3 <a href="#">+</a> acc <a href="#>>:seq.T:int:seq.T">>></a> (n.acc <a href="#">-</a> 4), <br>next([e3], stk, acc <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>(val, haveatt <a href="#sub:seq.T:int:T">sub</a> 1), intag)</span></span> <span class="keyword">else</span> next(haveatt, stk, acc <a href="#">+</a> <a href="#">extractdef</a>(defs, e3, content), intag),</span></span> acc <p> <a id="extractdef:seq.word:word:seq.word:seq.word" href="#markup">function</a> extractdef(defs:seq.word, name:word, content:seq.word) seq.word <br> <span class="keyword">if</span> name <a href="#">∈</a> <span class="literal">"content"</span> <span class="keyword">then</span> content <br> <span class="keyword">else</span> if name <a href="#">∈</a> <span class="literal">"colon"</span> <span class="keyword">then</span> <span class="literal">": "</span> <br> <span class="keyword">else</span> <a href="#">extractdef</a>(defs, name) <p> <a id="attribute:seq.word:word:seq.word" href="#markup">Function</a> attribute(val:seq.word, att:word) seq.word <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.val <span class="keyword">then</span> <span class="literal">""</span> <br> <span class="keyword">else</span> <span class="literal">"/sp:(att)/nsp =:(( <a href="#">dq</a> <a href="#">+</a> <span class="literal">"/nsp"</span> <a href="#">+</a> val <a href="#">+</a> <a href="#">dq</a>))"</span> <p> <span class="keyword" id="format1a">Module</span> format1a <p>use PEGrules <p>use UTF8 <p>use bits <p>use seq.seq.byte <p>use seq1.byte <p>use stack.frame <p>use seq1.int <p>use set.int <p>use standard <p>use seq.tableEntry <p>use seq.word <p>use seq1.seq.word <p> <a id="showZ:seq.word:seq.word" href="#format1a">function</a> showZ(out:seq.word) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, w ∈ out <br> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block"> <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <a href="#">+</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Z"</span></span>),</span> acc <p> <a id="toAttribute:seq.byte:seq.word:seq.byte" href="#format1a">function</a> toAttribute(a:seq.byte, b:seq.word) seq.byte <a href="#X:seq.word:seq.byte">X</a>.b <p> <a id="escape&amp;&lt;:seq.byte:seq.byte" href="#format1a">function</a> escape&amp;&lt;(a:seq.byte) seq.byte <br> <span class="keyword">let</span> lt = <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span> <br> <span class="keyword">let</span> amp = <span class="block"> <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&amp;"</span></span> <span class="keyword">for</span> i = 1, e ∈ a <br> <span class="keyword">while</span> e ≠ lt <a href="#∧:boolean:boolean:boolean">∧</a> e ≠ amp <br> <span class="keyword">do</span> i <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:byte:byte:boolean">=</a> amp <span class="keyword">then</span> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&amp;amp;"</span> <br> <span class="keyword">else</span> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&amp;lt;"</span>) <br> <a href="#">+</a> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>(a <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i)</span> <p> <a id="X:seq.word:seq.byte" href="#format1a">function</a> X(a:seq.word) seq.byte <br> <span class="keyword">for</span> acc0 = empty:seq.byte, w ∈ a <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> acc = acc0, ch ∈ <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> ( <span class="keyword">if</span> toint.ch <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> [ <a href="#tobyte:int:byte">tobyte</a>.toint.ch] <br> <span class="keyword">else</span> toseqbyte. <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>.ch),</span> acc <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32,</span> acc0 <a href="#>>:seq.T:int:seq.T">>></a> 1 <p> <a id="textFormat1a:seq.word:UTF8" href="#format1a">Function</a> textFormat1a(myinput:seq.word) UTF8 <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> r = <a href="#parse:seq.word:seq.byte:boolean:thisresult">parse</a>(myinput, empty:seq.byte, true) <br> <span class="comment">{assert false report trace.r}</span> <br>UTF8( <a href="#result:thisresult:seq.byte">result</a>.r <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32) <p> <a id="HTMLformat1a:seq.word:UTF8" href="#format1a">Function</a> HTMLformat1a(myinput:seq.word) UTF8 <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> r = <a href="#parse:seq.word:seq.byte:boolean:thisresult">parse</a>(myinput, empty:seq.byte, false) <br> <span class="comment">{assert false report}</span> <br>UTF8( <a href="#result:thisresult:seq.byte">result</a>.r <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32) <p> <a id="addSpace:seq.byte:seq.byte" href="#format1a">function</a> addSpace(a:seq.byte) seq.byte <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.32 <span class="keyword">then</span> a <br> <span class="keyword">else</span> a <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32 <p> <a id="paragraph:seq.byte:seq.byte" href="#format1a">function</a> paragraph(a:seq.byte) seq.byte <br> <span class="comment">{used for text and not html}</span> <br>a <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a ≠ <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span>[ <a href="#tobyte:int:byte">tobyte</a>.10] <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.10 <br> <span class="keyword">else</span> [ <a href="#tobyte:int:byte">tobyte</a>.10]) <p> <a id="linebreak:seq.byte:seq.byte" href="#format1a">function</a> linebreak(a:seq.byte) seq.byte <br> <span class="comment">{used for text and not html}</span> <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a ≠ <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span> a <a href="#">+</a> [ <a href="#tobyte:int:byte">tobyte</a>.10] <br> <span class="keyword">else</span> a <p>CN process commands with no space pending <p>CS process commands with space pending <p>N no commands with no space pending <p>S no commands with space pending <p>NSBA no space before or after <p>NSB no space before <p> <a id="endMark:word" href="#format1a">function</a> endMark word <a href="#encodeword:seq.char:word">encodeword</a>.[char.254] <p> <a id="break:word" href="#format1a">function</a> break word <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="genPEG:word:seq.byte:thisresult:boolean:boolean:seq.boolean" href="#format1a">function</a> genPEG( <br>seqElementType:word <br>, attributeType:seq.byte <br>, resultType:thisresult <br>, textOut:boolean <br>, commonType:boolean <br>) seq.boolean <br> <span class="comment">{commonName: textOut notablex: wordmap: dq dq sub 1, ec escapeformat, tag merge."/ ta g", break"/br<br>"sub 1,"$"sub 1}</span> <br>[ <span class="block"> <span class="literal">"* CN+"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/-"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/."</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/:"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/. "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/: "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/("</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/)"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/{"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/}"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/["</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/]"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"/ /sp"</span> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ /nsp"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ break"</span> <br> <a href="#">=</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#linebreak:seq.byte:seq.byte">linebreak</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <span class="keyword">else</span> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&lt;br>"</span>) <br>, <span class="literal">"/ /p"</span> <br> <a href="#">=</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#paragraph:seq.byte:seq.byte">paragraph</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <span class="keyword">else</span> <span class="block"> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>([ <a href="#encodeword:seq.char:word">encodeword</a>.[char.10, char.10]] <a href="#">+</a> <span class="literal">"&lt;p>"</span>)</span>) <br>, <span class="literal">"/ ec N"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/ CS"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"+CS,"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br>, <span class="literal">"/ /sp"</span> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ tag ! ec any"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/ !+!-!.!:!. !: ! dq !(!)![!]!{!}! /p ! break ! ec ! tag ! /nsp any"</span> <br> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#$:int:seq.byte">$</a>.1 <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>. <a href="#$:int:seq.byte">$</a>.1) <br>, <span class="literal">"N N' ec CN"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.1 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.2 <br>, <span class="literal">"* N' S+"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/ S-"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/ S."</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/ S:"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/ S. "</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/ S: "</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ S dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/ S("</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/ S)"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/ S{"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/ S}"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/ S["</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/ S]"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"/ S"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/+"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/-"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/."</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/:"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/. "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/: "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/("</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/)"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/{"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/}"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/["</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/]"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"+S,"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br>, <span class="literal">"/ !+!-!.!:!. !: ! dq !(!)![!]!{!}! ec any"</span> <br> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#$:int:seq.byte">$</a>.1 <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>. <a href="#$:int:seq.byte">$</a>.1)</span>] <p>&lt;&lt;&lt;&lt; Below is auto generated code >>>> <p> <br>Non-terminals:CN CS N N' S <br>Terminals:()+,-.. <p> :: []any break dq ec tag{} <br>* CN ←+/-/./:/. /: / dq /(/)/{/}/[/]/ // break / <p>/ ec N / CS <br>+CS ←, / / tag ! ec any / !+!-!.!:!. !: ! dq !(!)![!]!{!}! <p>! break ! ec ! tag !any <br>N ← N' ec CN <br>* N' ← S+/ S-/ S./ S:/ S. / S: / S dq / S(/ S)/ S{/ S}/ S[/ S]/ S /+/-/./:/. /: / dq /(/)/{/}/[/] <br>+S ←, / !+!-!.!:!. !: ! dq !(!)![!]!{!}! ec any <p> <a id="action:int:seq.seq.byte:boolean:seq.byte" href="#format1a">function</a> action(partno:int, R:seq.seq.byte, textOut:boolean) seq.byte <br> <span class="keyword">if</span> partno <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 3 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 4 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 5 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 6 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 7 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 8 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 9 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 10 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 11 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 12 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 13 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 14 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 15 <span class="keyword">then</span> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 16 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 17 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#linebreak:seq.byte:seq.byte">linebreak</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&lt;br>"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 18 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#paragraph:seq.byte:seq.byte">paragraph</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>([ <a href="#encodeword:seq.char:word">encodeword</a>.[char.10, char.10]] <a href="#">+</a> <span class="literal">"&lt;p>"</span>)</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 19 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 20 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 21 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 22 <span class="keyword">then</span> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 23 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 24 <span class="keyword">then</span> <span class="block"> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R)</span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 25 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 26 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 27 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 28 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 29 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 30 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 31 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 32 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 33 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 34 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 35 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 36 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 37 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 38 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 39 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 40 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 41 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 42 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 43 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 44 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 45 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 46 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 47 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 48 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 49 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 50 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 51 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 52 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 53 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 54 <span class="keyword">then</span> <span class="block"> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R)</span> <span class="keyword">else</span> R <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="mytable:seq.tableEntry" href="#format1a">function</a> mytable seq.tableEntry <br>[ <span class="block">{1} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.2 <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Match:state">Match</a> <br>, <a href="#Failure:state">Failure</a> <br>, <span class="literal">""</span></span>) <br>, {2} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(2, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.3 <br>, <span class="literal">""</span></span>) <br>, {3} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(3, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.4 <br>, <span class="literal">""</span></span>) <br>, {4} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(4, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.5 <br>, <span class="literal">""</span></span>) <br>, {5} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(5, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.6 <br>, <span class="literal">""</span></span>) <br>, {6} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(6, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.7 <br>, <span class="literal">""</span></span>) <br>, {7} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(7, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.8 <br>, <span class="literal">""</span></span>) <br>, {8} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(8, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.9 <br>, <span class="literal">""</span></span>) <br>, {9} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(9, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.10 <br>, <span class="literal">""</span></span>) <br>, {10} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(10, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.11 <br>, <span class="literal">""</span></span>) <br>, {11} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(11, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.12 <br>, <span class="literal">""</span></span>) <br>, {12} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(12, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.13 <br>, <span class="literal">""</span></span>) <br>, {13} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(13, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.14 <br>, <span class="literal">""</span></span>) <br>, {14} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(14, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.15 <br>, <span class="literal">""</span></span>) <br>, {15} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(15, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.16 <br>, <span class="literal">""</span></span>) <br>, {16} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(16, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.17 <br>, <span class="literal">""</span></span>) <br>, {17} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(17, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.18 <br>, <span class="literal">""</span></span>) <br>, {18} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(18, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.19 <br>, <span class="literal">""</span></span>) <br>, {19} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#NT:int:state">NT</a>.20 <br>, <a href="#NT:int:state">NT</a>.21 <br>, <span class="literal">""</span></span>) <br>, {20} <br>tableEntry( <span class="block"> <a href="#NT:int:state">NT</a>.46 <br>, <span class="literal">"N"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(19, <a href="#T':int:state">T'</a>.2) <br>, <a href="#NT:int:state">NT</a>.21 <br>, <span class="literal">""</span></span>) <br>, {21} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.22 <br>, <span class="literal">"CS"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(20, <a href="#T':int:state">T'</a>.2) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {22} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(21, <a href="#T':int:state">T'</a>.105) <br>, <a href="#T':int:state">T'</a>.23 <br>, <span class="literal">""</span></span>) <br>, {23} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(22, <a href="#T':int:state">T'</a>.105) <br>, <a href="#">T</a>.24 <br>, <span class="literal">""</span></span>) <br>, {24} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#!T:int:state">!T</a>.25 <br>, <a href="#!T:int:state">!T</a>.27 <br>, <span class="literal">""</span></span>) <br>, {25} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#!T:int:state">!T</a>.27 <br>, <a href="#MatchAny:int:state">MatchAny</a>.26 <br>, <span class="literal">""</span></span>) <br>, {26} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(23, <a href="#T':int:state">T'</a>.105) <br>, <a href="#!T:int:state">!T</a>.27 <br>, <span class="literal">""</span></span>) <br>, {27} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.28 <br>, <span class="literal">""</span></span>) <br>, {28} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.29 <br>, <span class="literal">""</span></span>) <br>, {29} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.30 <br>, <span class="literal">""</span></span>) <br>, {30} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.31 <br>, <span class="literal">""</span></span>) <br>, {31} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.32 <br>, <span class="literal">""</span></span>) <br>, {32} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.33 <br>, <span class="literal">""</span></span>) <br>, {33} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.34 <br>, <span class="literal">""</span></span>) <br>, {34} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.35 <br>, <span class="literal">""</span></span>) <br>, {35} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.36 <br>, <span class="literal">""</span></span>) <br>, {36} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.37 <br>, <span class="literal">""</span></span>) <br>, {37} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.38 <br>, <span class="literal">""</span></span>) <br>, {38} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.39 <br>, <span class="literal">""</span></span>) <br>, {39} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.40 <br>, <span class="literal">""</span></span>) <br>, {40} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.41 <br>, <span class="literal">""</span></span>) <br>, {41} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.42 <br>, <span class="literal">""</span></span>) <br>, {42} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.43 <br>, <span class="literal">""</span></span>) <br>, {43} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.44 <br>, <span class="literal">""</span></span>) <br>, {44} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.45 <br>, <span class="literal">""</span></span>) <br>, {45} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(24, <a href="#T':int:state">T'</a>.105) <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {46} <br>tableEntry( <span class="block"> <a href="#NT:int:state">NT</a>.49 <br>, <span class="literal">"N'"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#">T</a>.47 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {47} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#NT:int:state">NT</a>.48 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {48} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.2 <br>, <span class="literal">"CN"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce:int:state">Reduce</a>.25 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {49} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.50 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {50} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(26, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.52 <br>, <span class="literal">""</span></span>) <br>, {51} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.52 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {52} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(27, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.54 <br>, <span class="literal">""</span></span>) <br>, {53} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.54 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {54} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(28, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.56 <br>, <span class="literal">""</span></span>) <br>, {55} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.56 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {56} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(29, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.58 <br>, <span class="literal">""</span></span>) <br>, {57} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.58 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {58} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(30, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.60 <br>, <span class="literal">""</span></span>) <br>, {59} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.60 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {60} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(31, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.62 <br>, <span class="literal">""</span></span>) <br>, {61} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.62 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {62} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(32, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.64 <br>, <span class="literal">""</span></span>) <br>, {63} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.64 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {64} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(33, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.66 <br>, <span class="literal">""</span></span>) <br>, {65} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.66 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {66} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(34, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.68 <br>, <span class="literal">""</span></span>) <br>, {67} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.68 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {68} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(35, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.70 <br>, <span class="literal">""</span></span>) <br>, {69} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.70 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {70} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(36, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.72 <br>, <span class="literal">""</span></span>) <br>, {71} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.72 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {72} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(37, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#">T</a>.74 <br>, <span class="literal">""</span></span>) <br>, {73} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#">T</a>.74 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {74} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(38, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#NT:int:state">NT</a>.75 <br>, <span class="literal">""</span></span>) <br>, {75} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(39, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {76} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(40, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.77 <br>, <span class="literal">""</span></span>) <br>, {77} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(41, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.78 <br>, <span class="literal">""</span></span>) <br>, {78} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(42, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.79 <br>, <span class="literal">""</span></span>) <br>, {79} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(43, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.80 <br>, <span class="literal">""</span></span>) <br>, {80} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(44, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.81 <br>, <span class="literal">""</span></span>) <br>, {81} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(45, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.82 <br>, <span class="literal">""</span></span>) <br>, {82} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(46, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.83 <br>, <span class="literal">""</span></span>) <br>, {83} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(47, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.84 <br>, <span class="literal">""</span></span>) <br>, {84} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(48, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.85 <br>, <span class="literal">""</span></span>) <br>, {85} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(49, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.86 <br>, <span class="literal">""</span></span>) <br>, {86} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(50, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.87 <br>, <span class="literal">""</span></span>) <br>, {87} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(51, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#">T</a>.88 <br>, <span class="literal">""</span></span>) <br>, {88} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(52, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {89} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(53, <a href="#">T</a>.129) <br>, <a href="#!T:int:state">!T</a>.90 <br>, <span class="literal">""</span></span>) <br>, {90} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.91 <br>, <span class="literal">""</span></span>) <br>, {91} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.92 <br>, <span class="literal">""</span></span>) <br>, {92} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.93 <br>, <span class="literal">""</span></span>) <br>, {93} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.94 <br>, <span class="literal">""</span></span>) <br>, {94} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.95 <br>, <span class="literal">""</span></span>) <br>, {95} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.96 <br>, <span class="literal">""</span></span>) <br>, {96} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.97 <br>, <span class="literal">""</span></span>) <br>, {97} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.98 <br>, <span class="literal">""</span></span>) <br>, {98} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.99 <br>, <span class="literal">""</span></span>) <br>, {99} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.100 <br>, <span class="literal">""</span></span>) <br>, {100} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.101 <br>, <span class="literal">""</span></span>) <br>, {101} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.102 <br>, <span class="literal">""</span></span>) <br>, {102} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.103 <br>, <span class="literal">""</span></span>) <br>, {103} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.104 <br>, <span class="literal">""</span></span>) <br>, {104} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(54, <a href="#">T</a>.129) <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {105} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(21, <a href="#T':int:state">T'</a>.105) <br>, <a href="#T':int:state">T'</a>.106 <br>, <span class="literal">""</span></span>) <br>, {106} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(22, <a href="#T':int:state">T'</a>.105) <br>, <a href="#">T</a>.107 <br>, <span class="literal">""</span></span>) <br>, {107} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#!T:int:state">!T</a>.108 <br>, <a href="#!T:int:state">!T</a>.110 <br>, <span class="literal">""</span></span>) <br>, {108} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#!T:int:state">!T</a>.110 <br>, <a href="#MatchAny:int:state">MatchAny</a>.109 <br>, <span class="literal">""</span></span>) <br>, {109} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(23, <a href="#T':int:state">T'</a>.105) <br>, <a href="#!T:int:state">!T</a>.110 <br>, <span class="literal">""</span></span>) <br>, {110} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.111 <br>, <span class="literal">""</span></span>) <br>, {111} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.112 <br>, <span class="literal">""</span></span>) <br>, {112} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.113 <br>, <span class="literal">""</span></span>) <br>, {113} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.114 <br>, <span class="literal">""</span></span>) <br>, {114} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.115 <br>, <span class="literal">""</span></span>) <br>, {115} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.116 <br>, <span class="literal">""</span></span>) <br>, {116} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.117 <br>, <span class="literal">""</span></span>) <br>, {117} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.118 <br>, <span class="literal">""</span></span>) <br>, {118} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.119 <br>, <span class="literal">""</span></span>) <br>, {119} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.120 <br>, <span class="literal">""</span></span>) <br>, {120} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.121 <br>, <span class="literal">""</span></span>) <br>, {121} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.122 <br>, <span class="literal">""</span></span>) <br>, {122} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.123 <br>, <span class="literal">""</span></span>) <br>, {123} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.124 <br>, <span class="literal">""</span></span>) <br>, {124} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.125 <br>, <span class="literal">""</span></span>) <br>, {125} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.126 <br>, <span class="literal">""</span></span>) <br>, {126} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.127 <br>, <span class="literal">""</span></span>) <br>, {127} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.128 <br>, <span class="literal">""</span></span>) <br>, {128} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(24, <a href="#T':int:state">T'</a>.105) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {129} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(53, <a href="#">T</a>.129) <br>, <a href="#!T:int:state">!T</a>.130 <br>, <span class="literal">""</span></span>) <br>, {130} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.131 <br>, <span class="literal">""</span></span>) <br>, {131} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.132 <br>, <span class="literal">""</span></span>) <br>, {132} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.133 <br>, <span class="literal">""</span></span>) <br>, {133} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.134 <br>, <span class="literal">""</span></span>) <br>, {134} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.135 <br>, <span class="literal">""</span></span>) <br>, {135} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.136 <br>, <span class="literal">""</span></span>) <br>, {136} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.137 <br>, <span class="literal">""</span></span>) <br>, {137} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.138 <br>, <span class="literal">""</span></span>) <br>, {138} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.139 <br>, <span class="literal">""</span></span>) <br>, {139} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.140 <br>, <span class="literal">""</span></span>) <br>, {140} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.141 <br>, <span class="literal">""</span></span>) <br>, {141} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.142 <br>, <span class="literal">""</span></span>) <br>, {142} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.143 <br>, <span class="literal">""</span></span>) <br>, {143} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.144 <br>, <span class="literal">""</span></span>) <br>, {144} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(54, <a href="#">T</a>.129) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>)</span>] <p> <a id="=:seq.word:seq.byte:boolean" href="#format1a">function</a> =(seq.word, seq.byte) boolean true <p> <a id="$:int:seq.byte" href="#format1a">function</a> $(int) seq.byte empty:seq.seq.byte <a href="#sub:seq.T:int:T">sub</a> 1 <p>use standard <p>use seq.tableEntry <p>use seq1.frame <p>use stack.frame <p>use seq1.seq.byte <p>use PEGrules <p> <a id="place:thisresult:int" href="#format1a">function</a> place(r:thisresult) int i. <a href="#">top</a>.stk.r <p>type frame is <br>Sstate:state <br>, Fstate:state <br>, i:int <br>, result:seq.seq.byte <br>, faili:int <br>, failresult:seq.seq.byte <p>type thisresult is stk:stack.frame <p> <a id="status:thisresult:word" href="#format1a">Function</a> status(a:thisresult) word <br> <span class="keyword">if</span> Sstate. <a href="#">top</a>.stk.a ≠ <a href="#Match:state">Match</a> <span class="keyword">then</span> 'Failed <br> <span class="keyword">else</span> if <a href="#place:thisresult:int">place</a>.a <a href="#=:int:int:boolean">=</a> {length of input}faili. <a href="#">top</a>.stk.a <span class="keyword">then</span> 'Match <br> <span class="keyword">else</span> 'MatchPrefix <p> <a id="result:thisresult:seq.byte" href="#format1a">Function</a> result(a:thisresult) seq.byte <br> <span class="keyword">let</span> t = result. <a href="#">top</a>.stk.a, <br>t <a href="#sub:seq.T:int:T">sub</a> n.t <p> <a id="parse:seq.word:seq.byte:boolean:thisresult" href="#format1a">function</a> parse(myinput0:seq.word, initAttr:seq.byte, textOut:boolean) thisresult <br> <span class="keyword">let</span> myinput = packed(myinput0 <a href="#">+</a> <a href="#endMark:word">endMark</a>) <br> <span class="keyword">let</span> packedTable = packed. <a href="#mytable:seq.tableEntry">mytable</a> <br> <span class="keyword">for</span> <span class="block">stk = <a href="#empty::stack.T:stack.T">empty:stack.frame</a> <br>, state = <a href="#startstate:state">startstate</a> <br>, i = 1 <br>, inputi = myinput <a href="#sub:seq.T:int:T">sub</a> 1 <br>, result = [initAttr] <br>, faili = 1 <br>, failresult = [initAttr]</span> <span class="keyword">while</span> toint.state <a href="#>:int:int:boolean">></a> toint. <a href="#Match:state">Match</a> <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> actionState = <a href="#action:state:state">action</a>.state, <br> <span class="keyword">if</span> actionState <a href="#=:state:state:boolean">=</a> <a href="#Fail:state">Fail</a> <span class="keyword">then</span> <span class="block">{goto Fstate.top.stk, i = faili.top, pop.stk, discard result} <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br> <span class="keyword">if</span> toint. <a href="#action:state:state">action</a>.Fstate.top ≥ toint. <a href="#">S'</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newi = i.top, <br>next( <span class="block"> <a href="#">pop</a>.stk <br>, <a href="#nextState:state:state">nextState</a>.Fstate.top <br>, newi <br>, idxNB(myinput, newi) <br>, result.top <br>, faili.top <br>, failresult.top</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block"> <a href="#">pop</a>.stk <br>, Fstate.top <br>, faili.top <br>, idxNB(myinput, faili.top) <br>, failresult.top <br>, faili.top <br>, failresult.top</span>)</span></span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Success*:state">Success*</a> <span class="keyword">then</span> <span class="block">{goto Sstate.top.stk, pop.stk, keep result} <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> result, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#">Discard*</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next( <span class="block">stk <br>, <a href="#nextState:state:state">nextState</a>.state <br>, i <br>, inputi <br>, result.top <br>, i <br>, result.top</span>)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#All:state">All</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> att = <span class="block">[ <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(myinput, i.top, i <a href="#">-</a> 1))],</span> next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> att, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Lambda:state">Lambda</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)], <br>next( <span class="block">stk <br>, <a href="#nextState2:state:state">nextState2</a>.state <br>, i <br>, inputi <br>, result <a href="#">+</a> att <br>, faili <br>, failresult</span>)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Reduce:state">Reduce</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)], <br>next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> att, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Reduce*:state">Reduce*</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)] <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next(stk, <a href="#nextState:state:state">nextState</a>.state, i, inputi, att, i, att)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!Reduce:state">!Reduce</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> ini = idxNB(myinput, faili.top), <br>next( <a href="#">pop</a>.stk, Fstate.top, faili.top, ini, failresult.top, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!Fail:state">!Fail</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> ini = idxNB(myinput, i.top), <br>next( <a href="#">pop</a>.stk, Sstate.top, i.top, ini, result.top, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#">T</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi ≠ match.te <span class="keyword">then</span>{fail}next(stk, Fstate.te, faili, idxNB(myinput, faili), failresult, faili, failresult) <br> <span class="keyword">else</span> next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), result, faili, failresult)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!T:state">!T</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> match.te <span class="keyword">then</span>{fail}next(stk, Sstate.te, faili, idxNB(myinput, faili), failresult, faili, failresult) <br> <span class="keyword">else</span> next(stk, Fstate.te, i, inputi, result, faili, failresult)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#MatchAny:state">MatchAny</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> <a href="#endMark:word">endMark</a> <span class="keyword">then</span>{fail}next(stk, Fstate.te, i, inputi, result, faili, failresult) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> reslt = <span class="block">result <a href="#">+</a> <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, [inputi])</span> <span class="keyword">let</span> ini = idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), <br>next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, ini, reslt, faili, failresult)</span></span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#T':state">T'</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> match.te <span class="keyword">then</span> next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), result, faili, failresult) <br> <span class="keyword">else</span> next(stk, Fstate.te, i, inputi, result, faili, failresult)</span> <span class="keyword">else</span> <span class="block">{match non Terminal} <br> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state) <br> <span class="keyword">assert</span> <a href="#action:state:state">action</a>.action.te <a href="#">∈</a> [ <a href="#">NT</a>, <a href="#">NT*</a>] <span class="keyword">report</span> <span class="literal">"PROBLEM PEG:(state)"</span> <br> <span class="keyword">let</span> newstk = push(stk, frame(Sstate.te, Fstate.te, i, result, faili, failresult)), <br> <span class="keyword">let</span> tmp = <span class="block">[ <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, empty:seq.word)],</span> next(newstk, <a href="#nextState:state:state">nextState</a>.action.te, i, inputi, tmp, i, tmp),</span></span> thisresult.push(stk, frame(state, state, i, result, n.myinput, result)) <p> <span class="keyword" id="format4">Module</span> format4 <p>use UTF8 <p>use bits <p>use stack.blkstk <p>use seq1.byte <p>use seq.byte <p>use seq.char <p>use standard <p>type blkstk is result:UTF8, kind:word <p> <a id="textFormat4:seq.word:UTF8" href="#format4">Function</a> textFormat4(s:seq.word) UTF8 <br> <span class="comment">{OPTION INLINE /br<br>nospace means add no space before word}</span> <br> <span class="keyword">let</span> newway = false, <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.s <span class="keyword">then</span> <a href="#emptyUTF8:UTF8">emptyUTF8</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> <span class="block">prefix = [char.10] <br>, stk = <a href="#empty::stack.T:stack.T">empty:stack.blkstk</a> <br>, cmd = true <br>, result = <a href="#emptyUTF8:UTF8">emptyUTF8</a> <br>, Space = false <br>, this = s <a href="#sub:seq.T:int:T">sub</a> 1 <br>, w ∈ s <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1 <a href="#">+</a> <span class="literal">"?"</span></span> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> chars = <a href="#decodeword:word:seq.char">decodeword</a>.this, <br> <span class="keyword">if</span> n.chars <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> ch = chars <a href="#sub:seq.T:int:T">sub</a> 1, <br> <span class="keyword">if</span> ch <br> <a href="#">∈</a> ( <a href="#decodeword:word:seq.char">decodeword</a>. <a href="#">merge</a>. <span class="literal">"+-.:"</span> <br> <a href="#">+</a> char.10 <br> <a href="#">+</a> char.32) <span class="keyword">then</span>{no Space before or after}next(prefix, stk, cmd, result <a href="#+:UTF8:seq.char:UTF8">+</a> chars, false, w) <br> <span class="keyword">else</span> if ch <br> <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <a href="#">merge</a>. <span class="literal">",]}):( <a href="#">dq</a>)"</span> <span class="keyword">then</span>{no Space before but Space after}next(prefix, stk, cmd, result <a href="#+:UTF8:seq.char:UTF8">+</a> chars, true, w) <br> <span class="keyword">else</span> if ch <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <a href="#">merge</a>. <span class="literal">"([{"</span> <span class="keyword">then</span> <span class="block">{Space before but no Space after} <br>next( <span class="block">prefix <br>, stk <br>, cmd <br>, <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br>, false <br>, w</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block">prefix <br>, stk <br>, cmd <br>, <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:char:UTF8">+</a> ch <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:char:UTF8">+</a> ch <br>, true <br>, w</span>)</span></span> <span class="keyword">else</span> if n.chars <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> this <a href="#">∈</a> <span class="literal">". : "</span> <span class="keyword">then</span>{no Space before or after}next(prefix, stk, cmd, result <a href="#+:UTF8:seq.char:UTF8">+</a> chars, false, w) <br> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>.cmd <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> chars2 = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:seq.char:UTF8">+</a> chars,</span> next(prefix, stk, cmd, chars2, true, w)</span> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"/p"</span> <span class="keyword">then</span> next(prefix, stk, cmd, <a href="#paragraph:UTF8:UTF8">paragraph</a>.result, false, w) <br> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"*>"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:stack.T:boolean">isempty</a>.stk <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> kind. <a href="#">top</a>.stk <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> R0 = toseqbyte.result. <a href="#">top</a>.stk <br> <span class="keyword">let</span> R1 = toseqbyte.result <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> n.toseqbyte.result. <a href="#">top</a>.stk, <br> <span class="keyword">let</span> z = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.R1 <span class="keyword">then</span> result <br> <span class="keyword">else</span> if newway <span class="keyword">then</span> <span class="block">UTF8(toseqbyte.result <a href="#>>:seq.T:int:seq.T">>></a> <a href="#endbreak:seq.byte:int">endbreak</a>.toseqbyte.result) <br> <a href="#+:UTF8:seq.char:UTF8">+</a> prefix <a href="#>>:seq.T:int:seq.T">>></a> 1</span> <span class="keyword">else</span> <a href="#block:seq.byte:seq.byte:UTF8">block</a>(R0, R1),</span> next(prefix <a href="#>>:seq.T:int:seq.T">>></a> 1, <a href="#">pop</a>.stk, cmd, z, false, w)</span> <span class="keyword">else</span> next(prefix, <a href="#">pop</a>.stk, cmd, result, Space, w)</span> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"&lt;*"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"table block"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> new = <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"block"</span> <a href="#∧:boolean:boolean:boolean">∧</a> newway <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#haslinebreak:seq.byte:boolean">haslinebreak</a>.toseqbyte.result <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> prefix <a href="#+:UTF8:char:UTF8">+</a> char.32 <br> <span class="keyword">else</span> result</span> <span class="keyword">else</span> result,</span> next( <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> prefix <a href="#">+</a> char.32 <span class="keyword">else</span> prefix <br>, push(stk, blkstk(result, w)) <br>, cmd <br>, new <br>, false <br>, <span class="literal">"/cell"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block">prefix <br>, push(stk, blkstk(result, w)) <br>, cmd <br>, <span class="keyword">if</span> Space <span class="keyword">then</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <span class="keyword">else</span> result <br>, false <br>, <span class="literal">"/cell"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span>)</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> chars2 = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:seq.char:UTF8">+</a> chars,</span> next(prefix, stk, cmd, chars2, true, w)</span></span> <span class="keyword">else</span> if this <a href="#=:word:word:boolean">=</a> <a href="#escapeformat:word">escapeformat</a> <span class="keyword">then</span> next(prefix, stk, <a href="#not:boolean:boolean">not</a>.cmd, result, Space, w) <br> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>.cmd <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> chars2 = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:seq.char:UTF8">+</a> chars,</span> next(prefix, stk, cmd, chars2, true, w)</span> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"/keyword /em /strong /cell"</span> <span class="keyword">then</span> next(prefix, stk, cmd, result, Space, w) <br> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"/sp"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.toseqbyte.result <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#last:seq.T:T">last</a>.toseqbyte.result <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.32 <span class="keyword">then</span> next(prefix, stk, cmd, result, false, w) <br> <span class="keyword">else</span> next(prefix, stk, cmd, result <a href="#+:UTF8:char:UTF8">+</a> char.32, false, w)</span> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"/br"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> newway <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#haslinebreak:seq.byte:boolean">haslinebreak</a>.toseqbyte.result <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> z = result <a href="#+:UTF8:seq.char:UTF8">+</a> ( <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"/sp"</span> <span class="keyword">then</span> prefix <a href="#">+</a> char.32 <span class="keyword">else</span> prefix), <br>next(prefix, stk, cmd, z, false, w)</span> <span class="keyword">else</span> next(prefix, stk, cmd, result, false, w)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> z = UTF8. <a href="#linebreak:seq.byte:seq.byte">linebreak</a>.toseqbyte.result, <br>next(prefix, stk, cmd, z, false, w)</span></span> <span class="keyword">else</span> if this <a href="#">∈</a> <span class="literal">"/tag"</span> <span class="keyword">then</span> <span class="block">next( <span class="block">prefix <br>, stk <br>, cmd <br>, result <a href="#+:UTF8:seq.char:UTF8">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.w <br>, false <br>, <span class="literal">"/cell"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> chars2 = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.Space <span class="keyword">then</span> result <a href="#+:UTF8:seq.char:UTF8">+</a> chars <br> <span class="keyword">else</span> result <a href="#+:UTF8:char:UTF8">+</a> char.32 <a href="#+:UTF8:seq.char:UTF8">+</a> chars,</span> next(prefix, stk, cmd, chars2, true, w),</span></span> result <a href="#+:UTF8:char:UTF8">+</a> char.32</span> <p> <a id="block:seq.byte:seq.byte:UTF8" href="#format4">function</a> block(R0:seq.byte, R1:seq.byte) UTF8 <br> <span class="keyword">let</span> body = <span class="block"> <span class="keyword">if</span> <a href="#last:seq.T:T">last</a>.R1 <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span> R1 <a href="#>>:seq.T:int:seq.T">>></a> 1 <br> <span class="keyword">else</span> R1</span> <span class="keyword">let</span> init = <span class="block"> <a href="#linebreak:seq.byte:seq.byte">linebreak</a>.R0 <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(body, 1, 1) <br> <a href="#=:seq.T:seq.T:boolean">=</a> [ <a href="#tobyte:int:byte">tobyte</a>.32] <span class="keyword">then</span> empty:seq.byte <br> <span class="keyword">else</span> [ <a href="#tobyte:int:byte">tobyte</a>.32])</span> <span class="keyword">for</span> acc = init, b ∈ body <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> b <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span> acc <a href="#">+</a> b <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32 <br> <span class="keyword">else</span> acc <a href="#">+</a> b,</span> UTF8. <a href="#linebreak:seq.byte:seq.byte">linebreak</a>.acc <p> <a id="haslinebreak:seq.byte:boolean" href="#format4">function</a> haslinebreak(b:seq.byte) boolean <br> <a href="#endbreak:seq.byte:int">endbreak</a>.b <a href="#>:int:int:boolean">></a> 0 <p> <a id="endbreak:seq.byte:int" href="#format4">function</a> endbreak(b:seq.byte) int <br> <span class="keyword">for</span> <span class="block">a = <a href="#tobyte:int:byte">tobyte</a>.32 <br>, count = 0 <br>, e ∈ <a href="#reverse:seq.T:seq.T">reverse</a>.b</span> <span class="keyword">while</span> a <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.32 <br> <span class="keyword">do</span> next(e, count <a href="#+:int:int:int">+</a> 1), <br> <span class="keyword">if</span> a ≠ <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span> 0 <span class="keyword">else</span> count <p> <a id="paragraph:UTF8:UTF8" href="#format4">function</a> paragraph(ain:UTF8) UTF8 <br> <span class="keyword">let</span> a = toseqbyte.ain, <br>ain <br> <a href="#+:UTF8:seq.char:UTF8">+</a> ( <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#haslinebreak:seq.byte:boolean">haslinebreak</a>.a <span class="keyword">then</span>[char.10, char.10] <br> <span class="keyword">else</span> [char.10]) <p> <a id="linebreak:seq.byte:seq.byte" href="#format4">function</a> linebreak(a:seq.byte) seq.byte <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#haslinebreak:seq.byte:boolean">haslinebreak</a>.a <span class="keyword">then</span> a <a href="#">+</a> [ <a href="#tobyte:int:byte">tobyte</a>.10] <br> <span class="keyword">else</span> a <p> <span class="keyword" id="graph">Module</span> graph.T <p>use standard <p>use set.&lt;&lt;.T <p>use set.T <p>use seq.barc.T <p>use set.barc.T <p> <span class="keyword">unbound</span> tail(T) &lt;&lt;.T <p> <span class="keyword">unbound</span> head(T) &lt;&lt;.T <p> <span class="keyword">unbound</span> toarc(&lt;&lt;.T) T <p> <span class="keyword">unbound</span> >1(&lt;&lt;.T, &lt;&lt;.T) ordering <p> <span class="keyword">Export</span> head(T) &lt;&lt;.T <p> <a id=">1:T:T:ordering" href="#graph">Function</a> >1(a:T, b:T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <br> <a href="#∧:ordering:ordering:ordering">∧</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.b <p> <a id=">2:T:T:ordering" href="#graph">Function</a> >2(a:T, b:T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <p>type &lt;&lt; is dummy:T <p>type barc is arc:T <p> <a id="head:barc.T:&lt;&lt;.T" href="#graph">Function</a> head(b:barc.T) &lt;&lt;.T <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.arc.b <p> <a id="tail:barc.T:&lt;&lt;.T" href="#graph">Function</a> tail(b:barc.T) &lt;&lt;.T <a href="#head:barc.T:&lt;&lt;.T">head</a>.arc.b <p> <a id=">1:barc.T:barc.T:ordering" href="#graph">Function</a> >1(a:barc.T, b:barc.T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <br> <a href="#∧:ordering:ordering:ordering">∧</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.b <p> <a id=">2:barc.T:barc.T:ordering" href="#graph">Function</a> >2(a:barc.T, b:barc.T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <p> <a id="tobarc:seq.T:seq.barc.T" href="#graph">Function</a> tobarc(s:seq.T) seq.barc.T <br> <span class="keyword">for</span> acc = empty:seq.barc.T, e ∈ s <span class="keyword">do</span> acc <a href="#">+</a> barc.e, <br>acc <p> <a id="toarcs:seq.barc.T:seq.T" href="#graph">Function</a> toarcs(s:seq.barc.T) seq.T <br> <span class="keyword">for</span> acc = empty:seq.T, e ∈ s <span class="keyword">do</span> acc <a href="#">+</a> arc.e, <br>acc <p>type graph is arcs:set.T, backarcs:set.barc.T, nodes:set.&lt;&lt;.T <p> <span class="keyword">Export</span> nodes(graph.T) set.&lt;&lt;.T <p> <span class="keyword">Export</span> arcs(graph.T) set.T <p> <span class="keyword">Export</span> type:graph.T <p>/Export type:barc.T <p>/Export type:&lt;&lt;.T <p> <a id="newgraph:seq.T:graph.T" href="#graph">Function</a> newgraph(arcs:seq.T) graph.T <br> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>, e ∈ arcs <br> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.e <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e, <br>graph( <span class="block"> <a href="#asset:seq.T:set.T">asset</a>.arcs <br>, <a href="#asset:seq.T:set.T">asset</a>. <a href="#tobarc:seq.T:seq.barc.T">tobarc</a>.arcs <br>, acc</span>) <p> <a id="arcstosuccessors:graph.T:&lt;&lt;.T:set.T" href="#graph">Function</a> arcstosuccessors(g:graph.T, n:&lt;&lt;.T) set.T <br> <a href="#findelement2:set.T:T:set.T">findelement2</a>(arcs.g, <a href="#toarc:T:arc.T">toarc</a>.n) <p> <a id="successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> successors(g:graph.T, n:&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">for</span> <span class="block">acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a> <br>, @e ∈ toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(arcs.g, <a href="#toarc:T:arc.T">toarc</a>.n)</span> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.@e, <br>acc <p> <a id="arcstopredecessors:graph.T:&lt;&lt;.T:seq.T" href="#graph">Function</a> arcstopredecessors(g:graph.T, n:&lt;&lt;.T) seq.T <br> <a href="#toarcs:seq.barc.T:seq.T">toarcs</a>.toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(backarcs.g, barc. <a href="#toarc:T:arc.T">toarc</a>.n) <p> <a id="predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> predecessors(g:graph.T, n:&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">for</span> <span class="block">acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a> <br>, e ∈ toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(backarcs.g, barc. <a href="#toarc:T:arc.T">toarc</a>.n)</span> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e, <br>acc <p> <a id="replacearcs:graph.T:set.T:set.T:graph.T" href="#graph">Function</a> replacearcs(g:graph.T, oldarcs:set.T, newarcs:set.T) graph.T <br> <a href="#deletearcs:graph.T:set.T:graph.T">deletearcs</a>(g, oldarcs <a href="#\:set.T:set.T:set.T">\</a> newarcs) <br> <a href="#">+</a> toseq(newarcs <a href="#\:set.T:set.T:set.T">\</a> oldarcs) <p> <a id="deletearc:graph.T:T:graph.T" href="#graph">Function</a> deletearc(g:graph.T, a:T) graph.T <br>graph(arcs.g <a href="#-:set.T:T:set.T">-</a> a, backarcs.g <a href="#-:set.T:T:set.T">-</a> barc.a, nodes.g) <p> <a id="deletearcs:graph.T:set.T:graph.T" href="#graph">Function</a> deletearcs(g:graph.T, a:set.T) graph.T <br> <span class="keyword">for</span> acc = g, e ∈ toseq.a <span class="keyword">do</span> <a href="#deletearc:graph.T:T:graph.T">deletearc</a>(acc, e), <br>acc <p> <a id="+:graph.T:seq.&lt;&lt;.T:graph.T" href="#graph">Function</a> +(g:graph.T, nodes:seq.&lt;&lt;.T) graph.T <br>graph(arcs.g, backarcs.g, <a href="#asset:seq.T:set.T">asset</a>.nodes <a href="#">∪</a> nodes.g) <p> <a id="+:graph.T:T:graph.T" href="#graph">Function</a> +(g:graph.T, a:T) graph.T <br>graph( <span class="block">arcs.g <a href="#+:set.T:T:set.T">+</a> a <br>, backarcs.g <a href="#+:set.T:T:set.T">+</a> barc.a <br>, nodes.g <a href="#+:set.T:T:set.T">+</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a</span>) <p> <a id="+:graph.T:seq.T:graph.T" href="#graph">Function</a> +(g:graph.T, a:seq.T) graph.T <br> <span class="keyword">for</span> acc = g, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> @e, <br>acc <p> <a id="deletenode:graph.T:&lt;&lt;.T:graph.T" href="#graph">Function</a> deletenode(g:graph.T, n:&lt;&lt;.T) graph.T <br> <a href="#deletearcs:graph.T:set.T:graph.T">deletearcs</a>( <span class="block">graph(arcs.g, backarcs.g, nodes.g <a href="#-:set.T:T:set.T">-</a> n) <br>, <a href="#arcstosuccessors:graph.T:&lt;&lt;.T:set.T">arcstosuccessors</a>(g, n) <br> <a href="#">∪</a> <a href="#asset:seq.T:set.T">asset</a>. <a href="#arcstopredecessors:graph.T:&lt;&lt;.T:seq.T">arcstopredecessors</a>(g, n)</span>) <p> <a id="sinks:graph.T:set.&lt;&lt;.T:seq.&lt;&lt;.T" href="#graph">Function</a> sinks(g:graph.T, b:set.&lt;&lt;.T) seq.&lt;&lt;.T <br> <span class="comment">{returns list of sinks in graph with arcs to nodes in set b removed}</span> <br> <span class="keyword">for</span> acc = empty:seq.&lt;&lt;.T, n ∈ toseq(nodes.g <a href="#\:set.T:set.T:set.T">\</a> b) <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>( <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, n) <a href="#\:set.T:set.T:set.T">\</a> b) <br> <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> acc <a href="#">+</a> n <br> <span class="keyword">else</span> acc,</span> acc <p> <a id="sources:graph.T:set.&lt;&lt;.T:seq.&lt;&lt;.T" href="#graph">Function</a> sources(g:graph.T, b:set.&lt;&lt;.T) seq.&lt;&lt;.T <br> <span class="comment">{returns list of sources in graph with arcs to nodes in set b removed}</span> <br> <span class="keyword">for</span> acc = empty:seq.&lt;&lt;.T, n ∈ toseq(nodes.g <a href="#\:set.T:set.T:set.T">\</a> b) <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>( <a href="#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">predecessors</a>(g, n) <a href="#\:set.T:set.T:set.T">\</a> b) <br> <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> acc <a href="#">+</a> n <br> <span class="keyword">else</span> acc,</span> acc <p> <a id="sources:graph.T:seq.&lt;&lt;.T" href="#graph">Function</a> sources(g:graph.T) seq.&lt;&lt;.T <br> <a href="#">sources</a>(g, <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>) <p> <a id="sinks:graph.T:seq.&lt;&lt;.T" href="#graph">Function</a> sinks(g:graph.T) seq.&lt;&lt;.T <br> <a href="#">sinks</a>(g, <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>) <p> <a id="subgraph:graph.T:set.&lt;&lt;.T:graph.T" href="#graph">Function</a> subgraph(g:graph.T, nodes:set.&lt;&lt;.T) graph.T <br> <span class="keyword">for</span> <span class="block">acc = graph( <span class="block"> <a href="#empty::set.T:set.T">empty:set.T</a> <br>, <a href="#empty::set.T:set.T">empty:set.barc.T</a> <br>, nodes</span>) <br>, e ∈ toseq.arcs.g</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e ∉ nodes <span class="keyword">then</span> acc <br> <span class="keyword">else</span> if <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.e ∉ nodes <span class="keyword">then</span> acc <br> <span class="keyword">else</span> acc <a href="#">+</a> e,</span> acc <p> <a id="reachable:graph.T:seq.&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> reachable(g:graph.T, a:seq.&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">let</span> d = <a href="#asset:seq.T:set.T">asset</a>.a, <br> <a href="#">reachable</a>(g, d, d, 1) <p> <a id="reachable:graph.T:set.&lt;&lt;.T:set.&lt;&lt;.T:int:set.&lt;&lt;.T" href="#graph">function</a> reachable(g:graph.T, old:set.&lt;&lt;.T, new:set.&lt;&lt;.T, count:int) set.&lt;&lt;.T <br> <span class="keyword">assert</span> count <a href="#&lt;:int:int:boolean">&lt;</a> 1000 <span class="keyword">report</span> <span class="block"> <span class="literal">"fal"</span> <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>. <a href="#n:set.T:int">n</a>.old <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>. <a href="#n:set.T:int">n</a>.new,</span> <span class="keyword">if</span> <a href="#isempty:set.T:boolean">isempty</a>.new <span class="keyword">then</span> old <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>, e ∈ toseq.new <br> <span class="keyword">do</span> acc <a href="#">∪</a> <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, e) <br> <span class="keyword">let</span> b = old <a href="#">∪</a> new, <br> <a href="#">reachable</a>(g, b, acc <a href="#\:set.T:set.T:set.T">\</a> b, count <a href="#+:int:int:int">+</a> 1)</span> <p> <a id="complement:graph.T:graph.T" href="#graph">Function</a> complement(g:graph.T) graph.T <br> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.T</a>, a ∈ toseq.arcs.g <br> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#">reverse</a>.a, <br>graph( <span class="block">acc <br>, <a href="#asset:seq.T:set.T">asset</a>. <a href="#tobarc:seq.T:seq.barc.T">tobarc</a>.toseq.acc <br>, nodes.g</span>) <p> <span class="keyword">unbound</span> reverse(T) T <p>------------------------------- <p> <a id="outdegree:graph.T:&lt;&lt;.T:int" href="#graph">Function</a> outdegree(g:graph.T, n:&lt;&lt;.T) int <a href="#n:set.T:int">n</a>. <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, n) <p> <a id="indegree:graph.T:&lt;&lt;.T:int" href="#graph">Function</a> indegree(g:graph.T, n:&lt;&lt;.T) int <a href="#n:set.T:int">n</a>. <a href="#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">predecessors</a>(g, n) <p> <a id="=:graph.T:graph.T:boolean" href="#graph">Function</a> =(a:graph.T, b:graph.T) boolean <br> <a href="#n:set.T:int">n</a>.arcs.a <a href="#=:int:int:boolean">=</a> <a href="#n:set.T:int">n</a>.arcs.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> nodes.a <a href="#=:set.T:set.T:boolean">=</a> nodes.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> arcs.a <a href="#=:set.T:set.T:boolean">=</a> arcs.b <p> <a id="transitiveClosure:graph.T:graph.T" href="#graph">Function</a> transitiveClosure(gin:graph.T) graph.T <br> <span class="comment">{add arcs to graph so if node is reachable, it can be reached with single arc}</span> <br> <span class="keyword">for</span> g = gin, n ∈ toseq.nodes.gin <br> <span class="keyword">do</span> <span class="block">{add arcs to graph so path does not need to go through n} <br> <span class="keyword">for</span> <span class="block">arcs = empty:seq.T <br>, p ∈ <a href="#arcstopredecessors:graph.T:&lt;&lt;.T:seq.T">arcstopredecessors</a>(g, n)</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc2 = empty:seq.T <br>, s ∈ toseq. <a href="#arcstosuccessors:graph.T:&lt;&lt;.T:set.T">arcstosuccessors</a>(g, n)</span> <span class="keyword">do</span> acc2 <a href="#">+</a> <a href="#">merge</a>(p, s), <br>arcs <a href="#">+</a> acc2,</span> g <a href="#">+</a> arcs,</span> g <p> <span class="keyword">unbound</span> merge(T, T) T <p> <span class="keyword" id="arc">Module</span> arc.T <p>use standard <p>use seq.seq.word <p>use set.T <p> <span class="keyword">Export</span> type:arc.T <p> <span class="keyword">Export</span> head(arc.T) T <p> <span class="keyword">Export</span> tail(arc.T) T <p> <span class="keyword">Export</span> arc(T, T) arc.T <p>type arc is tail:T, head:T <p> <a id="toarc:T:arc.T" href="#arc">Function</a> toarc(n:T) arc.T arc(n, n) <p> <a id="reverse:arc.T:arc.T" href="#arc">Function</a> reverse(a:arc.T) arc.T arc(head.a, tail.a) <p> <a id="merge:arc.T:arc.T:arc.T" href="#arc">Function</a> merge(p:arc.T, s:arc.T) arc.T arc(tail.p, head.s) <p> <a id="arcLabel:set.arc.T:T:T:seq.seq.word" href="#arc">Function</a> arcLabel(set.arc.T, T, T) seq.seq.word empty:seq.seq.word <p> <span class="keyword" id="process">Module</span> process.T <p>use seq.T <p>use UTF8 <p>use bits <p>use seq1.byte <p>use standard <p>use toWords <p> <span class="keyword">Export</span> type:process.T <p> <span class="keyword">Export</span> body2(process.T) T <p> <span class="keyword">Export</span> header(a:process.T) UTF8 <p>type process is abortedx:boolean, msg:seq.word, header:UTF8, body1:seq.T, body2:T <p> <span class="keyword">Builtin</span> aborted(process.T) boolean <p> <a id="message:process.T:seq.word" href="#process">Function</a> message(p:process.T) seq.word <br> <span class="keyword">if</span> aborted.p <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.msg.p <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> h = toseqbyte.header.p, <br> <a href="#towords:UTF8:seq.word">towords</a>.UTF8. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(h, 1, <a href="#findindex:seq.T:T:int">findindex</a>(h, <a href="#tobyte:int:byte">tobyte</a>.10))</span> <span class="keyword">else</span> msg.p</span> <span class="keyword">else</span> <span class="literal">"normal exit"</span> <p> <a id="result:process.T:T" href="#process">Function</a> result(p:process.T) T <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>.aborted.p <span class="keyword">report</span> <span class="literal">"no result of aborted process"</span>, <br>(body1.p) <a href="#sub:seq.T:int:T">sub</a> 1 <p> <span class="keyword" id="real">Module</span> real <p>use UTF8 <p>use bits <p>use seq1.byte <p>use seq1.char <p>use kernal <p>use standard <p> <a id="-:real:real" href="#real">Function</a> -(r:real) real 0.00 <a href="#">-</a> r <p> <a id="abs:real:real" href="#real">Function</a> abs(x:real) real <span class="keyword">if</span> x <a href="#&lt;:real:real:boolean">&lt;</a> 0.0 <span class="keyword">then</span> 0.0 <a href="#">-</a> x <span class="keyword">else</span> x <span class="keyword">Builtin</span> <p>toreal <span class="keyword">Builtin</span> <p>intpart <p> <a id="decpart:real:real" href="#real">Function</a> decpart(a:real) real a <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.a <span class="keyword">Builtin</span> <p>sin <span class="keyword">Builtin</span> <p>cos <span class="keyword">Builtin</span> <p>sqrt <span class="keyword">Builtin</span> <p>tan <span class="keyword">Builtin</span> <p>arccos <span class="keyword">Builtin</span> <p>arcsin <p> <a id="pi:real" href="#real">Function</a> pi real 3.1415926535898 <p> <a id="NaN:real" href="#real">Function</a> NaN real <br> <a href="#casttoreal:int:real">casttoreal</a>. <a href="#toint:word:int">toint</a>. <span class="literal">"0x7FF8000000000000"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">Builtin</span> <p>>1 <p> <a id="=:real:real:boolean" href="#real">Function</a> =(a:real, b:real) boolean a <a href="#>1:real:real:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <p> <a id=">:real:real:boolean" href="#real">Function</a> >(a:real, b:real) boolean a <a href="#>1:real:real:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <p> <a id="&lt;:real:real:boolean" href="#real">Function</a> &lt;(a:real, b:real) boolean b <a href="#>:real:real:boolean">></a> a <p> <a id="max:real:real:real" href="#real">Function</a> max(a:real, b:real) real <br> <span class="keyword">if</span> a <a href="#>1:real:real:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <span class="keyword">else</span> b <p> <a id="min:real:real:real" href="#real">Function</a> min(a:real, b:real) real <br> <span class="keyword">if</span> a <a href="#>1:real:real:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span> a <span class="keyword">else</span> b <span class="keyword">Builtin</span> <p>+ <span class="keyword">Builtin</span> <p>- <span class="keyword">Builtin</span> <p>* <span class="keyword">Builtin</span> <p>/ <span class="keyword">Builtin</span> <p>representation <span class="keyword">Builtin</span> <p>casttoreal <p> <a id="sup:real:int:real" href="#real">Function</a> sup(a:real, n:int) real <br> <span class="keyword">if</span> n <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> 1.0 <br> <span class="keyword">else</span> if n <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if n <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> 1.0 <a href="#/:real:real:real">/</a> a <a href="#sup:real:int:real">sup</a> -n <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> d = n <a href="#/:int:int:int">/</a> 2, <br>a <a href="#sup:real:int:real">sup</a> d <a href="#">*</a> a <a href="#sup:real:int:real">sup</a> (n <a href="#">-</a> d)</span> <p> <a id="*:int:real:real" href="#real">Function</a> *(a:int, b:real) real <a href="#toreal:int:real">toreal</a>.a <a href="#">*</a> b <p> <a id="makereal:seq.word:real" href="#real">Function</a> makereal(w:seq.word) real <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <span class="block"> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ w <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.@e, <br>acc <br>, -1 <br>, 1 <br>, 0 <br>, 1</span>) <p> <a id="isNaN:real:boolean" href="#real">function</a> isNaN(r:real) boolean <br> <a href="#representation:real:int">representation</a>.r <br> <a href="#=:int:int:boolean">=</a> <a href="#representation:real:int">representation</a>. <a href="#NaN:real">NaN</a> <p> <a id="%:int:real:seq.word" href="#real">Function</a> %(decimalPlaces:int, rin1:real) seq.word <br> <span class="comment">{converts rin1 to text form with specified number no decimal places.}</span> <br> <span class="keyword">if</span> <a href="#representation:real:int">representation</a>.rin1 <br> <a href="#=:int:int:boolean">=</a> <a href="#representation:real:int">representation</a>. <a href="#NaN:real">NaN</a> <span class="keyword">then</span> <span class="literal">"NaN"</span> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> neg = rin1 <a href="#>1:real:real:ordering">>1</a> <a href="#toreal:int:real">toreal</a>.0 <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">let</span> rin = <span class="keyword">if</span> neg <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.0 <a href="#">-</a> rin1 <span class="keyword">else</span> rin1 <br> <span class="keyword">let</span> a = 10 <a href="#sup:int:int:int">sup</a> decimalPlaces <br> <span class="keyword">let</span> r = rin <a href="#+:real:real:real">+</a> 1.0 <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>(a <a href="#*:int:int:int">*</a> 2), <br> <span class="keyword">let</span> r2 = <span class="block"> <span class="keyword">if</span> decimalPlaces <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block">[ <span class="block"> <a href="#toword:int:word">toword</a>. <a href="#">intpart</a>.r <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#encodeword:seq.char:word">encodeword</a>. <a href="#lpad:int:T:seq.T:seq.T">lpad</a>( <span class="block">decimalPlaces <br>, char.48 <br>, <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>. <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>( <span class="block">(r <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.r) <br> <a href="#">*</a> <a href="#toreal:int:real">toreal</a>.a</span>)</span>)</span>]</span> <span class="keyword">else</span> [ <a href="#toword:int:word">toword</a>. <a href="#">intpart</a>.r],</span> <span class="keyword">if</span> neg <span class="keyword">then</span> <span class="literal">"-:(r2)"</span> <span class="keyword">else</span> r2</span> <p> <a id="toUTF8:real:int:UTF8" href="#real">Function</a> toUTF8(rin1:real, decimals:int) UTF8 <br> <span class="keyword">let</span> neg = rin1 <a href="#>1:real:real:ordering">>1</a> <a href="#toreal:int:real">toreal</a>.0 <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">let</span> rin = <span class="keyword">if</span> neg <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.0 <a href="#">-</a> rin1 <span class="keyword">else</span> rin1 <br> <span class="keyword">let</span> a = 10 <a href="#sup:int:int:int">sup</a> decimals <br> <span class="keyword">let</span> r = rin <a href="#+:real:real:real">+</a> 1.0 <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>(a <a href="#*:int:int:int">*</a> 2) <br> <span class="keyword">let</span> r2 = <span class="block"> <span class="keyword">if</span> decimals <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>.r <br> <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>. <a href="#periodchar:char">periodchar</a> <br> <a href="#+:UTF8:UTF8:UTF8">+</a> UTF8. <a href="#lpad:int:T:seq.T:seq.T">lpad</a>( <span class="block">decimals <br>, <a href="#tobyte:int:byte">tobyte</a>.48 <br>, toseqbyte. <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>( <span class="block">(r <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.r) <br> <a href="#">*</a> <a href="#toreal:int:real">toreal</a>.a</span>)</span>)</span> <span class="keyword">else</span> <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>.r,</span> <span class="keyword">if</span> neg <a href="#∧:boolean:boolean:boolean">∧</a> rin1 ≠ 0.0 <span class="keyword">then</span> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>. <a href="#hyphenchar:char">hyphenchar</a> <a href="#+:UTF8:UTF8:UTF8">+</a> r2 <br> <span class="keyword">else</span> r2 <p> <a id="reallit:UTF8:real" href="#real">Function</a> reallit(s:UTF8) real <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>.s, -1, 1, 0, 1) <p> <a id="reallit:seq.char:int:int:int:int:real" href="#real">function</a> reallit(s:seq.char, decimals:int, i:int, val:int, neg:int) real <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> r = <span class="block"> <span class="keyword">if</span> decimals <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.val <br> <span class="keyword">else</span> <a href="#toreal:int:real">toreal</a>.val <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>.decimals,</span> <span class="keyword">if</span> neg <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> -1.0 <a href="#">*</a> r <span class="keyword">else</span> r</span> <span class="keyword">else</span> if <a href="#between:int:int:int:boolean">between</a>(toint.s <a href="#sub:seq.T:int:T">sub</a> i, 48, 57) <span class="keyword">then</span> <span class="block"> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <span class="block">s <br>, <span class="keyword">if</span> decimals <a href="#=:int:int:boolean">=</a> -1 <span class="keyword">then</span> -1 <span class="keyword">else</span> decimals <a href="#*:int:int:int">*</a> 10 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, 10 <a href="#*:int:int:int">*</a> val <a href="#+:int:int:int">+</a> toint.s <a href="#sub:seq.T:int:T">sub</a> i <a href="#">-</a> 48 <br>, neg</span>)</span> <span class="keyword">else</span> if s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> char.32 <br> <a href="#∨:boolean:boolean:boolean">∨</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#commachar:char">commachar</a> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, neg) <br> <span class="keyword">else</span> if i <a href="#&lt;:int:int:boolean">&lt;</a> 3 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#hyphenchar:char">hyphenchar</a> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, -1) <br> <span class="keyword">else</span> if i <a href="#&lt;:int:int:boolean">&lt;</a> 3 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"+"</span> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#periodchar:char">periodchar</a> <span class="keyword">report</span> <span class="literal">"unexpected character in real literal"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s, <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, 1, i <a href="#+:int:int:int">+</a> 1, val, neg)</span> <p> <span class="keyword" id="seq">Module</span> seq.T <p>use kernal <p> <span class="keyword">Export</span> type:pseq.T <p> <span class="keyword">Export</span> a(pseq.T) seq.T <p> <span class="keyword">Export</span> b(pseq.T) seq.T <p> <span class="keyword">Export</span> start(a:pseq.T) int <p> <span class="keyword">Export</span> type:seq.T <p> <span class="keyword">Export</span> to:pseq.T(s:seq.T) pseq.T <p> <span class="keyword">Export</span> getseqtype(a:seq.T) int <p> <span class="keyword">unbound</span> =(T, T) boolean <p>type seq is sequence, x:T <p> <span class="keyword">Builtin</span> packed(s:seq.T) seq.T <p> <span class="keyword">Builtin</span> empty:seq.T seq.T{empty seq} <p> <span class="keyword">Builtin</span> idxNB(a:seq.T, i:int) T <p> <a id="pseq2seq:pseq.T:seq.T" href="#seq">Function</a> pseq2seq(a:pseq.T) seq.T toseq.a <p> <a id="=:seq.T:seq.T:boolean" href="#seq">Function</a> =(a:seq.T, b:seq.T) boolean <br> <span class="comment">{OPTION COMPILETIME}</span> <br> <span class="keyword">for</span> isequal = n.a <a href="#=:int:int:boolean">=</a> n.b, i = 1, e ∈ a <br> <span class="keyword">while</span> isequal <br> <span class="keyword">do</span> next(e <a href="#">=</a> b <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#+:int:int:int">+</a> 1), <br>isequal <p> <a id="∈:T:seq.T:boolean" href="#seq">Function</a> ∈(a:T, s:seq.T) boolean <br> <span class="keyword">for</span> found = false, e ∈ s <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <span class="keyword">do</span> a <a href="#">=</a> e, <br>found <p> <a id="lookup:seq.T:T:seq.T" href="#seq">Function</a> lookup(s:seq.T, a:T) seq.T <br> <span class="keyword">for</span> found = empty:seq.T, e ∈ s <br> <span class="keyword">while</span> <a href="#isempty:seq.T:boolean">isempty</a>.found <br> <span class="keyword">do</span> <span class="keyword">if</span> a <a href="#">=</a> e <span class="keyword">then</span> found <a href="#">+</a> e <span class="keyword">else</span> found, <br>found <p>type pseq is sequence, a:seq.T, b:seq.T, start:int <p> <a id="seqseg:seq.T:int:pseq.T" href="#seq">Function</a> seqseg(sin:seq.T, ii:int) pseq.T <br> <span class="keyword">let</span> s = to:pseq.T(sin), <br> <span class="keyword">if</span> n.toseq.s <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> pseq(n.sin <a href="#+:int:int:int">+</a> 1, sin, empty:seq.T, ii <a href="#">-</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = ii <a href="#+:int:int:int">+</a> start.s <br> <span class="keyword">let</span> len = n.a.s, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> len <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> x = to:pseq.T(b.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block">pseq( <span class="block">n.b.s <a href="#">-</a> i <a href="#+:int:int:int">+</a> len <a href="#+:int:int:int">+</a> 1 <br>, b.s <br>, empty:seq.T <br>, i <a href="#">-</a> len <a href="#">-</a> 1</span>)</span> <span class="keyword">else</span> <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(b.s, i <a href="#">-</a> len)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> x = to:pseq.T(a.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> pseq(n.a.s <a href="#">-</a> i <a href="#+:int:int:int">+</a> 1, a.s, empty:seq.T, i <a href="#">-</a> 1) <br> <span class="keyword">else</span> <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(a.s, i)</span></span> <p> <a id="sequenceIndex:pseq.T:int:T" href="#seq">function</a> sequenceIndex(s:pseq.T, ii:int) T <br> <span class="keyword">let</span> i = ii <a href="#+:int:int:int">+</a> start.s <br> <span class="keyword">let</span> len = n.a.s, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> len <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> x = to:pseq.T(b.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> idxNB(b.s, i <a href="#">-</a> len) <span class="keyword">else</span> <a href="#sequenceIndex:pseq.T:int:T">sequenceIndex</a>(x, i <a href="#">-</a> len)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> x = to:pseq.T(a.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> idxNB(a.s, i) <span class="keyword">else</span> <a href="#sequenceIndex:pseq.T:int:T">sequenceIndex</a>(x, i)</span> <p> <a id="ispseq:seq.T:boolean" href="#seq">Function</a> ispseq(s:seq.T) boolean n.toseq.to:pseq.T(s) ≠ 0 <p> <a id="+:seq.T:seq.T:seq.T" href="#seq">Function</a> +(a:seq.T, b:seq.T) seq.T <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> la = n.a, <br> <span class="keyword">if</span> n.a <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> lb = n.b, <br> <span class="keyword">if</span> lb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <span class="keyword">else</span> <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(a, b)</span> <p> <a id="+:seq.T:T:seq.T" href="#seq">Function</a> +(l:seq.T, a:T) seq.T l <a href="#">+</a> [a] <p> <a id="cat3:int:seq.T:seq.T:seq.T:seq.T" href="#seq">function</a> cat3(totallength:int, a:seq.T, b:seq.T, c:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> toseq.pseq(totallength, a, <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(b, c), 0) <br> <span class="keyword">else</span> if n.b <a href="#&lt;:int:int:boolean">&lt;</a> n.c <span class="keyword">then</span> toseq.pseq(totallength, <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(a, b), c, 0) <br> <span class="keyword">else</span> <span class="block">toseq.pseq(totallength, toseq.pseq(n.a <a href="#+:int:int:int">+</a> n.b, a, b, 0), c, 0)</span> <p> <a id="catnonzero:seq.T:seq.T:seq.T" href="#seq">function</a> catnonzero(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> totallength = n.a <a href="#+:int:int:int">+</a> n.b, <br> <span class="keyword">if</span> totallength <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> [idxNB(a, 1), idxNB(b, 1)] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ta = to:pseq.T(a), <br> <span class="keyword">if</span> n.toseq.ta <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> tb = to:pseq.T(b), <br> <span class="keyword">if</span> n.toseq.tb <a href="#=:int:int:boolean">=</a> 0 <br> <a href="#∨:boolean:boolean:boolean">∨</a> n.a.tb <a href="#+:int:int:int">+</a> n.b.tb ≠ n.toseq.tb <span class="keyword">then</span> toseq.pseq(totallength, a, b, 0) <br> <span class="keyword">else</span> <a href="#cat3:int:seq.T:seq.T:seq.T:seq.T">cat3</a>(totallength, a, a.tb, b.tb)</span> <span class="keyword">else</span> if n.a.ta <a href="#+:int:int:int">+</a> n.b.ta ≠ n.toseq.ta <span class="keyword">then</span> toseq.pseq(totallength, a, b, 0) <br> <span class="keyword">else</span> <a href="#cat3:int:seq.T:seq.T:seq.T:seq.T">cat3</a>(totallength, a.ta, b.ta, b)</span> <p> <a id="subseq:seq.T:int:int:seq.T" href="#seq">Function</a> subseq(s:seq.T, start:int, finish:int) seq.T <br> <span class="keyword">if</span> start <a href="#>:int:int:boolean">></a> finish <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if start <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, finish) <br> <span class="keyword">else</span> if finish <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, start, n.s) <br> <span class="keyword">else</span> if start <a href="#=:int:int:boolean">=</a> 1 <a href="#∧:boolean:boolean:boolean">∧</a> n.s <a href="#=:int:int:boolean">=</a> finish <span class="keyword">then</span> s <br> <span class="keyword">else</span> if start <a href="#=:int:int:boolean">=</a> finish <a href="#+:int:int:int">+</a> 1 <span class="keyword">then</span> [s <a href="#sub:seq.T:int:T">sub</a> start, s <a href="#sub:seq.T:int:T">sub</a> finish] <br> <span class="keyword">else</span> if start <a href="#+:int:int:int">+</a> 1 ≥ finish <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> start <a href="#=:int:int:boolean">=</a> finish <span class="keyword">then</span> [s <a href="#sub:seq.T:int:T">sub</a> start] <br> <span class="keyword">else</span> [s <a href="#sub:seq.T:int:T">sub</a> start, s <a href="#sub:seq.T:int:T">sub</a> finish]</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = to:pseq.T(s), <br> <span class="keyword">if</span> n.toseq.p <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block">toseq.pseq(finish <a href="#">-</a> start <a href="#+:int:int:int">+</a> 1, s, s, start <a href="#">-</a> 1)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> adjstart = start <a href="#+:int:int:int">+</a> start.p <a href="#">-</a> n.a.p <br> <span class="keyword">let</span> adjfinish = start.p <a href="#+:int:int:int">+</a> finish <a href="#">-</a> n.a.p, <br> <span class="keyword">if</span> adjstart <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span>{all in part b} <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b.p, adjstart, adjfinish) <br> <span class="keyword">else</span> if adjfinish <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a.p, start.p <a href="#+:int:int:int">+</a> start, n.a.p) <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b.p, 1, adjfinish)</span> <span class="keyword">else</span> {all in part a} <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a.p, start.p <a href="#+:int:int:int">+</a> start, start.p <a href="#+:int:int:int">+</a> finish)</span></span> <p> <a id="isempty:seq.T:boolean" href="#seq">Function</a> isempty(a:seq.T) boolean n.a <a href="#=:int:int:boolean">=</a> 0 <p> <a id="&lt;&lt;:seq.T:int:seq.T" href="#seq">Function</a> &lt;&lt;(s:seq.T, i:int) seq.T <br> <span class="comment">{* removes i elements from beginning of s}</span> <br> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s) <p> <a id=">>:seq.T:int:seq.T" href="#seq">Function</a> >>(s:seq.T, i:int) seq.T <br> <span class="comment">{* removes i elements from end of s}</span> <br> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, n.s <a href="#">-</a> i) <p> <span class="keyword">Builtin</span> n(s:seq.T) int{length of string} <p> <a id="sub:seq.T:int:T" href="#seq">Function</a> sub(s:seq.T, i:int) T <br> <span class="comment">{Number elements in sequence from 1 to n.s and return the element numbered i}</span> <br> <span class="keyword">assert</span> i <a href="#>:int:int:boolean">></a> 0 <a href="#∧:boolean:boolean:boolean">∧</a> i ≤ n.s <br> <a href="#∨:boolean:boolean:boolean">∨</a> getseqtype.s <a href="#>:int:int:boolean">></a> 1 <span class="keyword">report</span> outofbounds:T, <br>idxNB(s, i) <p> <span class="keyword">builtin</span> outofbounds:T seq.word <p> <a id="last:seq.T:T" href="#seq">Function</a> last(s:seq.T) T <br> <span class="comment">{last element of sequence}</span> <br>s <a href="#sub:seq.T:int:T">sub</a> n.s <p> <span class="keyword" id="set">Module</span> set.T <p>use seq1.T <p>use standard <p>use sort.T <p> <span class="keyword">Export</span> type:set.T <p> <span class="keyword">Export</span> toseq(set.T) seq.T <p> <span class="keyword">Export</span> sub(seq.T, int) T <p> <span class="keyword">Export</span> +(seq.T, T) seq.T{From seq.T} <p> <span class="keyword">Export</span> +(seq.T, seq.T) seq.T{From seq.T} <p> <span class="keyword">Export</span> empty:seq.T seq.T{From seq.T} <p>type set is toseq:seq.T <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="asset:seq.T:set.T" href="#set">Function</a> asset(s:seq.T) set.T <br> <span class="keyword">for</span> acc = empty:seq.T, @e ∈ s <span class="keyword">do</span> <a href="#setinsert:seq.T:T:seq.T">setinsert</a>(acc, @e), <br>set.acc <p> <a id="empty::set.T:set.T" href="#set">Function</a> empty:set.T set.T set.empty:seq.T <p> <a id="+:set.T:T:set.T" href="#set">Function</a> +(s:set.T, val:T) set.T set. <a href="#setinsert:seq.T:T:seq.T">setinsert</a>(toseq.s, val) <p> <a id="replace:set.T:T:set.T" href="#set">Function</a> replace(s:set.T, val:T) set.T set. <a href="#setreplaceorinsert:seq.T:T:seq.T">setreplaceorinsert</a>(toseq.s, val) <p> <a id="∪:T:set.T:set.T" href="#set">Function</a> ∪(val:T, s:set.T) set.T set. <a href="#setreplaceorinsert:seq.T:T:seq.T">setreplaceorinsert</a>(toseq.s, val) <p> <a id="sub:set.T:int:T" href="#set">Function</a> sub(s:set.T, i:int) T (toseq.s) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="lookup:set.T:T:set.T" href="#set">Function</a> lookup(s:set.T, val:T) set.T <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(toseq.s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> set.[(toseq.s) <a href="#sub:seq.T:int:T">sub</a> i] <br> <span class="keyword">else</span> <a href="#empty::set.T:set.T">empty:set.T</a> <p> <a id="∩:set.T:set.T:set.T" href="#set">Function</a> ∩(a:set.T, b:set.T) set.T set. <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(toseq.a, toseq.b, 1, 1) <p> <a id="intersect:seq.T:seq.T:int:int:seq.T" href="#set">function</a> intersect(a:seq.T, b:seq.T, i:int, j:int) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span>[a <a href="#sub:seq.T:int:T">sub</a> i] <a href="#">+</a> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j)</span> <p> <a id="union:set.T:set.T:set.T" href="#set">function</a> union(a:set.T, b:set.T) set.T <br> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <a href="#+:set.T:T:set.T">+</a> b <a href="#sub:set.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> set. <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="∪:set.T:set.T:set.T" href="#set">Function</a> ∪(a:set.T, b:set.T) set.T <br> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <a href="#+:set.T:T:set.T">+</a> b <a href="#sub:set.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> set. <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="union:seq.T:seq.T:int:int:seq.T:seq.T" href="#set">function</a> union(a:seq.T, b:seq.T, i:int, j:int, result:seq.T) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, n.b) <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> b <a href="#sub:seq.T:int:T">sub</a> j) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> a <a href="#sub:seq.T:int:T">sub</a> i) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = <a href="#">binarysearch</a>(a, i <a href="#+:int:int:int">+</a> 1, n.a, b <a href="#sub:seq.T:int:T">sub</a> j), <br> <span class="keyword">if</span> p <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, p <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, p)) <br> <span class="keyword">else</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, -p, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, -p <a href="#">-</a> 1) <a href="#">+</a> [b <a href="#sub:seq.T:int:T">sub</a> j])</span> <p> <a id="\:set.T:set.T:set.T" href="#set">Function</a> \(a:set.T, b:set.T) set.T <br> <span class="comment">{elements in a but not in b}</span> <br>set. <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(toseq.a, toseq.b, 1, 1) <p> <a id="-:set.T:T:set.T" href="#set">Function</a> -(a:set.T, b:T) set.T set. <a href="#setdelete:seq.T:T:seq.T">setdelete</a>(toseq.a, b) <p> <a id="diff:seq.T:seq.T:int:int:seq.T" href="#set">function</a> diff(a:seq.T, b:seq.T, i:int, j:int) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span>[a <a href="#sub:seq.T:int:T">sub</a> i] <a href="#">+</a> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j) <br> <span class="keyword">else</span> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1) <p> <a id="replace:set.T:set.T:set.T" href="#set">Function</a> replace(a:set.T, b:set.T) set.T <br>set. <a href="#">replace</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="replace:seq.T:seq.T:int:int:seq.T:seq.T" href="#set">function</a> replace(a:seq.T, b:seq.T, i:int, j:int, result:seq.T) seq.T <br> <span class="comment">{if in a and b then b else a}</span> <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ai = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="keyword">let</span> c = ai <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#">replace</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> [b <a href="#sub:seq.T:int:T">sub</a> j]) <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span> <a href="#">replace</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j, result <a href="#">+</a> ai) <br> <span class="keyword">else</span> <a href="#">replace</a>(a, b, i, <a href="#skipahead:seq.T:int:int:T:int">skipahead</a>(b, j, 1, ai), result)</span> <p> <a id="skipahead:seq.T:int:int:T:int" href="#set">function</a> skipahead(b:seq.T, j:int, k:int, ai:T) int <br> <span class="keyword">if</span> j <a href="#+:int:int:int">+</a> k <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> j <a href="#+:int:int:int">+</a> k <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1 <br> <span class="keyword">else</span> if ai <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> (j <a href="#+:int:int:int">+</a> k) <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#skipahead:seq.T:int:int:T:int">skipahead</a>(b, j, k <a href="#+:int:int:int">+</a> k, ai) <br> <span class="keyword">else</span> j <a href="#+:int:int:int">+</a> k <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1 <p> <a id="isempty:set.T:boolean" href="#set">Function</a> isempty(a:set.T) boolean n.toseq.a <a href="#=:int:int:boolean">=</a> 0 <p> <a id="∈:T:set.T:boolean" href="#set">Function</a> ∈(val:T, a:set.T) boolean <a href="#">binarysearch</a>(toseq.a, val) <a href="#>:int:int:boolean">></a> 0 <p> <a id="findindex:set.T:T:int" href="#set">Function</a> findindex(a:set.T, val:T) int <a href="#">binarysearch</a>(toseq.a, val) <p> <a id="cardinality:set.T:int" href="#set">Function</a> cardinality(a:set.T) int n.toseq.a <p> <a id="n:set.T:int" href="#set">Function</a> n(a:set.T) int <br> <span class="comment">{set cardinality}</span> <br>n.toseq.a <p> <a id="=:set.T:set.T:boolean" href="#set">Function</a> =(a:set.T, b:set.T) boolean <br> <a href="#n:set.T:int">n</a>.a <a href="#=:int:int:boolean">=</a> <a href="#n:set.T:int">n</a>.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> toseq.a <a href="#">=</a> toseq.b <p> <a id="subseq:set.T:int:int:set.T" href="#set">Function</a> subseq(a:set.T, from:int, to:int) set.T set. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.a, from, to) <p>------------------------------- <p>Secondary ordering that allows a secondary search on a partial key. <p>The following must be true(a >2 b)≠ EQ implies >1(a, b)=(a >2 b) <p> <span class="keyword">unbound</span> >2(T, T) ordering <p> <a id="findelement2:set.T:T:set.T" href="#set">Function</a> findelement2(a:set.T, n:T) set.T <br> <span class="keyword">let</span> i = <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(toseq.a, 1, n.toseq.a, n), <br> <a href="#asset:seq.T:set.T">asset</a>( <span class="block"> <span class="keyword">if</span> i <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc = empty:seq.T <br>, @e ∈ <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.a, <a href="#expandrangedown:seq.T:T:int:int">expandrangedown</a>(toseq.a, n, i), <a href="#expandrangeup:seq.T:T:int:int">expandrangeup</a>(toseq.a, n, i))</span> <span class="keyword">do</span> acc <a href="#">+</a> @e, <br>acc</span></span>) <p> <a id="expandrangedown:seq.T:T:int:int" href="#set">function</a> expandrangedown(a:seq.T, n:T, l:int) int <br> <span class="keyword">if</span> l <a href="#>:int:int:boolean">></a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> (l <a href="#">-</a> 1) <br> <a href="#">>2</a> n <br> <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#expandrangedown:seq.T:T:int:int">expandrangedown</a>(a, n, l <a href="#">-</a> 1) <br> <span class="keyword">else</span> l</span> <span class="keyword">else</span> l <p> <a id="expandrangeup:seq.T:T:int:int" href="#set">function</a> expandrangeup(a:seq.T, n:T, u:int) int <br> <span class="keyword">if</span> u <a href="#&lt;:int:int:boolean">&lt;</a> n.a <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> (u <a href="#+:int:int:int">+</a> 1) <br> <a href="#">>2</a> n <br> <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#expandrangeup:seq.T:T:int:int">expandrangeup</a>(a, n, u <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> u</span> <span class="keyword">else</span> u <p> <span class="keyword" id="sparseseq">Module</span> sparseseq.T <p>* lets a sequence have a default value even beyond the length of the seq. <p>use seq.T <p>use seq1.sparseele.T <p>use standard <p>type sparseele is start:int, edata:seq.T <p>type sparse is sequence, sdata:seq.sparseele.T, default:T <p> <a id=">1:sparseele.T:sparseele.T:ordering" href="#sparseseq">Function</a> >1(a:sparseele.T, b:sparseele.T) ordering start.a <a href="#>1:int:int:ordering">>1</a> start.b <p> <a id="sequenceIndex:sparse.T:int:T" href="#sparseseq">function</a> sequenceIndex(s:sparse.T, i:int) T <br> <span class="keyword">let</span> place = <a href="#">binarysearch</a>(sdata.s, sparseele(i, empty:seq.T)), <br> <span class="keyword">if</span> place <a href="#=:int:int:boolean">=</a> -1 <span class="keyword">then</span> default.s <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> k = <span class="keyword">if</span> place <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> -place <a href="#">-</a> 1 <span class="keyword">else</span> place <br> <span class="keyword">let</span> before = (sdata.s) <a href="#sub:seq.T:int:T">sub</a> k, <br> <span class="keyword">let</span> beforeindex = i <a href="#">-</a> start.before <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> beforeindex <a href="#>:int:int:boolean">></a> n.edata.before <span class="keyword">then</span> default.s <span class="keyword">else</span> (edata.before) <a href="#sub:seq.T:int:T">sub</a> beforeindex</span> <p> <a id="sparseseq:T:seq.T" href="#sparseseq">Function</a> sparseseq(a:T) seq.T toseq.sparse(1, empty:seq.sparseele.T, a) <p> <a id="replaceS:seq.T:int:seq.T:seq.T" href="#sparseseq">Function</a> replaceS(a:seq.T, i:int, b:seq.T) seq.T <br> <span class="keyword">let</span> d = to:sparse.T(a), <br> <span class="keyword">if</span> n.toseq.d <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> b <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i <a href="#+:int:int:int">+</a> n.b, n.a)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ele = sparseele(i, b) <br> <span class="keyword">let</span> place = <a href="#">binarysearch</a>(sdata.d, ele) <br> <span class="keyword">let</span> t = <span class="block"> <span class="keyword">if</span> place <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, 1, place <a href="#">-</a> 1) <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> ele <br> <a href="#">+</a> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>( <span class="block">i <a href="#+:int:int:int">+</a> n.b <a href="#">-</a> 1 <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, place <a href="#+:int:int:int">+</a> 1, n.sdata.d) <br>, 1</span>)</span> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, 1, -place <a href="#">-</a> 1) <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> ele <br> <a href="#">+</a> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>( <span class="block">i <a href="#+:int:int:int">+</a> n.b <a href="#">-</a> 1 <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, -place, n.sdata.d) <br>, 1</span>),</span></span> <span class="keyword">let</span> last = t <a href="#sub:seq.T:int:T">sub</a> n.t, <br>toseq.sparse(start.last <a href="#+:int:int:int">+</a> n.edata.last <a href="#">-</a> 1, t, default.d)</span> <p> <a id="removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T" href="#sparseseq">function</a> removeoverlap(finish:int, s:seq.sparseele.T, i:int) seq.sparseele.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> empty:seq.sparseele.T <br> <span class="keyword">else</span> if finish <a href="#&lt;:int:int:boolean">&lt;</a> start.s <a href="#sub:seq.T:int:T">sub</a> i <span class="keyword">then</span> s <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> (i <a href="#">-</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> this = s <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="keyword">let</span> thisfinish = start.this <a href="#+:int:int:int">+</a> n.edata.this <a href="#">-</a> 1, <br> <span class="keyword">if</span> finish ≥ thisfinish <span class="keyword">then</span> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>(finish, s, i <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block">[sparseele(finish <a href="#+:int:int:int">+</a> 1, edata.this <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> (finish <a href="#">-</a> start.this))] <br> <a href="#">+</a> s <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i</span></span> <p> <a id="*:seq.sparseele.T:sparseele.T:seq.sparseele.T" href="#sparseseq">function</a> *(a:seq.sparseele.T, e:sparseele.T) seq.sparseele.T <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <span class="keyword">then</span> [e] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> last = a <a href="#sub:seq.T:int:T">sub</a> n.a <br> <span class="keyword">let</span> lastend = start.last <a href="#+:int:int:int">+</a> n.edata.last <a href="#">-</a> 1, <br> <span class="keyword">if</span> lastend <a href="#&lt;:int:int:boolean">&lt;</a> start.e <span class="keyword">then</span> a <a href="#">+</a> e <br> <span class="keyword">else</span> <span class="block">a <br> <a href="#>>:seq.T:int:seq.T">>></a> 1 <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> sparseele( <span class="block">start.last <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(edata.last, 1, start.e <a href="#">-</a> start.last) <br> <a href="#">+</a> edata.e</span>)</span></span> <p> <span class="keyword" id="stack">Module</span> stack.T <p>use seq.T <p>use standard <p> <span class="keyword">Export</span> type:stack.T <p> <span class="keyword">Export</span> toseq(stack.T) seq.T <p>type stack is toseq:seq.T <p> <a id="top:stack.T:int:seq.T" href="#stack">Function</a> top(f:stack.T, n:int) seq.T <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, n.toseq.f <a href="#">-</a> n <a href="#+:int:int:int">+</a> 1, n.toseq.f) <p> <a id="top:stack.T:T" href="#stack">Function</a> top(f:stack.T) T (toseq.f) <a href="#sub:seq.T:int:T">sub</a> n.toseq.f <p> <a id="push:stack.T:T:stack.T" href="#stack">Function</a> push(f:stack.T, t:T) stack.T stack(toseq.f <a href="#">+</a> t) <p> <a id="pop:stack.T:int:stack.T" href="#stack">Function</a> pop(f:stack.T, n:int) stack.T <br> <span class="keyword">assert</span> n.toseq.f ≥ n <span class="keyword">report</span> <span class="literal">"stack underflow:(stacktrace)"</span>, <br>stack. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, 1, n.toseq.f <a href="#">-</a> n) <p> <a id="pop:stack.T:stack.T" href="#stack">Function</a> pop(f:stack.T) stack.T <br> <span class="keyword">assert</span> n.toseq.f <a href="#>:int:int:boolean">></a> 0 <span class="keyword">report</span> <span class="literal">"stack underflow:(stacktrace)"</span>, <br>stack. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, 1, n.toseq.f <a href="#">-</a> 1) <p> <a id="empty::stack.T:stack.T" href="#stack">Function</a> empty:stack.T stack.T stack.empty:seq.T <p> <a id="isempty:stack.T:boolean" href="#stack">Function</a> isempty(f:stack.T) boolean n.toseq.f <a href="#=:int:int:boolean">=</a> 0 <p> <a id="undertop:stack.T:int:T" href="#stack">Function</a> undertop(f:stack.T, n:int) T (toseq.f) <a href="#sub:seq.T:int:T">sub</a> (n.toseq.f <a href="#">-</a> n) <p> <span class="keyword" id="standard">Module</span> standard <p>use bits <p>use seq1.char <p>use seq.char <p>use sort.char <p>use seq1.int <p>use kernal <p>use word <p>use seq1.word <p>use seq.seq.word <p> <span class="keyword">Export</span> char1(s:seq.word) char <p> <span class="keyword">Export</span> type:boolean <p> <span class="keyword">Export</span> type:char <p> <span class="keyword">Export</span> toint(char) int <p> <span class="keyword">Export</span> char(int) char <p> <span class="keyword">Export</span> type:ordering <p> <span class="keyword">Export</span> toword(n:int) word{Covert integer to a single word.}{From UTF8} <p> <span class="keyword">Export</span> toint(w:word) int{Convert an integer represented as a word to an int}{From UTF8} <p> <span class="keyword">Export</span> not(a:boolean) boolean{From internal} <p> <span class="keyword">Export</span> =(a:boolean, b:boolean) boolean{From internal} <p> <span class="keyword">Export</span> false boolean{From internal} <p> <span class="keyword">Export</span> true boolean{From internal} <p> <span class="keyword">Export</span> arithseq(int, int, int) seq.int{From seq1.int} <p> <span class="keyword">Export</span> constantseq(len:int, element:int) seq.int{From seq1.int} <p> <span class="keyword">Export</span> findindex(seq.word, word) int{From seq1.word} <p> <span class="keyword">Export</span> type:seq.char{From seq.char} <p> <span class="keyword">Export</span> isempty(seq.char) boolean{From seq.char} <p> <span class="keyword">Export</span> n(seq.char) int{From seq.char} <p> <span class="keyword">Export</span> sub(seq.char, int) char{From seq.char} <p> <span class="keyword">Export</span> +(seq.char, char) seq.char{From seq.char} <p> <span class="keyword">Export</span> +(seq.char, seq.char) seq.char{From seq.char} <p> <span class="keyword">Export</span> =(seq.char, seq.char) boolean{From seq.char} <p> <span class="keyword">Export</span> empty:seq.char seq.char{From seq.char} <p> <span class="keyword">Export</span> subseq(seq.char, int, int) seq.char{From seq.char} <p> <span class="keyword">Export</span> type:seq.int{From seq.int} <p> <span class="keyword">Export</span> isempty(seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> n(seq.int) int{From seq.int} <p> <span class="keyword">Export</span> sub(seq.int, int) int{From seq.int} <p> <span class="keyword">Export</span> +(seq.int, int) seq.int{From seq.int} <p> <span class="keyword">Export</span> +(seq.int, seq.int) seq.int{From seq.int} <p> <span class="keyword">Export</span> =(seq.int, seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> empty:seq.int seq.int{From seq.int} <p> <span class="keyword">Export</span> subseq(seq.int, int, int) seq.int{From seq.int} <p> <span class="keyword">Export</span> ∈(int, seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> type:seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> n(seq.seq.word) int{From seq.seq.word} <p> <span class="keyword">Export</span> sub(seq.seq.word, int) seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> +(seq.seq.word, seq.seq.word) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> +(seq.seq.word, seq.word) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> empty:seq.seq.word seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> subseq(seq.seq.word, int, int) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> ∈(seq.word, seq.seq.word) boolean{From seq.seq.word} <p> <span class="keyword">Export</span> type:seq.word{From seq.word} <p> <span class="keyword">Export</span> isempty(seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> n(seq.word) int{From seq.word} <p> <span class="keyword">Export</span> sub(seq.word, int) word{From seq.word} <p> <span class="keyword">Export</span> +(a:seq.word, b:seq.word) seq.word{OPTION COMPILETIME}{From seq.word} <p> <span class="keyword">Export</span> +(seq.word, word) seq.word{From seq.word} <p> <span class="keyword">Export</span> &lt;&lt;(s:seq.word, i:int) seq.word <br>{* removes i words from beginning of s From seq.word}{From seq.word} <p> <span class="keyword">Export</span> =(seq.word, seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> >>(s:seq.word, i:int) seq.word{* removes i words from end of s}{From seq.word} <p> <span class="keyword">Export</span> last(seq.word) word <p> <span class="keyword">Export</span> empty:seq.word seq.word{From seq.word} <p> <span class="keyword">Export</span> subseq(seq.word, int, int) seq.word{From seq.word} <p> <span class="keyword">Export</span> ∈(word, seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> encodeword(a:seq.char) word{From word} <p> <span class="keyword">Export</span> merge(a:seq.word) word{make multiple word into a single word.}{From word} <p> <span class="keyword">Export</span> type:word{From word} <p> <span class="keyword">Export</span> decodeword(w:word) seq.char{From word} <p> <span class="keyword">Export</span> hash(a:word) int{From word} <p> <span class="keyword">Export</span> =(a:word, b:word) boolean{From word} <p> <span class="keyword">Export</span> >1(a:word, b:word) ordering{From word} <p> <span class="keyword">Export</span> stacktrace seq.word <p> <a id="dq:seq.word" href="#standard">Function</a> dq seq.word <br> <span class="comment">{doublequote}</span> <br>[ <a href="#encodeword:seq.char:word">encodeword</a>.[char.34]] <p> <a id="dq:seq.word:seq.word" href="#standard">Function</a> dq(s:seq.word) seq.word <a href="#">dq</a> <a href="#">+</a> s <a href="#">+</a> <a href="#">dq</a> <p> <span class="keyword">Export</span> >1(char, char) ordering <p> <span class="keyword">Export</span> =(char, char) boolean <p> <span class="keyword">Export</span> EQ ordering <p> <span class="keyword">Export</span> GT ordering <p> <span class="keyword">Export</span> LT ordering <p> <span class="keyword">Export</span> =(ordering, ordering) boolean <p> <a id="∧:ordering:ordering:ordering" href="#standard">Function</a> ∧(a:ordering, b:ordering) ordering <br> <span class="keyword">if</span> a <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> b <span class="keyword">else</span> a <p> <a id=">1:boolean:boolean:ordering" href="#standard">Function</a> >1(a:boolean, b:boolean) ordering <br> <span class="keyword">if</span> a <span class="keyword">then</span> <span class="keyword">if</span> b <span class="keyword">then</span> {T T} <a href="#EQ:ordering">EQ</a> <span class="keyword">else</span> {T F} <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if b <span class="keyword">then</span> {F T} <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> {F F} <a href="#EQ:ordering">EQ</a> <p> <span class="keyword">Export</span> ∧(a:boolean, b:boolean) boolean <p> <span class="keyword">Export</span> ∨(a:boolean, b:boolean) boolean <p>------------------------------- <p> <span class="keyword">Export</span> -(i:int) int <p> <span class="keyword">Export</span> >1(a:int, b:int) ordering <p> <span class="keyword">Export</span> +(a:int, b:int) int <p> <span class="keyword">Export</span> -(a:int, b:int) int <p> <span class="keyword">Export</span> *(a:int, b:int) int <p> <span class="keyword">Export</span> /(a:int, b:int) int <p> <span class="keyword">Export</span> =(a:int, b:int) boolean <p>-------------------- <p> <span class="keyword">Export</span> abs(x:int) int <p> <span class="keyword">Export</span> mod(x:int, y:int) int <p> <span class="keyword">Export</span> >(a:int, b:int) boolean <p> <span class="keyword">Export</span> &lt;(a:int, b:int) boolean <p> <span class="keyword">Export</span> between(i:int, lower:int, upper:int) boolean <p> <span class="keyword">Export</span> sup(i:int, n:int) int <p> <span class="keyword">Export</span> max(a:int, b:int) int <p> <span class="keyword">Export</span> min(a:int, b:int) int <p>------------------------------- <p> <span class="keyword">Export</span> hash(a:seq.int) int <p> <span class="keyword">Export</span> hash(a:seq.word) int <p> <a id="randomseq:int:int:seq.int" href="#standard">Function</a> randomseq(seed:int, length:int) seq.int <br> <span class="comment">{Xorshift* see Wikapedia entry on Xorshift}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, state = bits.seed <br> <span class="keyword">while</span> n.acc <a href="#&lt;:int:int:boolean">&lt;</a> length <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> x1 = state <a href="#⊻:bits:bits:bits">⊻</a> state <a href="#>>:bits:int:bits">>></a> 12 <br> <span class="keyword">let</span> x2 = x1 <a href="#⊻:bits:bits:bits">⊻</a> x1 <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 25, <br> <span class="keyword">let</span> nextrandom = x2 <a href="#⊻:bits:bits:bits">⊻</a> x2 <a href="#>>:bits:int:bits">>></a> 27, <br>next( <span class="block">acc <a href="#">+</a> toint.state <a href="#*:int:int:int">*</a> toint.0x2545F4914F6CDD1D <br>, nextrandom</span>)</span> <span class="comment">{???? omitting acc gives strange error message}</span> <br>acc <p> <a id="break:seq.word:seq.word:boolean:seq.seq.word" href="#standard">Function</a> break(s:seq.word, seperators:seq.word, includeseperator:boolean) seq.seq.word <br> <span class="keyword">let</span> nosep = <span class="keyword">if</span> includeseperator <span class="keyword">then</span> 0 <span class="keyword">else</span> 1 <br> <span class="keyword">for</span> l = empty:seq.int, j = 1, e ∈ s <br> <span class="keyword">do</span> next(l <a href="#">+</a> ( <span class="keyword">if</span> e <a href="#">∈</a> seperators <span class="keyword">then</span> [j] <span class="keyword">else</span> empty:seq.int), j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.seq.word <br>, i = 1 <br>, ele ∈ l <a href="#">+</a> (n.s <a href="#+:int:int:int">+</a> 1)</span> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">s <br>, <span class="keyword">if</span> i <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> 1 <br> <span class="keyword">else</span> l <a href="#sub:seq.T:int:T">sub</a> (i <a href="#">-</a> 1) <a href="#+:int:int:int">+</a> nosep <br>, ele <a href="#">-</a> 1</span>) <br>, i <a href="#+:int:int:int">+</a> 1</span>),</span> acc <p> <a id="extractValue:seq.word:seq.word:seq.word" href="#standard">Function</a> extractValue(s:seq.word, name:seq.word) seq.word <br> <span class="keyword">for</span> <span class="block">value = <span class="literal">""</span> <br>, invalue = false <br>, last = <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, found = false <br>, w ∈ s</span> <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> invalue <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">": :"</span> <span class="keyword">then</span> next(value <a href="#>>:seq.T:int:seq.T">>></a> 1, invalue, w, true) <br> <span class="keyword">else</span> next(value <a href="#">+</a> w, invalue, w, false)</span> <span class="keyword">else</span> if w <a href="#">∈</a> <span class="literal">": :"</span> <a href="#∧:boolean:boolean:boolean">∧</a> last <a href="#">∈</a> name <span class="keyword">then</span> next(value, true, w, false) <br> <span class="keyword">else</span> next(value, false, w, false),</span> value <p> <a id="extractFlag:seq.word:seq.word:boolean" href="#standard">Function</a> extractFlag(s:seq.word, name:seq.word) boolean <br> <span class="keyword">for</span> <span class="block">value = <span class="literal">""</span> <br>, invalue = false <br>, last = <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, found = false <br>, w ∈ s</span> <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> invalue <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">": :"</span> <span class="keyword">then</span> next(value <a href="#>>:seq.T:int:seq.T">>></a> 1, invalue, w, true) <br> <span class="keyword">else</span> next(value <a href="#">+</a> w, invalue, w, false)</span> <span class="keyword">else</span> if w <a href="#">∈</a> <span class="literal">": :"</span> <a href="#∧:boolean:boolean:boolean">∧</a> last <a href="#">∈</a> name <span class="keyword">then</span> next(value, true, w, false) <br> <span class="keyword">else</span> next(value, false, w, false),</span> found <a href="#∧:boolean:boolean:boolean">∧</a> value ≠ <span class="literal">"false"</span> <p> <a id="hexdigit:bits:char" href="#standard">function</a> hexdigit(b:bits) char <br> <span class="keyword">let</span> k = <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"0123456789ABCDEF"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">assert</span> n.k <a href="#=:int:int:boolean">=</a> 16 <span class="keyword">report</span> <span class="literal">"XXX:(n.k)"</span>, <br>k <a href="#sub:seq.T:int:T">sub</a> (1 <a href="#+:int:int:int">+</a> toint(b <a href="#∧:bits:bits:bits">∧</a> 0x0F)) <p> <a id="hexword:bits:word" href="#standard">function</a> hexword(b:bits) word <br> <a href="#encodeword:seq.char:word">encodeword</a>.[ <span class="block"> <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 12) <br>, <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 8) <br>, <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 4) <br>, <a href="#hexdigit:bits:char">hexdigit</a>.b</span>] <p> <a id="%:bits:seq.word" href="#standard">Function</a> %(b:bits) seq.word <br>[ <span class="block"> <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 48) <br>, <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 32) <br>, <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 16) <br>, <a href="#hexword:bits:word">hexword</a>.b</span>] <p> <a id="%:byte:seq.word" href="#standard">Function</a> %(b:byte) seq.word <br>[ <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>.[ <span class="block"> <a href="#hexdigit:bits:char">hexdigit</a>( <a href="#tobits:byte:bits">tobits</a>.b <a href="#>>:bits:int:bits">>></a> 4) <br>, <a href="#hexdigit:bits:char">hexdigit</a>. <a href="#tobits:byte:bits">tobits</a>.b</span>]</span>] <p> <a id="%:int:seq.word" href="#standard">Function</a> %(n:int) seq.word [ <a href="#toword:int:word">toword</a>.n] <p> <a id="%:word:seq.word" href="#standard">Function</a> %(w:word) seq.word [w] <p> <a id="%:boolean:seq.word" href="#standard">Function</a> %(b:boolean) seq.word <span class="keyword">if</span> b <span class="keyword">then</span> <span class="literal">"true"</span> <span class="keyword">else</span> <span class="literal">"false"</span> <p> <a id="%:ordering:seq.word" href="#standard">Function</a> %(o:ordering) seq.word [ <span class="literal">"LT EQ GT"</span> <a href="#sub:seq.T:int:T">sub</a> (toint.o <a href="#+:int:int:int">+</a> 1)] <p> <a id=">alpha:word:word:ordering" href="#standard">Function</a> >alpha(a:word, b:word) ordering <br> <span class="keyword">if</span> a <a href="#=:word:word:boolean">=</a> b <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <a href="#decodeword:word:seq.char">decodeword</a>.a <br> <a href="#>alpha:seq.T:seq.T:ordering">>alpha</a> <a href="#decodeword:word:seq.char">decodeword</a>.b</span> <p> <span class="keyword">Export</span> type:word <p> <a id=">alpha:char:char:ordering" href="#standard">Function</a> >alpha(a:char, b:char) ordering a <a href="#>1:char:char:ordering">>1</a> b <p>use seq.int <p> <a id="seqseg2:seq.int:int:pseq.int" href="#standard">Function</a> seqseg2(s:seq.int, i:int) pseq.int <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(s, i) <p> <a id="red:seq.word:seq.word" href="#standard">Function</a> red(s:seq.word) seq.word <span class="literal">"//:(s)/literal"</span> <p> <span class="keyword" id="toWords">Module</span> toWords <p>use UTF8 <p>use bits <p>use seq.byte <p>use seq.int <p>use standard <p>use seq.word <p>use seq.seq.word <p>use seq.tblrec <p>use seq1.seq.word <p> <a id="towords:UTF8:seq.word" href="#toWords">Function</a> towords(a:UTF8) seq.word <br> <span class="comment">{assumes no paragraph breaks in a}</span> <br> <span class="keyword">let</span> b = <a href="#breakparagraph:seq.byte:seq.seq.word">breakparagraph</a>.toseqbyte.a, <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.b <span class="keyword">then</span> empty:seq.word <span class="keyword">else</span> b <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="breakparagraph:seq.byte:seq.seq.word" href="#toWords">Function</a> breakparagraph(bytes:seq.byte) seq.seq.word <br> <span class="comment">{breaks file into seq of paragraphs. Paragraphs are delimited by one or blank lines.}</span> <br> <a href="#test:seq.byte:seq.tblrec:seq.seq.word">test</a>(bytes, <a href="#tableText:seq.tblrec">tableText</a>) <p> <a id="fromHTML:seq.byte:seq.seq.word" href="#toWords">Function</a> fromHTML(bytes:seq.byte) seq.seq.word <br> <span class="comment">{input is broken into paragraphs when each paragraph is either an HTML element or is text. Paragraphs of text end with a double quote.}</span> <br> <a href="#test:seq.byte:seq.tblrec:seq.seq.word">test</a>(bytes, <a href="#tableHTML:seq.tblrec">tableHTML</a>) <p>type tblrec is kind:int, chr:char <p> <a id="handleCharRef:seq.char:char:seq.char" href="#toWords">function</a> handleCharRef(chars:seq.char, ch:char) seq.char <br> <span class="keyword">if</span> ch <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">";"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> list = <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"&lt;&amp;"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.char <br>, idx = 1 <br>, e ∈ [ <span class="block"> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"&amp;lt"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"&amp;amp"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span>]</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(chars, n.chars <a href="#">-</a> n.e <a href="#+:int:int:int">+</a> 1, n.chars) <br> <a href="#=:seq.T:seq.T:boolean">=</a> e <span class="keyword">then</span> <span class="block">next( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(chars, n.e <a href="#+:int:int:int">+</a> 1, n.e) <br> <a href="#">+</a> list <a href="#sub:seq.T:int:T">sub</a> idx <br>, idx <a href="#+:int:int:int">+</a> 1</span>)</span> <span class="keyword">else</span> next(acc, idx <a href="#+:int:int:int">+</a> 1),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.acc <span class="keyword">then</span> chars <a href="#">+</a> ch <span class="keyword">else</span> acc</span> <span class="keyword">else</span> chars <a href="#">+</a> ch <p> <a id="test:seq.byte:seq.tblrec:seq.seq.word" href="#toWords">function</a> test(bytes:seq.byte, classify:seq.tblrec) seq.seq.word <br> <span class="keyword">let</span> period/colon = 1 <br> <span class="comment">{period or colon is pending waiting for next character}</span> <br> <span class="keyword">for</span> <span class="block">tag = false <br>, state0 = 0 <br>, paragraph0 = empty:seq.seq.word <br>, chars0 = empty:seq.char <br>, gather = bits.0 <br>, expect = 0 <br>, words0 = <span class="literal">""</span> <br>, b ∈ bytes <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> tabrec = classify <a href="#sub:seq.T:int:T">sub</a> ( <a href="#toint:byte:int">toint</a>.b <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> bits = <a href="#tobits:int:bits">tobits</a>. <a href="#toint:byte:int">toint</a>.b <br> <span class="keyword">let</span> kind = kind.tabrec <br> <span class="keyword">let</span> ch = chr.tabrec, <br> <span class="keyword">for</span> state = state0, paragraph = paragraph0, words = words0, chars = chars0, e ∈ [1] <br> <span class="keyword">do</span> <span class="block">{???? make sure this for does not use loop in final code.} <br> <span class="keyword">if</span> state <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> next(state, paragraph, words, chars) <br> <span class="keyword">else</span> if state <a href="#=:int:int:boolean">=</a> period/colon <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newwords = <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>(chars0 <a href="#">+</a> ( <span class="keyword">if</span> ch <a href="#=:char:char:boolean">=</a> {space}char.32 <span class="keyword">then</span> [char.32] <span class="keyword">else</span> empty:seq.char)),</span> next(0, paragraph, words <a href="#">+</a> newwords, empty:seq.char)</span> <span class="keyword">else</span> if state <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> <span class="block">{found first LF and looking for second LF} <br> <span class="keyword">let</span> newstate = <span class="block"> <span class="keyword">if</span> kind <a href="#=:int:int:boolean">=</a> <a href="#Space:int">Space</a> <span class="keyword">then</span> <span class="keyword">if</span> ch <a href="#=:char:char:boolean">=</a> {LF}char.10 <span class="keyword">then</span> 3 <span class="keyword">else</span> 2 <br> <span class="keyword">else</span> 0,</span> next(newstate, paragraph, words, chars)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> state <a href="#=:int:int:boolean">=</a> 3 <span class="keyword">report</span> <span class="literal">"State problem"</span>, <br> <span class="keyword">if</span> kind <a href="#=:int:int:boolean">=</a> <a href="#Space:int">Space</a> <span class="keyword">then</span>{remain in state 3}next(state, paragraph, words, chars) <br> <span class="keyword">else</span> <span class="block">{finish paragraph} <br>next( <span class="block">0 <br>, <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.words <span class="keyword">then</span> paragraph <br> <span class="keyword">else</span> paragraph <a href="#">+</a> [words] <br>, <span class="literal">""</span> <br>, chars</span>),</span></span></span> <span class="keyword">if</span> kind <a href="#=:int:int:boolean">=</a> <a href="#Char&amp;&lt;:int">Char&amp;&lt;</a> <span class="keyword">then</span> <span class="block">{starting a tag} <br> <span class="keyword">let</span> newwords = <span class="block"> <span class="keyword">if</span> n.chars <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> words <br> <span class="keyword">else</span> words <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.chars,</span> <span class="keyword">if</span> ch <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">">"</span> <span class="keyword">then</span> <span class="block">{assert ch ∈(decodeword."&lt;!doctypehml"sub 1+char.32)report"ch:(tag)"+encodeword.[ch]} <br> <span class="keyword">if</span> tag <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newpara = <span class="block">paragraph <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(chars, 1, 2) <br> <a href="#=:seq.T:seq.T:boolean">=</a> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"&lt;/"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span>[words] <a href="#">+</a> [ <a href="#encodeword:seq.char:word">encodeword</a>(chars <a href="#">+</a> ch)] <br> <span class="keyword">else</span> [words] <a href="#">+</a> [[ <a href="#encodeword:seq.char:word">encodeword</a>.chars] <a href="#">+</a> <span class="literal">">"</span>]),</span> next(false, state, newpara, empty:seq.char, bits.0, 0, <span class="literal">""</span>)</span> <span class="keyword">else</span> if <a href="#isempty:seq.T:boolean">isempty</a>.words <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#char1:seq.word:char">char1</a>.words ≠ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span> <span class="keyword">then</span> <span class="block">{???? A more general solution is needed to determine whether a '>' marks the end of an element tag. Does not handle the case where the first word of text is a less than.} <br>next(false, 0, paragraph, chars <a href="#">+</a> ch, bits.0, 0, words)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> newpara = <span class="block">paragraph <a href="#">+</a> [words <a href="#">+</a> [ <a href="#encodeword:seq.char:word">encodeword</a>.chars] <a href="#">+</a> <span class="literal">">"</span>],</span> next(false, 0, newpara, empty:seq.char, bits.0, 0, <span class="literal">""</span>)</span></span> <span class="keyword">else</span> if ch <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.newwords <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#last:seq.T:T">last</a>.newwords ∉ <span class="literal">">"</span> <span class="keyword">then</span> next(true, 0, paragraph <a href="#">+</a> [newwords <a href="#">+</a> <a href="#">dq</a>], [ch], bits.0, 0, <span class="literal">""</span>) <br> <span class="keyword">else</span> next(true, 0, paragraph, [ch], bits.0, 0, newwords)</span> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#Space:int">Space</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> tag <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newpara = <span class="block">paragraph <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.words0 <span class="keyword">then</span> empty:seq.seq.word <br> <span class="keyword">else</span> [words0]),</span> next( <span class="block">false <br>, state <br>, newpara <br>, empty:seq.char <br>, bits.0 <br>, 0 <br>, [ <a href="#encodeword:seq.char:word">encodeword</a>.chars]</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> newwords = <span class="block"> <span class="keyword">if</span> n.chars <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> words <br> <span class="keyword">else</span> words <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.chars</span> <span class="keyword">let</span> newstate = <span class="block"> <span class="keyword">if</span> ch <a href="#=:char:char:boolean">=</a> {LF}char.10 <a href="#∧:boolean:boolean:boolean">∧</a> state <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> state,</span> next(tag, newstate, paragraph, empty:seq.char, bits.0, 0, newwords)</span></span> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> tag <span class="keyword">then</span> <span class="block">next( <span class="block">ch ≠ <a href="#char1:seq.word:char">char1</a>. <span class="literal">";"</span> <br>, 0 <br>, paragraph <br>, <a href="#handleCharRef:seq.char:char:seq.char">handleCharRef</a>(chars, ch) <br>, bits.0 <br>, 0 <br>, words</span>)</span> <span class="keyword">else</span> next(tag, 0, paragraph, chars <a href="#">+</a> ch, bits.0, 0, words)</span> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#ThreeByte:int">ThreeByte</a> <span class="keyword">then</span> next(tag, 0, paragraph, chars, 0xF <a href="#∧:bits:bits:bits">∧</a> bits, 2, words) <br> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#TwoByte:int">TwoByte</a> <span class="keyword">then</span> next(tag, 0, paragraph, chars, 0x1F <a href="#∧:bits:bits:bits">∧</a> bits, 1, words) <br> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#FourByte:int">FourByte</a> <span class="keyword">then</span> next(tag, 0, paragraph, chars, 0x7 <a href="#∧:bits:bits:bits">∧</a> bits, 3, words) <br> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#More:int">More</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newbits = gather <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 6 <a href="#∨:bits:bits:bits">∨</a> 0x3F <a href="#∧:bits:bits:bits">∧</a> bits, <br> <span class="keyword">if</span> expect <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> next(tag, 0, paragraph, chars <a href="#">+</a> char.toint.newbits, bits.0, 0, words) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> expect <a href="#>:int:int:boolean">></a> 0 <span class="keyword">report</span> <span class="literal">"error"</span>, <br>next(tag, 0, paragraph, chars, newbits, expect <a href="#">-</a> 1, words)</span></span> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#StandAlone:int">StandAlone</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newwords = <span class="block"> <span class="keyword">if</span> n.chars <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> words <br> <span class="keyword">else</span> words <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.chars,</span> next( <span class="block">tag <br>, 0 <br>, paragraph <br>, empty:seq.char <br>, bits.0 <br>, 0 <br>, newwords <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.[ch]</span>)</span> <span class="keyword">else</span> if kind <a href="#=:int:int:boolean">=</a> <a href="#Period:int">Period</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newwords = <span class="block"> <span class="keyword">if</span> n.chars <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> words <br> <span class="keyword">else</span> words <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.chars,</span> next(tag, period/colon, paragraph, [ch], bits.0, 0, newwords)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> false <span class="keyword">report</span> <span class="literal">"kind:(kind)"</span>, <br>next(tag, 0, paragraph, chars, bits.0, 0, words),</span></span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.words0 <span class="keyword">then</span> paragraph0 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> html = <span class="block">kind.classify <a href="#sub:seq.T:int:T">sub</a> (toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span> <a href="#+:int:int:int">+</a> 1) <br> <a href="#=:int:int:boolean">=</a> <a href="#Char&amp;&lt;:int">Char&amp;&lt;</a>,</span> paragraph0 <a href="#">+</a> [ <span class="keyword">if</span> html <span class="keyword">then</span> words0 <a href="#">+</a> <a href="#">dq</a> <span class="keyword">else</span> words0]</span> <p> <a id="Invalid:int" href="#toWords">function</a> Invalid int 1 <p> <a id="More:int" href="#toWords">function</a> More int 2 <p> <a id="TwoByte:int" href="#toWords">function</a> TwoByte int 3 <p> <a id="ThreeByte:int" href="#toWords">function</a> ThreeByte int 4 <p> <a id="FourByte:int" href="#toWords">function</a> FourByte int 5 <p> <a id="StandAlone:int" href="#toWords">function</a> StandAlone int 6 <p> <a id="Space:int" href="#toWords">function</a> Space int 7 <p> <a id="Period:int" href="#toWords">function</a> Period int 8 <p> <a id="Char&amp;&lt;:int" href="#toWords">function</a> Char&amp;&lt; int 9 <p> <a id="tableHTML:seq.tblrec" href="#toWords">function</a> tableHTML seq.tblrec <br> <span class="comment">{auto generated}</span> <br>[ <span class="block">{00}tblrec(0, char.0) <br>, {01}tblrec(0, char.1) <br>, {02}tblrec(0, char.2) <br>, {03}tblrec(0, char.3) <br>, {04}tblrec(0, char.4) <br>, {05}tblrec(0, char.5) <br>, {06}tblrec(0, char.6) <br>, {07}tblrec(0, char.7) <br>, {08}tblrec(0, char.8) <br>, {09}tblrec(0, char.9) <br>, {0A}tblrec( <a href="#Space:int">Space</a>, char.10) <br>, {0B}tblrec(0, char.11) <br>, {0C}tblrec(0, char.12) <br>, {0D}tblrec( <a href="#Space:int">Space</a>, char.13) <br>, {0E}tblrec(0, char.14) <br>, {0F}tblrec(0, char.15) <br>, {10}tblrec(0, char.16) <br>, {11}tblrec(0, char.17) <br>, {12}tblrec(0, char.18) <br>, {13}tblrec(0, char.19) <br>, {14}tblrec(0, char.20) <br>, {15}tblrec(0, char.21) <br>, {16}tblrec(0, char.22) <br>, {17}tblrec(0, char.23) <br>, {18}tblrec(0, char.24) <br>, {19}tblrec(0, char.25) <br>, {1A}tblrec(0, char.26) <br>, {1B}tblrec(0, char.27) <br>, {1C}tblrec(0, char.28) <br>, {1D}tblrec(0, char.29) <br>, {1E}tblrec(0, char.30) <br>, {1F}tblrec(0, char.31) <br>, {20}tblrec( <a href="#Space:int">Space</a>, char.32) <br>, {21}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"!"</span>) <br>, {22} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <a href="#">dq</a>) <br>, {23}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"#"</span>) <br>, {24}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"$"</span>) <br>, {25}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"%"</span>) <br>, {26}tblrec( <a href="#Char&amp;&lt;:int">Char&amp;&lt;</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&amp;"</span>) <br>, {27}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"'"</span>) <br>, {28} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"("</span>) <br>, {29} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">")"</span>) <br>, {2A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"*"</span>) <br>, {2B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"+"</span>) <br>, {2C} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">","</span>) <br>, {2D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span>) <br>, {2E}tblrec( <a href="#Period:int">Period</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"."</span>) <br>, {2F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>) <br>, {30}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>) <br>, {31}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"1"</span>) <br>, {32}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"2"</span>) <br>, {33}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"3"</span>) <br>, {34}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"4"</span>) <br>, {35}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"5"</span>) <br>, {36}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"6"</span>) <br>, {37}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"7"</span>) <br>, {38}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"8"</span>) <br>, {39}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"9"</span>) <br>, {3A}tblrec( <a href="#Period:int">Period</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">":"</span>) <br>, {3B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">";"</span>) <br>, {3C}tblrec( <a href="#Char&amp;&lt;:int">Char&amp;&lt;</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span>) <br>, {3D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"="</span>) <br>, {3E}tblrec( <a href="#Char&amp;&lt;:int">Char&amp;&lt;</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">">"</span>) <br>, {3F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"?"</span>) <br>, {40}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"@"</span>) <br>, {41}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"A"</span>) <br>, {42}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"B"</span>) <br>, {43}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"C"</span>) <br>, {44}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"D"</span>) <br>, {45}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"E"</span>) <br>, {46}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"F"</span>) <br>, {47}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"G"</span>) <br>, {48}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"H"</span>) <br>, {49}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"I"</span>) <br>, {4A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"J"</span>) <br>, {4B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"K"</span>) <br>, {4C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"L"</span>) <br>, {4D}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"M"</span>) <br>, {4E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"N"</span>) <br>, {4F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"O"</span>) <br>, {50}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"P"</span>) <br>, {51}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Q"</span>) <br>, {52}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"R"</span>) <br>, {53}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"S"</span>) <br>, {54}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"T"</span>) <br>, {55}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"U"</span>) <br>, {56}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"V"</span>) <br>, {57}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"W"</span>) <br>, {58}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"X"</span>) <br>, {59}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Y"</span>) <br>, {5A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Z"</span>) <br>, {5B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"["</span>) <br>, {5C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"\"</span>) <br>, {5D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"]"</span>) <br>, {5E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"^"</span>) <br>, {5F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"_"</span>) <br>, {60}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"`"</span>) <br>, {61}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"a"</span>) <br>, {62}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"b"</span>) <br>, {63}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"c"</span>) <br>, {64}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"d"</span>) <br>, {65}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"e"</span>) <br>, {66}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"f"</span>) <br>, {67}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"g"</span>) <br>, {68}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"h"</span>) <br>, {69}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"i"</span>) <br>, {6A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"j"</span>) <br>, {6B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"k"</span>) <br>, {6C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"l"</span>) <br>, {6D}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"m"</span>) <br>, {6E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"n"</span>) <br>, {6F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"o"</span>) <br>, {70}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"p"</span>) <br>, {71}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"q"</span>) <br>, {72}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"r"</span>) <br>, {73}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"s"</span>) <br>, {74}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"t"</span>) <br>, {75}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"u"</span>) <br>, {76}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"v"</span>) <br>, {77}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"w"</span>) <br>, {78}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"x"</span>) <br>, {79}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"y"</span>) <br>, {7A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"z"</span>) <br>, {7B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"{"</span>) <br>, {7C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"|"</span>) <br>, {7D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"}"</span>) <br>, {7E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"~"</span>) <br>, {7F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">""</span>) <br>, {80}tblrec( <a href="#More:int">More</a>, char.128) <br>, {81}tblrec( <a href="#More:int">More</a>, char.129) <br>, {82}tblrec( <a href="#More:int">More</a>, char.130) <br>, {83}tblrec( <a href="#More:int">More</a>, char.131) <br>, {84}tblrec( <a href="#More:int">More</a>, char.132) <br>, {85}tblrec( <a href="#More:int">More</a>, char.133) <br>, {86}tblrec( <a href="#More:int">More</a>, char.134) <br>, {87}tblrec( <a href="#More:int">More</a>, char.135) <br>, {88}tblrec( <a href="#More:int">More</a>, char.136) <br>, {89}tblrec( <a href="#More:int">More</a>, char.137) <br>, {8A}tblrec( <a href="#More:int">More</a>, char.138) <br>, {8B}tblrec( <a href="#More:int">More</a>, char.139) <br>, {8C}tblrec( <a href="#More:int">More</a>, char.140) <br>, {8D}tblrec( <a href="#More:int">More</a>, char.141) <br>, {8E}tblrec( <a href="#More:int">More</a>, char.142) <br>, {8F}tblrec( <a href="#More:int">More</a>, char.143) <br>, {90}tblrec( <a href="#More:int">More</a>, char.144) <br>, {91}tblrec( <a href="#More:int">More</a>, char.145) <br>, {92}tblrec( <a href="#More:int">More</a>, char.146) <br>, {93}tblrec( <a href="#More:int">More</a>, char.147) <br>, {94}tblrec( <a href="#More:int">More</a>, char.148) <br>, {95}tblrec( <a href="#More:int">More</a>, char.149) <br>, {96}tblrec( <a href="#More:int">More</a>, char.150) <br>, {97}tblrec( <a href="#More:int">More</a>, char.151) <br>, {98}tblrec( <a href="#More:int">More</a>, char.152) <br>, {99}tblrec( <a href="#More:int">More</a>, char.153) <br>, {9A}tblrec( <a href="#More:int">More</a>, char.154) <br>, {9B}tblrec( <a href="#More:int">More</a>, char.155) <br>, {9C}tblrec( <a href="#More:int">More</a>, char.156) <br>, {9D}tblrec( <a href="#More:int">More</a>, char.157) <br>, {9E}tblrec( <a href="#More:int">More</a>, char.158) <br>, {9F}tblrec( <a href="#More:int">More</a>, char.159) <br>, {A0}tblrec( <a href="#More:int">More</a>, char.160) <br>, {A1}tblrec( <a href="#More:int">More</a>, char.161) <br>, {A2}tblrec( <a href="#More:int">More</a>, char.162) <br>, {A3}tblrec( <a href="#More:int">More</a>, char.163) <br>, {A4}tblrec( <a href="#More:int">More</a>, char.164) <br>, {A5}tblrec( <a href="#More:int">More</a>, char.165) <br>, {A6}tblrec( <a href="#More:int">More</a>, char.166) <br>, {A7}tblrec( <a href="#More:int">More</a>, char.167) <br>, {A8}tblrec( <a href="#More:int">More</a>, char.168) <br>, {A9}tblrec( <a href="#More:int">More</a>, char.169) <br>, {AA}tblrec( <a href="#More:int">More</a>, char.170) <br>, {AB}tblrec( <a href="#More:int">More</a>, char.171) <br>, {AC}tblrec( <a href="#More:int">More</a>, char.172) <br>, {AD}tblrec( <a href="#More:int">More</a>, char.173) <br>, {AE}tblrec( <a href="#More:int">More</a>, char.174) <br>, {AF}tblrec( <a href="#More:int">More</a>, char.175) <br>, {B0}tblrec( <a href="#More:int">More</a>, char.176) <br>, {B1}tblrec( <a href="#More:int">More</a>, char.177) <br>, {B2}tblrec( <a href="#More:int">More</a>, char.178) <br>, {B3}tblrec( <a href="#More:int">More</a>, char.179) <br>, {B4}tblrec( <a href="#More:int">More</a>, char.180) <br>, {B5}tblrec( <a href="#More:int">More</a>, char.181) <br>, {B6}tblrec( <a href="#More:int">More</a>, char.182) <br>, {B7}tblrec( <a href="#More:int">More</a>, char.183) <br>, {B8}tblrec( <a href="#More:int">More</a>, char.184) <br>, {B9}tblrec( <a href="#More:int">More</a>, char.185) <br>, {BA}tblrec( <a href="#More:int">More</a>, char.186) <br>, {BB}tblrec( <a href="#More:int">More</a>, char.187) <br>, {BC}tblrec( <a href="#More:int">More</a>, char.188) <br>, {BD}tblrec( <a href="#More:int">More</a>, char.189) <br>, {BE}tblrec( <a href="#More:int">More</a>, char.190) <br>, {BF}tblrec( <a href="#More:int">More</a>, char.191) <br>, {C0}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.192) <br>, {C1}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.193) <br>, {C2}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.194) <br>, {C3}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.195) <br>, {C4}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.196) <br>, {C5}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.197) <br>, {C6}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.198) <br>, {C7}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.199) <br>, {C8}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.200) <br>, {C9}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.201) <br>, {CA}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.202) <br>, {CB}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.203) <br>, {CC}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.204) <br>, {CD}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.205) <br>, {CE}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.206) <br>, {CF}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.207) <br>, {D0}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.208) <br>, {D1}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.209) <br>, {D2}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.210) <br>, {D3}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.211) <br>, {D4}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.212) <br>, {D5}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.213) <br>, {D6}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.214) <br>, {D7}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.215) <br>, {D8}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.216) <br>, {D9}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.217) <br>, {DA}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.218) <br>, {DB}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.219) <br>, {DC}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.220) <br>, {DD}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.221) <br>, {DE}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.222) <br>, {DF}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.223) <br>, {E0}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.224) <br>, {E1}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.225) <br>, {E2}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.226) <br>, {E3}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.227) <br>, {E4}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.228) <br>, {E5}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.229) <br>, {E6}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.230) <br>, {E7}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.231) <br>, {E8}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.232) <br>, {E9}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.233) <br>, {EA}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.234) <br>, {EB}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.235) <br>, {EC}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.236) <br>, {ED}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.237) <br>, {EE}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.238) <br>, {EF}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.239) <br>, {F0}tblrec( <a href="#FourByte:int">FourByte</a>, char.240) <br>, {F1}tblrec( <a href="#FourByte:int">FourByte</a>, char.241) <br>, {F2}tblrec( <a href="#FourByte:int">FourByte</a>, char.242) <br>, {F3}tblrec( <a href="#FourByte:int">FourByte</a>, char.243) <br>, {F4}tblrec( <a href="#FourByte:int">FourByte</a>, char.244) <br>, {F5}tblrec( <a href="#FourByte:int">FourByte</a>, char.245) <br>, {F6}tblrec( <a href="#FourByte:int">FourByte</a>, char.246) <br>, {F7}tblrec( <a href="#FourByte:int">FourByte</a>, char.247) <br>, {F8}tblrec( <a href="#Invalid:int">Invalid</a>, char.248) <br>, {F9}tblrec( <a href="#Invalid:int">Invalid</a>, char.249) <br>, {FA}tblrec( <a href="#Invalid:int">Invalid</a>, char.250) <br>, {FB}tblrec( <a href="#Invalid:int">Invalid</a>, char.251) <br>, {FC}tblrec( <a href="#Invalid:int">Invalid</a>, char.252) <br>, {FD}tblrec( <a href="#Invalid:int">Invalid</a>, char.253) <br>, {FE}tblrec( <a href="#Invalid:int">Invalid</a>, char.254) <br>, {FF}tblrec( <a href="#Invalid:int">Invalid</a>, char.255)</span>] <p> <a id="tableText:seq.tblrec" href="#toWords">function</a> tableText seq.tblrec <br> <span class="comment">{auto generated}</span> <br>[ <span class="block">{00}tblrec(0, char.0) <br>, {01}tblrec(0, char.1) <br>, {02}tblrec(0, char.2) <br>, {03}tblrec(0, char.3) <br>, {04}tblrec(0, char.4) <br>, {05}tblrec(0, char.5) <br>, {06}tblrec(0, char.6) <br>, {07}tblrec(0, char.7) <br>, {08}tblrec(0, char.8) <br>, {09}tblrec(0, char.9) <br>, {0A}tblrec( <a href="#Space:int">Space</a>, char.10) <br>, {0B}tblrec(0, char.11) <br>, {0C}tblrec(0, char.12) <br>, {0D}tblrec( <a href="#Space:int">Space</a>, char.13) <br>, {0E}tblrec(0, char.14) <br>, {0F}tblrec(0, char.15) <br>, {10}tblrec(0, char.16) <br>, {11}tblrec(0, char.17) <br>, {12}tblrec(0, char.18) <br>, {13}tblrec(0, char.19) <br>, {14}tblrec(0, char.20) <br>, {15}tblrec(0, char.21) <br>, {16}tblrec(0, char.22) <br>, {17}tblrec(0, char.23) <br>, {18}tblrec(0, char.24) <br>, {19}tblrec(0, char.25) <br>, {1A}tblrec(0, char.26) <br>, {1B}tblrec(0, char.27) <br>, {1C}tblrec(0, char.28) <br>, {1D}tblrec(0, char.29) <br>, {1E}tblrec(0, char.30) <br>, {1F}tblrec(0, char.31) <br>, {20}tblrec( <a href="#Space:int">Space</a>, char.32) <br>, {21}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"!"</span>) <br>, {22} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <a href="#">dq</a>) <br>, {23}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"#"</span>) <br>, {24}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"$"</span>) <br>, {25}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"%"</span>) <br>, {26}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&amp;"</span>) <br>, {27}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"'"</span>) <br>, {28} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"("</span>) <br>, {29} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">")"</span>) <br>, {2A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"*"</span>) <br>, {2B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"+"</span>) <br>, {2C} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">","</span>) <br>, {2D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span>) <br>, {2E}tblrec( <a href="#Period:int">Period</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"."</span>) <br>, {2F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>) <br>, {30}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>) <br>, {31}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"1"</span>) <br>, {32}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"2"</span>) <br>, {33}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"3"</span>) <br>, {34}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"4"</span>) <br>, {35}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"5"</span>) <br>, {36}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"6"</span>) <br>, {37}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"7"</span>) <br>, {38}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"8"</span>) <br>, {39}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"9"</span>) <br>, {3A}tblrec( <a href="#Period:int">Period</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">":"</span>) <br>, {3B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">";"</span>) <br>, {3C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span>) <br>, {3D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"="</span>) <br>, {3E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">">"</span>) <br>, {3F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"?"</span>) <br>, {40}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"@"</span>) <br>, {41}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"A"</span>) <br>, {42}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"B"</span>) <br>, {43}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"C"</span>) <br>, {44}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"D"</span>) <br>, {45}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"E"</span>) <br>, {46}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"F"</span>) <br>, {47}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"G"</span>) <br>, {48}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"H"</span>) <br>, {49}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"I"</span>) <br>, {4A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"J"</span>) <br>, {4B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"K"</span>) <br>, {4C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"L"</span>) <br>, {4D}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"M"</span>) <br>, {4E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"N"</span>) <br>, {4F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"O"</span>) <br>, {50}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"P"</span>) <br>, {51}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Q"</span>) <br>, {52}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"R"</span>) <br>, {53}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"S"</span>) <br>, {54}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"T"</span>) <br>, {55}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"U"</span>) <br>, {56}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"V"</span>) <br>, {57}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"W"</span>) <br>, {58}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"X"</span>) <br>, {59}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Y"</span>) <br>, {5A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Z"</span>) <br>, {5B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"["</span>) <br>, {5C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"\"</span>) <br>, {5D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"]"</span>) <br>, {5E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"^"</span>) <br>, {5F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"_"</span>) <br>, {60}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"`"</span>) <br>, {61}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"a"</span>) <br>, {62}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"b"</span>) <br>, {63}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"c"</span>) <br>, {64}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"d"</span>) <br>, {65}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"e"</span>) <br>, {66}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"f"</span>) <br>, {67}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"g"</span>) <br>, {68}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"h"</span>) <br>, {69}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"i"</span>) <br>, {6A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"j"</span>) <br>, {6B}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"k"</span>) <br>, {6C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"l"</span>) <br>, {6D}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"m"</span>) <br>, {6E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"n"</span>) <br>, {6F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"o"</span>) <br>, {70}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"p"</span>) <br>, {71}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"q"</span>) <br>, {72}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"r"</span>) <br>, {73}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"s"</span>) <br>, {74}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"t"</span>) <br>, {75}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"u"</span>) <br>, {76}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"v"</span>) <br>, {77}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"w"</span>) <br>, {78}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"x"</span>) <br>, {79}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"y"</span>) <br>, {7A}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"z"</span>) <br>, {7B} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"{"</span>) <br>, {7C}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"|"</span>) <br>, {7D} <br>tblrec( <a href="#StandAlone:int">StandAlone</a>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"}"</span>) <br>, {7E}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"~"</span>) <br>, {7F}tblrec(0, <a href="#char1:seq.word:char">char1</a>. <span class="literal">""</span>) <br>, {80}tblrec( <a href="#More:int">More</a>, char.128) <br>, {81}tblrec( <a href="#More:int">More</a>, char.129) <br>, {82}tblrec( <a href="#More:int">More</a>, char.130) <br>, {83}tblrec( <a href="#More:int">More</a>, char.131) <br>, {84}tblrec( <a href="#More:int">More</a>, char.132) <br>, {85}tblrec( <a href="#More:int">More</a>, char.133) <br>, {86}tblrec( <a href="#More:int">More</a>, char.134) <br>, {87}tblrec( <a href="#More:int">More</a>, char.135) <br>, {88}tblrec( <a href="#More:int">More</a>, char.136) <br>, {89}tblrec( <a href="#More:int">More</a>, char.137) <br>, {8A}tblrec( <a href="#More:int">More</a>, char.138) <br>, {8B}tblrec( <a href="#More:int">More</a>, char.139) <br>, {8C}tblrec( <a href="#More:int">More</a>, char.140) <br>, {8D}tblrec( <a href="#More:int">More</a>, char.141) <br>, {8E}tblrec( <a href="#More:int">More</a>, char.142) <br>, {8F}tblrec( <a href="#More:int">More</a>, char.143) <br>, {90}tblrec( <a href="#More:int">More</a>, char.144) <br>, {91}tblrec( <a href="#More:int">More</a>, char.145) <br>, {92}tblrec( <a href="#More:int">More</a>, char.146) <br>, {93}tblrec( <a href="#More:int">More</a>, char.147) <br>, {94}tblrec( <a href="#More:int">More</a>, char.148) <br>, {95}tblrec( <a href="#More:int">More</a>, char.149) <br>, {96}tblrec( <a href="#More:int">More</a>, char.150) <br>, {97}tblrec( <a href="#More:int">More</a>, char.151) <br>, {98}tblrec( <a href="#More:int">More</a>, char.152) <br>, {99}tblrec( <a href="#More:int">More</a>, char.153) <br>, {9A}tblrec( <a href="#More:int">More</a>, char.154) <br>, {9B}tblrec( <a href="#More:int">More</a>, char.155) <br>, {9C}tblrec( <a href="#More:int">More</a>, char.156) <br>, {9D}tblrec( <a href="#More:int">More</a>, char.157) <br>, {9E}tblrec( <a href="#More:int">More</a>, char.158) <br>, {9F}tblrec( <a href="#More:int">More</a>, char.159) <br>, {A0}tblrec( <a href="#More:int">More</a>, char.160) <br>, {A1}tblrec( <a href="#More:int">More</a>, char.161) <br>, {A2}tblrec( <a href="#More:int">More</a>, char.162) <br>, {A3}tblrec( <a href="#More:int">More</a>, char.163) <br>, {A4}tblrec( <a href="#More:int">More</a>, char.164) <br>, {A5}tblrec( <a href="#More:int">More</a>, char.165) <br>, {A6}tblrec( <a href="#More:int">More</a>, char.166) <br>, {A7}tblrec( <a href="#More:int">More</a>, char.167) <br>, {A8}tblrec( <a href="#More:int">More</a>, char.168) <br>, {A9}tblrec( <a href="#More:int">More</a>, char.169) <br>, {AA}tblrec( <a href="#More:int">More</a>, char.170) <br>, {AB}tblrec( <a href="#More:int">More</a>, char.171) <br>, {AC}tblrec( <a href="#More:int">More</a>, char.172) <br>, {AD}tblrec( <a href="#More:int">More</a>, char.173) <br>, {AE}tblrec( <a href="#More:int">More</a>, char.174) <br>, {AF}tblrec( <a href="#More:int">More</a>, char.175) <br>, {B0}tblrec( <a href="#More:int">More</a>, char.176) <br>, {B1}tblrec( <a href="#More:int">More</a>, char.177) <br>, {B2}tblrec( <a href="#More:int">More</a>, char.178) <br>, {B3}tblrec( <a href="#More:int">More</a>, char.179) <br>, {B4}tblrec( <a href="#More:int">More</a>, char.180) <br>, {B5}tblrec( <a href="#More:int">More</a>, char.181) <br>, {B6}tblrec( <a href="#More:int">More</a>, char.182) <br>, {B7}tblrec( <a href="#More:int">More</a>, char.183) <br>, {B8}tblrec( <a href="#More:int">More</a>, char.184) <br>, {B9}tblrec( <a href="#More:int">More</a>, char.185) <br>, {BA}tblrec( <a href="#More:int">More</a>, char.186) <br>, {BB}tblrec( <a href="#More:int">More</a>, char.187) <br>, {BC}tblrec( <a href="#More:int">More</a>, char.188) <br>, {BD}tblrec( <a href="#More:int">More</a>, char.189) <br>, {BE}tblrec( <a href="#More:int">More</a>, char.190) <br>, {BF}tblrec( <a href="#More:int">More</a>, char.191) <br>, {C0}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.192) <br>, {C1}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.193) <br>, {C2}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.194) <br>, {C3}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.195) <br>, {C4}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.196) <br>, {C5}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.197) <br>, {C6}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.198) <br>, {C7}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.199) <br>, {C8}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.200) <br>, {C9}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.201) <br>, {CA}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.202) <br>, {CB}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.203) <br>, {CC}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.204) <br>, {CD}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.205) <br>, {CE}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.206) <br>, {CF}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.207) <br>, {D0}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.208) <br>, {D1}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.209) <br>, {D2}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.210) <br>, {D3}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.211) <br>, {D4}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.212) <br>, {D5}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.213) <br>, {D6}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.214) <br>, {D7}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.215) <br>, {D8}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.216) <br>, {D9}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.217) <br>, {DA}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.218) <br>, {DB}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.219) <br>, {DC}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.220) <br>, {DD}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.221) <br>, {DE}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.222) <br>, {DF}tblrec( <a href="#TwoByte:int">TwoByte</a>, char.223) <br>, {E0}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.224) <br>, {E1}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.225) <br>, {E2}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.226) <br>, {E3}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.227) <br>, {E4}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.228) <br>, {E5}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.229) <br>, {E6}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.230) <br>, {E7}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.231) <br>, {E8}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.232) <br>, {E9}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.233) <br>, {EA}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.234) <br>, {EB}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.235) <br>, {EC}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.236) <br>, {ED}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.237) <br>, {EE}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.238) <br>, {EF}tblrec( <a href="#ThreeByte:int">ThreeByte</a>, char.239) <br>, {F0}tblrec( <a href="#FourByte:int">FourByte</a>, char.240) <br>, {F1}tblrec( <a href="#FourByte:int">FourByte</a>, char.241) <br>, {F2}tblrec( <a href="#FourByte:int">FourByte</a>, char.242) <br>, {F3}tblrec( <a href="#FourByte:int">FourByte</a>, char.243) <br>, {F4}tblrec( <a href="#FourByte:int">FourByte</a>, char.244) <br>, {F5}tblrec( <a href="#FourByte:int">FourByte</a>, char.245) <br>, {F6}tblrec( <a href="#FourByte:int">FourByte</a>, char.246) <br>, {F7}tblrec( <a href="#FourByte:int">FourByte</a>, char.247) <br>, {F8}tblrec( <a href="#Invalid:int">Invalid</a>, char.248) <br>, {F9}tblrec( <a href="#Invalid:int">Invalid</a>, char.249) <br>, {FA}tblrec( <a href="#Invalid:int">Invalid</a>, char.250) <br>, {FB}tblrec( <a href="#Invalid:int">Invalid</a>, char.251) <br>, {FC}tblrec( <a href="#Invalid:int">Invalid</a>, char.252) <br>, {FD}tblrec( <a href="#Invalid:int">Invalid</a>, char.253) <br>, {FE}tblrec( <a href="#Invalid:int">Invalid</a>, char.254) <br>, {FF}tblrec( <a href="#Invalid:int">Invalid</a>, char.255)</span>] <p> <span class="keyword" id="UTF8">Module</span> UTF8 <p>use bits <p>use seq.byte <p>use seq1.char <p>use seq.int <p>use standard <p>use word <p> <span class="keyword">Export</span> type:UTF8 <p> <span class="keyword">Export</span> toseqbyte(UTF8) seq.byte <p> <span class="keyword">Export</span> UTF8(seq.byte) UTF8 <p>type UTF8 is toseqbyte:seq.byte <p> <a id="length:UTF8:int" href="#UTF8">Function</a> length(a:UTF8) int n.toseqbyte.a <p> <a id="sub:UTF8:int:byte" href="#UTF8">Function</a> sub(a:UTF8, i:int) byte (toseqbyte.a) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="emptyUTF8:UTF8" href="#UTF8">Function</a> emptyUTF8 UTF8 UTF8.empty:seq.byte <p> <a id="+:UTF8:UTF8:UTF8" href="#UTF8">Function</a> +(a:UTF8, b:UTF8) UTF8 UTF8(toseqbyte.a <a href="#">+</a> toseqbyte.b) <p> <a id="+:UTF8:char:UTF8" href="#UTF8">Function</a> +(a:UTF8, ch:char) UTF8 a <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>.ch <p> <a id="+:UTF8:seq.char:UTF8" href="#UTF8">Function</a> +(a:UTF8, s:seq.char) UTF8 <br> <span class="keyword">for</span> acc = a, @e ∈ s <span class="keyword">do</span> acc <a href="#+:UTF8:char:UTF8">+</a> @e, <br>acc <p> <a id="=:UTF8:UTF8:boolean" href="#UTF8">Function</a> =(a:UTF8, b:UTF8) boolean toseqbyte.a <a href="#=:seq.T:seq.T:boolean">=</a> toseqbyte.b <p> <a id="commachar:char" href="#UTF8">Function</a> commachar char char.44 <p> <a id="hyphenchar:char" href="#UTF8">Function</a> hyphenchar char char.45 <p> <a id="periodchar:char" href="#UTF8">Function</a> periodchar char char.46 <p> <a id="hexOrDecimal?:word:word" href="#UTF8">Function</a> hexOrDecimal?(w:word) word <br> <span class="comment">{checks to see if the first 2 chars indicate the word may be integer in hex or decimal format and returns hex, decimal, or other}</span> <br> <span class="keyword">let</span> chars = <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <span class="keyword">let</span> len = n.chars, <br> <span class="keyword">if</span> len <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="literal">"other"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = <span class="block"> <span class="keyword">if</span> len <a href="#>:int:int:boolean">></a> 1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> chars <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span> <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> 1</span> <span class="keyword">let</span> firstchar = toint.chars <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#between:int:int:int:boolean">between</a>(firstchar, 48, 57) <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> len <a href="#>:int:int:boolean">></a> 1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"'"</span> <a href="#=:char:char:boolean">=</a> chars <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="literal">"word"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="literal">"other"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">else</span> if firstchar <a href="#=:int:int:boolean">=</a> 48 <br> <a href="#∧:boolean:boolean:boolean">∧</a> len <a href="#>:int:int:boolean">></a> 2 <br> <a href="#∧:boolean:boolean:boolean">∧</a> chars <a href="#sub:seq.T:int:T">sub</a> 2 <br> <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"xX"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="literal">"hex"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="literal">"decimal"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span> <p> <a id="toUTF8:int:UTF8" href="#UTF8">Function</a> toUTF8(n:int) UTF8 <br> <span class="keyword">for</span> acc = empty:seq.byte, e ∈ <a href="#tochars:int:seq.char">tochars</a>.n <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.toint.e, <br>UTF8.acc <p> <a id="encodeUTF8:char:UTF8" href="#UTF8">Function</a> encodeUTF8(ch:char) UTF8 <br> <span class="comment">{convert to UTF8 byte encoding of unicode character}</span> <br> <span class="keyword">let</span> i = toint.ch, <br>UTF8( <span class="block"> <span class="keyword">if</span> i <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> [ <a href="#tobyte:int:byte">tobyte</a>.i] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc = [ <a href="#tobyte:int:byte">tobyte</a>(128 <a href="#+:int:int:int">+</a> i <a href="#mod:int:int:int">mod</a> 64)] <br>, t = 32 <br>, c = i <a href="#/:int:int:int">/</a> 64</span> <span class="keyword">while</span> c ≥ t <br> <span class="keyword">do</span> <span class="block">next( <span class="block">[ <a href="#tobyte:int:byte">tobyte</a>(128 <a href="#+:int:int:int">+</a> c <a href="#mod:int:int:int">mod</a> 64)] <br> <a href="#">+</a> acc <br>, t <a href="#/:int:int:int">/</a> 2 <br>, c <a href="#/:int:int:int">/</a> 64</span>),</span>[ <a href="#tobyte:int:byte">tobyte</a>(256 <a href="#">-</a> 2 <a href="#*:int:int:int">*</a> t <a href="#+:int:int:int">+</a> c)] <br> <a href="#">+</a> acc</span></span>) <p> <a id="decodeUTF8:UTF8:seq.char" href="#UTF8">Function</a> decodeUTF8(b:UTF8) seq.char <br> <span class="comment">{converts UTF-8 encoded sequence into a sequence of chars}</span> <br> <span class="keyword">for</span> state = 0, val = 0, result = empty:seq.int, x0 ∈ toseqbyte.b <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> x = <a href="#toint:byte:int">toint</a>.x0, <br> <span class="keyword">if</span> state <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> x <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> next(0, 0, result <a href="#">+</a> x) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 224 <span class="keyword">then</span> next(1, (x <a href="#">-</a> 192) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 240 <span class="keyword">then</span> next(2, (x <a href="#">-</a> 224) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 248 <span class="keyword">then</span> next(3, (x <a href="#">-</a> 240) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 252 <span class="keyword">then</span> next(4, (x <a href="#">-</a> 248) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> next(5, (x <a href="#">-</a> 252) <a href="#*:int:int:int">*</a> 64, result)</span> <span class="keyword">else</span> if state <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> next(0, 0, result <a href="#">+</a> (x <a href="#+:int:int:int">+</a> val <a href="#">-</a> 128)) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">state <a href="#">-</a> 1 <br>, (val <a href="#+:int:int:int">+</a> (x <a href="#">-</a> 128)) <a href="#*:int:int:int">*</a> 64 <br>, result</span>),</span></span> <a href="#tocharseq:seq.int:seq.char">tocharseq</a>.result <p> <a id="intlit:UTF8:int" href="#UTF8">Function</a> intlit(s:UTF8) int <br> <a href="#cvttoint:seq.char:int">cvttoint</a>. <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>.s <p> <a id="tointseq:seq.char:seq.int" href="#UTF8">Function</a> tointseq(a:seq.char) seq.int <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> toint.@e, <br>acc <p> <a id="tocharseq:seq.int:seq.char" href="#UTF8">Function</a> tocharseq(a:seq.int) seq.char <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> char.@e, <br>acc <p> <a id="escapeformat:word" href="#UTF8">Function</a> escapeformat word <a href="#">merge</a>. <span class="literal">"/ escapeformat"</span> <p> <span class="keyword" id="word">Module</span> word <p>use bits <p>use seq.char <p>use encoding.seq.char <p>use seq.int <p>use kernal <p>use seq.word <p>use xxhash <p> <a id="tointseq:seq.char:seq.int" href="#word">function</a> tointseq(a:seq.char) seq.int <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> toint.@e, <br>acc <p> <a id="word:encoding.seq.char:word" href="#word">Function</a> word(a:encoding.seq.char) word word.valueofencoding.a <p> <a id="asencoding:word:encoding.seq.char" href="#word">Function</a> asencoding(w:word) encoding.seq.char <a href="#">to:encoding.seq.char</a>(rawvalue.w) <p> <a id=">1:char:char:ordering" href="#word">Function</a> >1(a:char, b:char) ordering toint.a <a href="#>1:int:int:ordering">>1</a> toint.b <p> <a id="hash:seq.char:int" href="#word">Function</a> hash(a:seq.char) int <br> <span class="keyword">for</span> <span class="block">acc = <a href="#hashstart32:int:bits">hashstart32</a>.0 <br>, @e ∈ <a href="#tointseq:seq.char:seq.int">tointseq</a>.a</span> <span class="keyword">do</span> <a href="#hash32:bits:int:bits">hash32</a>(acc, @e), <br> <a href="#finalmix32:bits:int">finalmix32</a>.acc <p> <a id="wordencodingtoword:int:word" href="#word">Function</a> wordencodingtoword(i:int) word <br> <a href="#word:encoding.seq.char:word">word</a>. <a href="#">to:encoding.seq.char</a>(i) <p> <a id="encodeword:seq.char:word" href="#word">Function</a> encodeword(a:seq.char) word <br> <span class="comment">{OPTION NOINLINE COMPILETIME}</span> <br> <a href="#word:encoding.seq.char:word">word</a>. <a href="#encode:T:encoding.T">encode</a>.a <p> <a id="decodeword:word:seq.char" href="#word">Function</a> decodeword(w:word) seq.char <br> <span class="comment">{OPTION NOINLINE COMPILETIME}</span> <br> <a href="#decode:encoding.T:T">decode</a>. <a href="#asencoding:word:encoding.seq.char">asencoding</a>.w <p> <a id="hash:word:int" href="#word">Function</a> hash(a:word) int <br> <a href="#hash:encoding.T:int">hash</a>. <a href="#asencoding:word:encoding.seq.char">asencoding</a>.a <p> <a id="hash:seq.word:int" href="#word">Function</a> hash(a:seq.word) int <br> <span class="keyword">for</span> acc = <a href="#hashstart:bits">hashstart</a>, @e ∈ a <br> <span class="keyword">do</span> <a href="#hash:bits:int:bits">hash</a>(acc, <a href="#hash:word:int">hash</a>.@e), <br> <a href="#finalmix:bits:int">finalmix</a>.acc <p> <a id="hash:seq.int:int" href="#word">Function</a> hash(a:seq.int) int <br> <span class="keyword">for</span> acc = <a href="#hashstart:bits">hashstart</a>, @e ∈ a <br> <span class="keyword">do</span> <a href="#hash:bits:int:bits">hash</a>(acc, @e), <br> <a href="#finalmix:bits:int">finalmix</a>.acc <p> <a id=">1:word:word:ordering" href="#word">Function</a> >1(a:word, b:word) ordering <br> <a href="#asencoding:word:encoding.seq.char">asencoding</a>.a <br> <a href="#>1:encoding.T:encoding.T:ordering">>1</a> <a href="#asencoding:word:encoding.seq.char">asencoding</a>.b <p> <a id="merge:seq.word:word" href="#word">Function</a> merge(a:seq.word) word <br> <span class="comment">{OPTION COMPILETIME /br<br>make multiple words into a single word. }</span> <br> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ a <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.@e, <br> <a href="#encodeword:seq.char:word">encodeword</a>.acc <p> <a id="toword:int:word" href="#word">Function</a> toword(n:int) word <br> <span class="comment">{OPTION NOINLINE COMPILETIME /br<br>Covert integer to sequence of characters represented as a single word. }</span> <br> <a href="#encodeword:seq.char:word">encodeword</a>. <a href="#tochars:int:seq.char">tochars</a>.n <p> <a id="tochars:int:seq.char" href="#word">Function</a> tochars(n:int) seq.char <br> <span class="keyword">if</span> n <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> [{hyphenchar}char.45] <a href="#">+</a> <a href="#tochars:int:int:seq.char">tochars</a>(n, 10) <span class="keyword">else</span> <a href="#tochars:int:int:seq.char">tochars</a>(-n, 10) <p> <a id="tochars:int:int:seq.char" href="#word">function</a> tochars(n:int, base:int) seq.char <br> <span class="comment">{n should always be negative. This is to handle the smallest integer in the twos complement representation of integers}</span> <br> <span class="keyword">if</span> base <a href="#+:int:int:int">+</a> n <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> [char(48 <a href="#">-</a> n)] <br> <span class="keyword">else</span> <span class="block"> <a href="#tochars:int:int:seq.char">tochars</a>(n <a href="#/:int:int:int">/</a> base, base) <br> <a href="#">+</a> char(48 <a href="#+:int:int:int">+</a> n <a href="#/:int:int:int">/</a> base <a href="#*:int:int:int">*</a> base <a href="#">-</a> n)</span> <p> <a id="toint:word:int" href="#word">Function</a> toint(w:word) int <br> <span class="comment">{Convert an integer represented as a word to an int}</span> <br> <a href="#cvttoint:seq.char:int">cvttoint</a>. <a href="#decodeword:word:seq.char">decodeword</a>.w <p> <a id="cvttoint:seq.char:int" href="#word">Function</a> cvttoint(s:seq.char) int <br> <span class="comment">{Hex values starting with 0x or 0X are allowed. }</span> <br> <span class="keyword">if</span> n.s <a href="#>:int:int:boolean">></a> 2 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> 2 <br> <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"Xx"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> b = 0x0, c ∈ s <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> i = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i, 0, 9) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits.i <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i2 = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"a"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i2, 0, 5) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits(i2 <a href="#+:int:int:int">+</a> 10) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i3 = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"A"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i3, 0, 5) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits(i3 <a href="#+:int:int:int">+</a> 10) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> c <br> <a href="#">∈</a> [ <span class="block"> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"x"</span> <br>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"X"</span> <br>, {no breack space}char.160</span>] <span class="keyword">report</span> <span class="literal">"invalid hex digit"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s, <br>b,</span></span></span></span> toint.b</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> val = 0, c ∈ s <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> i = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i, 0, 9) <span class="keyword">then</span> val <a href="#*:int:int:int">*</a> 10 <a href="#">-</a> i <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> c <a href="#">∈</a> [ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span>, {no breack space}char.160] <span class="keyword">report</span> <span class="literal">"invalid digit"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s <a href="#">+</a> stacktrace, <br>val</span></span> <span class="comment">{Since there are more negative numbers in twos-complement we calculate using negative values. }</span> <br> <span class="keyword">if</span> val <a href="#=:int:int:boolean">=</a> 0 <br> <a href="#∨:boolean:boolean:boolean">∨</a> s <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span> <span class="keyword">then</span> val <br> <span class="keyword">else</span> -val</span> <p> <a id="char1:seq.word:char" href="#word">Function</a> char1(s:seq.word) char <br> <span class="comment">{* First character of first word of s}</span> <br>( <a href="#decodeword:word:seq.char">decodeword</a>.s <a href="#sub:seq.T:int:T">sub</a> 1) <br> <a href="#sub:seq.T:int:T">sub</a> 1 <p> <span class="keyword" id="xxhash">Module</span> xxhash <p>use bits <p>use kernal <p> <a id="rotateleft:bits:int:bits" href="#xxhash">Function</a> rotateleft(x:bits, n:int) bits <br>x <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> n <a href="#∨:bits:bits:bits">∨</a> x <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> n) <p> <a id="hash:bits:int:bits" href="#xxhash">Function</a> hash(acc:bits, x:int) bits <br> <span class="comment">{after xxhash /br<br>example use to hash x and y finalmix(hash(hash(hashstart(seed), x), y))}</span> <br> <span class="keyword">let</span> PRIME1 = 11400714785074694791 <br> <span class="keyword">let</span> PRIME2 = 14029467366897019727 <br> <span class="keyword">let</span> PRIME4 = 9650029242287828579, <br>bits( <span class="block">toint. <a href="#rotateleft:bits:int:bits">rotateleft</a>( <span class="block">acc <br> <a href="#⊻:bits:bits:bits">⊻</a> bits( <span class="block">toint. <a href="#rotateleft:bits:int:bits">rotateleft</a>( <span class="block">bits(toint.acc <a href="#+:int:int:int">+</a> x <a href="#*:int:int:int">*</a> PRIME2) <br>, 31</span>) <br> <a href="#*:int:int:int">*</a> PRIME1</span>) <br>, 27</span>) <br> <a href="#*:int:int:int">*</a> PRIME1 <br> <a href="#+:int:int:int">+</a> PRIME4</span>) <p> <a id="hashstart:int:bits" href="#xxhash">Function</a> hashstart(seed:int) bits <br> <span class="keyword">let</span> PRIME5 = 2870177450012600261, <br>bits(seed <a href="#+:int:int:int">+</a> PRIME5 <a href="#+:int:int:int">+</a> 64) <p> <a id="hashstart:bits" href="#xxhash">Function</a> hashstart bits <a href="#hashstart:int:bits">hashstart</a>.0 <p> <a id="finalmix:bits:int" href="#xxhash">Function</a> finalmix(acc:bits) int <br> <span class="keyword">let</span> PRIME2 = 14029467366897019727 <br> <span class="keyword">let</span> PRIME3 = 1609587929392839161 <br> <span class="keyword">let</span> acc1 = <span class="block">bits( <span class="block">toint(acc <a href="#⊻:bits:bits:bits">⊻</a> acc <a href="#>>:bits:int:bits">>></a> 33) <br> <a href="#*:int:int:int">*</a> PRIME2</span>)</span> <span class="keyword">let</span> acc2 = <span class="block">bits( <span class="block">toint(acc1 <a href="#⊻:bits:bits:bits">⊻</a> acc1 <a href="#>>:bits:int:bits">>></a> 29) <br> <a href="#*:int:int:int">*</a> PRIME3</span>),</span> <a href="#abs:int:int">abs</a>.toint(acc2 <a href="#⊻:bits:bits:bits">⊻</a> acc2 <a href="#>>:bits:int:bits">>></a> 32) <p> <a id="rotl32:bits:int:bits" href="#xxhash">Function</a> rotl32(x:bits, n:int) bits <br>0xFFFF FFFF <a href="#∧:bits:bits:bits">∧</a> (x <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> n <a href="#∨:bits:bits:bits">∨</a> x <a href="#>>:bits:int:bits">>></a> (32 <a href="#">-</a> n)) <p> <a id="hash32:bits:int:bits" href="#xxhash">Function</a> hash32(hash:bits, key:int) bits <br> <a href="#rotl32:bits:int:bits">rotl32</a>( <span class="block">bits(toint.hash <a href="#+:int:int:int">+</a> toint(bits.2246822519 <a href="#*:bits:int:bits">*</a> key)) <br>, 13</span>) <br> <a href="#*:bits:int:bits">*</a> 2654435761 <p> <a id="*:bits:int:bits" href="#xxhash">Function</a> *(a:bits, b:int) bits <br> <span class="keyword">let</span> m = toint(bits.b <a href="#∨:bits:bits:bits">∨</a> bits.0) <br> <span class="keyword">let</span> nlo = toint(a <a href="#∧:bits:bits:bits">∧</a> 0xFFFF) <br> <span class="keyword">let</span> nhi = toint(a <a href="#∧:bits:bits:bits">∧</a> 0xFFFF <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 16), <br>bits( <span class="block">toint(bits(nhi <a href="#*:int:int:int">*</a> m) <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF) <br> <a href="#+:int:int:int">+</a> nlo <a href="#*:int:int:int">*</a> m</span>) <br> <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF <p> <a id="finalmix32:bits:int" href="#xxhash">Function</a> finalmix32(hash:bits) int <br> <span class="keyword">let</span> h32c = <span class="block">(hash <a href="#⊻:bits:bits:bits">⊻</a> hash <a href="#>>:bits:int:bits">>></a> 15) <br> <a href="#*:bits:int:bits">*</a> 668265263</span> <span class="keyword">let</span> h32d = <span class="block">(h32c <a href="#⊻:bits:bits:bits">⊻</a> h32c <a href="#>>:bits:int:bits">>></a> 13) <br> <a href="#*:bits:int:bits">*</a> 374761393,</span> <a href="#abs:int:int">abs</a>.toint( <span class="block">(h32d <a href="#⊻:bits:bits:bits">⊻</a> h32d <a href="#>>:bits:int:bits">>></a> 16) <br> <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF</span>) <p> <a id="hashstart32:int:bits" href="#xxhash">Function</a> hashstart32(seed:int) bits <br> <span class="keyword">let</span> PRIME5 = 374761393, <br>bits(seed <a href="#+:int:int:int">+</a> PRIME5) <p> <a id="hash:int:int" href="#xxhash">Function</a> hash(i:int) int <br> <a href="#finalmix:bits:int">finalmix</a>. <a href="#hash:bits:int:bits">hash</a>( <a href="#hashstart:bits">hashstart</a>, i) <p> <span class="keyword" id="seq1">Module</span> seq1.T <p>use seq.T <p>use seq.seq.T <p>use seq.int <p>use kernal <p>use word <p>use seq.word <p> <span class="keyword">Export</span> type:arithmeticseq.T <p> <span class="keyword">Export</span> type:seq.T{From seq.T} <p> <span class="keyword">Export</span> isempty(a:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> ispseq(s:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> n(a:seq.T) int{From seq.T} <p> <span class="keyword">Export</span> sub(s:seq.T, i:int) T <p> <span class="keyword">Export</span> +(a:seq.T, b:seq.T) seq.T{From seq.T} <p> <span class="keyword">Export</span> +(l:seq.T, a:T) seq.T{From seq.T} <p> <span class="keyword">Export</span> &lt;&lt;(s:seq.T, i:int) seq.T{* removes i elements from beginning of s}{From seq.T} <p> <span class="keyword">Export</span> =(a:seq.T, b:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> >>(s:seq.T, i:int) seq.T{* removes i elements from end of s}{From seq.T} <p> <span class="keyword">Export</span> last(seq.T) T <p> <span class="keyword">Export</span> empty:seq.T seq.T{From seq.T} <p> <span class="keyword">Export</span> lookup(s:seq.T, T) seq.T{From seq.T} <p> <span class="keyword">Export</span> subseq(s:seq.T, start:int, finish:int) seq.T{From seq.T} <p> <span class="keyword">Export</span> ∈(a:T, s:seq.T) boolean{From seq.T} <p> <a id="reverse:seq.T:seq.T" href="#seq1">Function</a> reverse(s:seq.T) seq.T <br> <span class="keyword">for</span> acc = empty:seq.T, i = n.s <br> <span class="keyword">while</span> i <a href="#>:int:int:boolean">></a> 0 <br> <span class="keyword">do</span> next(acc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#">-</a> 1), <br>acc <p>type cseq is sequence, element:T <p> <a id="sequenceIndex:cseq.T:int:T" href="#seq1">function</a> sequenceIndex(s:cseq.T, i:int) T element.s <p> <a id="constantseq:int:T:seq.T" href="#seq1">Function</a> constantseq(len:int, element:T) seq.T toseq.cseq(len, element) <p>type patternseq is sequence, patternlen:int, elements:seq.T <p> <a id="sequenceIndex:patternseq.T:int:T" href="#seq1">function</a> sequenceIndex(s:patternseq.T, i:int) T <br>(elements.s) <br> <a href="#sub:seq.T:int:T">sub</a> ((i <a href="#">-</a> 1) <a href="#mod:int:int:int">mod</a> patternlen.s <a href="#+:int:int:int">+</a> 1) <p> <a id="patternseq:int:seq.T:seq.T" href="#seq1">Function</a> patternseq(len:int, element:seq.T) seq.T <br>toseq.patternseq(len, n.element, element) <p> <a id="replace:seq.T:int:T:seq.T" href="#seq1">Function</a> replace(s:seq.T, index:int, value:T) seq.T <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#ispseq:seq.T:boolean">ispseq</a>.s <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> acc = empty:seq.T, i = 1 <br> <span class="keyword">while</span> i <a href="#&lt;:int:int:boolean">&lt;</a> index <br> <span class="keyword">do</span> next(acc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">for</span> oldacc = acc <a href="#">+</a> value, j = index <a href="#+:int:int:int">+</a> 1 <br> <span class="keyword">while</span> j ≤ n.s <br> <span class="keyword">do</span> next(oldacc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> j, j <a href="#+:int:int:int">+</a> 1), <br>oldacc</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = to:pseq.T(s), <br> <span class="keyword">if</span> index <a href="#>:int:int:boolean">></a> n.a.p <span class="keyword">then</span> a.p <a href="#">+</a> <a href="#">replace</a>(b.p, index <a href="#">-</a> n.a.p, value) <br> <span class="keyword">else</span> <a href="#">replace</a>(a.p, index, value) <a href="#">+</a> b.p</span> <p> <span class="keyword">Export</span> type:arithmeticseq.T <p> <span class="keyword">Export</span> arithmeticseq(int, step:T, start:T) arithmeticseq.T <p> <span class="keyword">Export</span> step(arithmeticseq.T) T <p> <span class="keyword">Export</span> start(arithmeticseq.T) T <p> <span class="keyword">Export</span> toseq(arithmeticseq.T) seq.T <p>type arithmeticseq is sequence, step:T, start:T <p> <span class="keyword">unbound</span> +(T, T) T <p> <span class="keyword">unbound</span> *(int, T) T <p> <span class="keyword">unbound</span> =(T, T) boolean <p> <a id="sequenceIndex:arithmeticseq.T:int:T" href="#seq1">Function</a> sequenceIndex(s:arithmeticseq.T, i:int) T <br>start.s <a href="#">+</a> (i <a href="#">-</a> 1) <a href="#">*</a> step.s <p> <a id="arithseq:int:T:T:seq.T" href="#seq1">Function</a> arithseq(length:int, step:T, start:T) seq.T <br>toseq.arithmeticseq(length, step, start) <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id=">1:seq.T:seq.T:ordering" href="#seq1">Function</a> >1(a:seq.T, b:seq.T) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> lengtha <a href="#>:int:int:boolean">></a> lengthb <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if lengtha <a href="#&lt;:int:int:boolean">&lt;</a> lengthb <span class="keyword">then</span> <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> <a href="#subcmp:seq.T:seq.T:int:ordering">subcmp</a>(a, b, 1) <p> <a id="subcmp:seq.T:seq.T:int:ordering" href="#seq1">function</a> subcmp(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmp:seq.T:seq.T:int:ordering">subcmp</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <p> <span class="keyword">unbound</span> >2(T, T) ordering <p>precedence > for >1 >2 >3 >4 >alpha <p> <a id=">2:seq.T:seq.T:ordering" href="#seq1">Function</a> >2(a:seq.T, b:seq.T) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> lengtha <a href="#>:int:int:boolean">></a> lengthb <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if lengtha <a href="#&lt;:int:int:boolean">&lt;</a> lengthb <span class="keyword">then</span> <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> <a href="#subcmp2:seq.T:seq.T:int:ordering">subcmp2</a>(a, b, 1) <p> <a id="subcmp2:seq.T:seq.T:int:ordering" href="#seq1">function</a> subcmp2(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>2</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmp2:seq.T:seq.T:int:ordering">subcmp2</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="binarysearch:seq.T:T:int" href="#seq1">Function</a> binarysearch(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, 1, n.s, val) <p> <a id="binarysearch:seq.T:int:int:T:int" href="#seq1">Function</a> binarysearch(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">assert</span> b <a href="#>:int:int:boolean">></a> 0 <a href="#∧:boolean:boolean:boolean">∧</a> a ≤ n.s <span class="keyword">report</span> <span class="literal">"out of bounds in binary search"</span>, <br> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, b, a, val) <p> <a id="binarysearchNB:seq.T:int:int:T:int" href="#seq1">Function</a> binarysearchNB(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = idxNB(s, p) <a href="#">>1</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <a id="setinsert:seq.T:T:seq.T" href="#seq1">Function</a> setinsert(s:seq.T, val:T) seq.T <br> <span class="comment">{* assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> s <br> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, -i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, -i, n.s)</span> <p> <a id="setdelete:seq.T:T:seq.T" href="#seq1">Function</a> setdelete(s:seq.T, val:T) seq.T <br> <span class="comment">{* assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s)</span> <span class="keyword">else</span> s <p> <a id="setreplaceorinsert:seq.T:T:seq.T" href="#seq1">Function</a> setreplaceorinsert(s:seq.T, val:T) seq.T <br> <span class="comment">{assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s)</span> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, -i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, -i, n.s)</span> <p> <a id="lpad:int:T:seq.T:seq.T" href="#seq1">Function</a> lpad(n:int, val:T, l:seq.T) seq.T <br> <a href="#constantseq:int:T:seq.T">constantseq</a>(n <a href="#">-</a> n.l, val) <a href="#">+</a> l <p> <a id="break:T:seq.T:seq.seq.T" href="#seq1">Function</a> break(w:T, a:seq.T) seq.seq.T <a href="#">break</a>(w, empty:seq.T, a) <p> <a id="break:T:seq.T:seq.T:seq.seq.T" href="#seq1">Function</a> break(seperator:T, quotes:seq.T, a:seq.T) seq.seq.T <br> <span class="keyword">for</span> acc = empty:seq.int, i = 1, e ∈ a <br> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <a href="#">+</a> ( <span class="keyword">if</span> e <a href="#">∈</a> ([seperator] <a href="#">+</a> quotes) <span class="keyword">then</span> [i] <span class="keyword">else</span> empty:seq.int) <br>, i <a href="#+:int:int:int">+</a> 1</span>),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.acc <span class="keyword">then</span> [a] <br> <span class="keyword">else</span> <a href="#">break</a>(empty:seq.T, seperator, seperator, a, acc, 1, 1, empty:seq.seq.T) <p> <a id="break:seq.T:T:T:seq.T:seq.int:int:int:seq.seq.T:seq.seq.T" href="#seq1">function</a> break( <br>str:seq.T <br>, currentquote:T <br>, seperator:T <br>, a:seq.T <br>, b:seq.int <br>, j:int <br>, start:int <br>, result:seq.seq.T <br>) seq.seq.T <br> <span class="keyword">if</span> j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, n.a)) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> currentquote ≠ seperator <span class="keyword">then</span> <span class="block">{in quoted string} <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> seperator <span class="keyword">then</span> <a href="#">break</a>(str, currentquote, seperator, a, b, j <a href="#+:int:int:int">+</a> 1, start, result) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> currentquote <a href="#∧:boolean:boolean:boolean">∧</a> i <a href="#=:int:int:boolean">=</a> n.a <span class="keyword">then</span> result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1)) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> currentquote <br> <a href="#∧:boolean:boolean:boolean">∧</a> a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#+:int:int:int">+</a> 1) <a href="#">=</a> currentquote <span class="keyword">then</span> <span class="block"> <a href="#">break</a>( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i) <br>, currentquote <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 2 <br>, i <a href="#+:int:int:int">+</a> 2 <br>, result</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> a <a href="#sub:seq.T:int:T">sub</a> i ≠ seperator <br> <a href="#∧:boolean:boolean:boolean">∧</a> a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#+:int:int:int">+</a> 1) <a href="#">=</a> seperator <span class="keyword">report</span> <span class="literal">"Format problem"</span>, <br> <a href="#">break</a>( <span class="block">empty:seq.T <br>, seperator <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 2 <br>, i <a href="#+:int:int:int">+</a> 2 <br>, result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1))</span>)</span></span> <span class="keyword">else</span> <span class="block">{not in quoted string} <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> seperator <span class="keyword">then</span> <span class="block"> <a href="#">break</a>( <span class="block">empty:seq.T <br>, seperator <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 1 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1))</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> <a href="#isempty:seq.T:boolean">isempty</a>(str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1)) <span class="keyword">report</span> <span class="literal">"Format problem"</span>, <br> <a href="#">break</a>(str, a <a href="#sub:seq.T:int:T">sub</a> i, seperator, a, b, j <a href="#+:int:int:int">+</a> 1, i <a href="#+:int:int:int">+</a> 1, result)</span></span></span> <p> <a id="findindex:seq.T:T:int" href="#seq1">Function</a> findindex(s:seq.T, w:T) int <br> <span class="comment">{result > length.s when element is not found.Otherwise results is location in sequence}</span> <br> <span class="keyword">for</span> i = 1, e ∈ s <span class="keyword">while</span> e ≠ w <span class="keyword">do</span> i <a href="#+:int:int:int">+</a> 1, <br>i <p> <span class="keyword">unbound</span> =(T, T) boolean <p>------------------------------- <p> <span class="keyword">unbound</span> %(T) seq.word <p> <a id="%:seq.word:seq.T:seq.word" href="#seq1">Function</a> %(term:seq.word, z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, i ∈ z <span class="keyword">do</span> acc <a href="#">+</a> <a href="#">%</a>.i <a href="#">+</a> term, <br>acc <p> <a id="%:seq.T:seq.word" href="#seq1">Function</a> %(z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, i ∈ z <span class="keyword">do</span> acc <a href="#">+</a> <a href="#">%</a>.i, <br>acc <p> <a id="%n:seq.T:seq.word" href="#seq1">Function</a> %n(z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, idx = 1, i ∈ z <br> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <a href="#">+</a> <span class="literal">"/br"</span> <a href="#">+</a> <a href="#toword:int:word">toword</a>.idx <a href="#">+</a> <span class="literal">":"</span> <a href="#">+</a> <a href="#">%</a>.i <br>, idx <a href="#+:int:int:int">+</a> 1</span>),</span> acc <p> <span class="keyword" id="sort">Module</span> sort.T <p>use standard <p>use seq.T <p>use set.T <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="sort:seq.T:seq.T" href="#sort">Function</a> sort(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#">merge</a>( <span class="block"> <a href="#sort:seq.T:seq.T">sort</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort:seq.T:seq.T">sort</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge:seq.T:seq.T:seq.T" href="#sort">Function</a> merge(a:seq.T, b:seq.T) seq.T <br> <span class="comment">{* combines sorted seq}</span> <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>1</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#">>1</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#">>1</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <a id="sort>3:seq.T:seq.T" href="#sort">Function</a> sort>3(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>3:seq.T:seq.T:seq.T">merge>3</a>( <span class="block"> <a href="#sort>3:seq.T:seq.T">sort>3</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>3:seq.T:seq.T">sort>3</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>3:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>3(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>3</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>3</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#">>3</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#">>3</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >3(T, T) ordering <p> <a id="sort>4:seq.T:seq.T" href="#sort">Function</a> sort>4(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>4:seq.T:seq.T:seq.T">merge>4</a>( <span class="block"> <a href="#sort>4:seq.T:seq.T">sort>4</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>4:seq.T:seq.T">sort>4</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>4:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>4(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 >4 a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 >4 b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 >4 aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval >4 a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >4(T, T) ordering <p> <a id="sort>alpha:seq.T:seq.T" href="#sort">Function</a> sort>alpha(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>alpha:seq.T:seq.T:seq.T">merge>alpha</a>( <span class="block"> <a href="#sort>alpha:seq.T:seq.T">sort>alpha</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>alpha:seq.T:seq.T">sort>alpha</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>alpha:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>alpha(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>alpha</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>alpha</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#">>alpha</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#">>alpha</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >alpha(T, T) ordering <p> <a id=">alpha:seq.T:seq.T:ordering" href="#sort">Function</a> >alpha(a:seq.T, b:seq.T) ordering <a href="#subcmpalpha:seq.T:seq.T:int:ordering">subcmpalpha</a>(a, b, 1) <p> <a id="subcmpalpha:seq.T:seq.T:int:ordering" href="#sort">function</a> subcmpalpha(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> i ≤ lengtha <a href="#∧:boolean:boolean:boolean">∧</a> i ≤ lengthb <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>alpha</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmpalpha:seq.T:seq.T:int:ordering">subcmpalpha</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <span class="keyword">else</span> if n.a <a href="#=:int:int:boolean">=</a> n.b <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> if n.a <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> <a href="#LT:ordering">LT</a> <p> <span class="keyword">unbound</span> >2(T, T) ordering <p> <a id="binarysearch>2:seq.T:T:int" href="#sort">Function</a> binarysearch>2(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, 1, n.s, val) <p> <a id="binarysearch2:seq.T:int:int:T:int" href="#sort">Function</a> binarysearch2(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = s <a href="#sub:seq.T:int:T">sub</a> p <a href="#">>2</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <a id="binarysearch>3:seq.T:T:int" href="#sort">Function</a> binarysearch>3(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#">binarysearch>3</a>(s, 1, n.s, val) <p> <a id="binarysearch>3:seq.T:int:int:T:int" href="#sort">Function</a> binarysearch>3(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = s <a href="#sub:seq.T:int:T">sub</a> p <a href="#">>3</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#">binarysearch>3</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#">binarysearch>3</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <span class="keyword" id="textio">Module</span> textio <p>use UTF8 <p>use seq.UTF8 <p>use bits <p>use seq1.byte <p>use standard <p>use toWords <p> <span class="keyword">Export</span> type:UTF8{From UTF8} <p> <span class="keyword">Export</span> towords(a:UTF8) seq.word{From toWords} <p> <span class="keyword">Export</span> breakparagraph(input:seq.byte) seq.seq.word{From toWords} <p> <span class="keyword">Export</span> fromHTML(bytes:seq.byte) seq.seq.word <br>{input is broken into paragraphs when each paragraph is either an HTML element or is text. Paragraphs of text end with a double quote.} <p> <a id="breaklines:UTF8:seq.UTF8" href="#textio">Function</a> breaklines(a:UTF8) seq.UTF8 <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(toseqbyte.a, 2, 1, empty:seq.UTF8) <p> <a id="breaklines:seq.byte:seq.UTF8" href="#textio">Function</a> breaklines(a:seq.byte) seq.UTF8 <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(a, 2, 1, empty:seq.UTF8) <p> <a id="breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8" href="#textio">function</a> breaklines(a:seq.byte, i:int, last:int, result:seq.UTF8) seq.UTF8 <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <br> <span class="keyword">else</span> if <a href="#toint:byte:int">toint</a>.a <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:int:int:boolean">=</a> 10 <span class="keyword">then</span> <span class="block"> <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>( <span class="block">a <br>, i <a href="#+:int:int:int">+</a> 1 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, result <br> <a href="#">+</a> UTF8. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">a <br>, last <br>, i <br> <a href="#">-</a> ( <span class="keyword">if</span> <a href="#toint:byte:int">toint</a>.a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#">-</a> 1) <br> <a href="#=:int:int:boolean">=</a> 13 <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> 1)</span>)</span>)</span> <span class="keyword">else</span> <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(a, i <a href="#+:int:int:int">+</a> 1, last, result) <p> <a id="breakcommas:UTF8:seq.UTF8" href="#textio">Function</a> breakcommas(a:UTF8) seq.UTF8 <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.UTF8 <br>, @e ∈ break( <span class="block"> <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">","</span> <br>, [ <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <a href="#">dq</a>] <br>, toseqbyte.a</span>)</span> <span class="keyword">do</span> acc <a href="#">+</a> UTF8.@e, <br>acc <p> <span class="keyword" id="file">Module</span> file <p>use UTF8 <p>use bits <p>use seq.byte <p>use seq1.char <p>use seq.seq.char <p>use seq.filename <p>use format1a <p>use markup <p>use standard <p>use textio <p>use seq.seq.word <p> <span class="keyword">Export</span> type:file <p> <span class="keyword">Export</span> fn(file) filename <p> <span class="keyword">Export</span> rawdata(file) seq.seq.byte <p> <span class="keyword">Export</span> response(file) UTF8 <p> <span class="keyword">Export</span> file(fn:filename, rawdata:seq.seq.byte, response:UTF8) file <p> <span class="keyword">Export</span> type:filename <p> <span class="keyword">Export</span> dirpath(filename) word <p> <span class="keyword">Export</span> ext(filename) word <p> <span class="keyword">Export</span> name(filename) word <p> <a id="HTMLformat1:seq.word:UTF8" href="#file">Function</a> HTMLformat1(myinput:seq.word) UTF8 <br> <a href="#HTMLformat1a:seq.word:UTF8">HTMLformat1a</a>.myinput <p> <a id="textFormat1:seq.word:UTF8" href="#file">Function</a> textFormat1(myinput:seq.word) UTF8 <br> <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>.myinput <p> <a id="HTMLformat:seq.word:UTF8" href="#file">Function</a> HTMLformat(s:seq.word) UTF8 <a href="#HTMLformat1:seq.word:UTF8">HTMLformat1</a>.s <p> <a id="textformat:seq.word:UTF8" href="#file">Function</a> textformat(s:seq.word) UTF8 <a href="#textFormat1:seq.word:UTF8">textFormat1</a>.s <p>type filename is dirpath:word, name:word, ext:word <p> <a id="fullname:filename:word" href="#file">Function</a> fullname(fn:filename) word <br> <a href="#">merge</a>( <span class="block"> <span class="keyword">if</span> dirpath.fn <a href="#">∈</a> <span class="literal">"."</span> <span class="keyword">then</span> [name.fn, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1, ext.fn] <br> <span class="keyword">else</span> [dirpath.fn, <span class="literal">"/"</span> <a href="#sub:seq.T:int:T">sub</a> 1, name.fn, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1, ext.fn]</span>) <p>type file is fn:filename, rawdata:seq.seq.byte, response:UTF8 <p> <a id="data:file:seq.byte" href="#file">Function</a> data(f:file) seq.byte <br> <span class="keyword">for</span> acc = empty:seq.byte, e ∈ rawdata.f <span class="keyword">do</span> acc <a href="#">+</a> e, <br>acc <p> <a id="getname:seq.word:filename" href="#file">function</a> getname(name:seq.word) filename <br> <span class="keyword">let</span> fns = <a href="#tofilenames:seq.word:seq.filename">tofilenames</a>.name <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.fns <span class="keyword">report</span> <span class="literal">"no file name specified"</span>, <br>fns <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="file:seq.word:seq.word:file" href="#file">Function</a> file(name:seq.word, out:seq.word) file <br> <a href="#file:filename:seq.word:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, out) <p> <a id="file:seq.word:seq.UTF8:file" href="#file">Function</a> file(name:seq.word, out:seq.UTF8) file <br> <span class="keyword">for</span> bytes = empty:seq.byte, e ∈ out <span class="keyword">do</span> bytes <a href="#">+</a> toseqbyte.e, <br> <a href="#file:filename:seq.byte:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, bytes) <p> <a id="file:seq.word:seq.byte:file" href="#file">Function</a> file(name:seq.word, bytes:seq.byte) file <br> <a href="#file:filename:seq.byte:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, bytes) <p>use markup <a id="file:filename:seq.word:file" href="#file">Function</a> file(fn:filename, out:seq.word) file <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> bytes = <span class="keyword">if</span> ext.fn <a href="#">∈</a> <span class="literal">"html"</span> <span class="keyword">then</span> toseqbyte. <a href="#processTXT:seq.seq.word:seq.classinfo:boolean:seq.word:UTF8">processTXT</a>([ <p>"//../tau.css /link /head /sp /tag &lt;table /tag > /nsp /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal

 <p>// // ptr /id Module /keyword ptr

 <p>Export /keyword type:ptr

 <p>Builtin /keyword // allocatespace

 <p>type ptr is xx:int

 <p>// // indirect /id Module /keyword indirect.T

 <p>Export /keyword type:indirect.T

 <p>type indirect is value:seq.T

 <p>Builtin /keyword indirect(T) indirect.T

 <p>Builtin /keyword fromindirect(indirect.T) T

 <p>// // PEGrules /id Module /keyword PEGrules

 <p>use UTF8

 <p>use bits

 <p>use seq.int

 <p>use seq1.oneRule

 <p>use set.oneRule

 <p>use seq1.pegpart

 <p>use seq.pegpart

 <p>use seq1.pegrule

 <p>use set.pegrule

 <p>use standard

 <p>use seq.state

 <p>use seq1.tableEntry

 <p>use seq1.word

 <p>use set.word

 <p>use sort.word

 <p>Export /keyword state(i:int) state

 <p>Export /keyword type:pegpart

 <p>Export /keyword part(pegpart) seq.word

 <p>Export /keyword replacement(pegpart) seq.word

 <p>Export /keyword pegpart(part:seq.word, replacement:seq.word) pegpart

 <p>Export /keyword type:pegrule

 <p>Export /keyword begin(pegrule) state

 <p>Export /keyword kind(pegrule) word

 <p>Export /keyword leftside(pegrule) word

 <p>Export /keyword parts(pegrule) seq.pegpart

 <p>Export /keyword pegrule(word, word, seq.pegpart, int, state) pegrule

 <p>Export /keyword type:state

 <p>Export /keyword toint(state) int

 <p>Export /keyword type:tableEntry

 <p>Export /keyword Fstate(tableEntry) state

 <p>Export /keyword Sstate(tableEntry) state

 <p>Export /keyword action(tableEntry) state

 <p>Export /keyword match(tableEntry) word

 <p>Export /keyword recover(tableEntry) seq.word

 <p>Export /keyword tableEntry(<br>action:state<br>, match:word<br>, Sstate:state<br>, Fstate:state<br>, recover:seq.word<br>) tableEntry<br>

 <p>Export /keyword ∈(state, seq.state) boolean{From seq.state}

 <p>Function // adjust:seq.pegrule:seq.pegrule /id // #PEGrules /href /a adjust(g:seq.pegrule) seq.pegrule<br>// for /keyword // rZ = // //#empty::set.T:set.T /href empty:set.word /a<br>, r!Z = // //#empty::set.T:set.T /href empty:set.word /a<br>, NonT = // //#empty::set.T:set.T /href empty:set.word /a<br>, NonT* = // //#empty::set.T:set.T /href empty:set.word /a<br>, begin = // //#state:state:int:state /href state /a(// //#Idx:state /href Idx /a, 2)<br>, newg1 = empty:seq.pegrule<br>, r ∈ g /block // do /keyword // // for /keyword pZ = //""/literal, p!Z = //""/literal, p ∈ parts.r<br>// do /keyword // // for /keyword eZ = pZ, e!Z = p!Z, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, e ∈ part.p<br>// do /keyword // // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword next(eZ, e!Z, e)<br>// else /keyword if last // //#/href ∈ /a //"!"/literal // then /keyword next(eZ, e!Z // //#/href+/a e, e)<br>// else /keyword next(eZ // //#/href+/a e, e!Z, e), /block next(eZ, e!Z)/block // assert /keyword leftside.r ∉ NonT // //#/href ∪ /a NonT* // report /keyword //"Duplicate Non-Terminal::(leftside.r):(// //#%:int:seq.pegrule:seq.word /href % /a(2, g))"/literal<br>// let /keyword noStates = n.pZ // //#+:int:int:int /href+/a n.p!Z,<br>// let /keyword newg = newg1 // //#/href+/a pegrule(kind.r, leftside.r, parts.r, noStates, begin),<br>// if /keyword kind.r // //#/href ∈ /a //"*+"/literal // then /keyword // next(// rZ // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.pZ<br>, r!Z // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.p!Z<br>, NonT<br>, NonT* // //#+:set.T:T:set.T /href+/a leftside.r<br>, begin // //#+:state:int:state /href+/a noStates<br>, newg /block)/block // else /keyword // next(// rZ // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.pZ<br>, r!Z // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.p!Z<br>, NonT // //#+:set.T:T:set.T /href+/a leftside.r<br>, NonT*<br>, begin // //#+:state:int:state /href+/a noStates<br>, newg /block)/block /block // assert /keyword // //#isempty:set.T:boolean /href isempty /a(r!Z // //#∩:set.T:set.T:set.T /href ∩ /a NonT*) // report /keyword //"cannot use ! on * Non-terminal"/literal<br>// let /keyword NonT! = NonT // //#∩:set.T:set.T:set.T /href ∩ /a r!Z<br>// let /keyword NonTAdd = NonT! // //#∩:set.T:set.T:set.T /href ∩ /a rZ<br>// let /keyword NonTchange = NonT! // //#\:set.T:set.T:set.T /href \ /a NonTAdd<br>// for /keyword acc = empty:seq.pegrule, add = empty:seq.pegrule, r ∈ newg1<br>// do /keyword // // if /keyword leftside.r // //#/href ∈ /a NonTchange // then /keyword // next(// acc<br> // //#/href+/a pegrule(//"!"/literal // //#sub:seq.T:int:T /href sub /a 1, leftside.r, parts.r, nostates.r, begin.r)<br>, add /block)/block // else /keyword if leftside.r // //#/href ∈ /a NonTAdd // then /keyword next(acc, add // //#/href+/a r)<br>// else /keyword next(acc // //#/href+/a r, add)/block // assert /keyword // //#isempty:seq.T:boolean /href isempty /a.add // report /keyword // //"PEG grammar not implemented using same non-terminal with ! and without ! /sp /tag &lt;br /tag > /nsp<br>NonT!:(toseq.NonT!)/sp /tag &lt;br /tag > /nsp NonTAdd:(toseq.NonTAdd)"/literal, /block acc

 <p>-----------

 <p>function // smallest:set.oneRule:word:seq.word /id // #PEGrules /href /a smallest(costs:set.oneRule, w:word) seq.word<br>// let /keyword l = // //#lookup:set.T:T:set.T /href lookup /a(costs, oneRule(w, //""/literal, false)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.l // then /keyword [w] // else /keyword right.l // //#sub:set.T:int:T /href sub /a 1

 <p>function // smallest:seq.pegrule:set.oneRule /id // #PEGrules /href /a smallest(rules:seq.pegrule) set.oneRule<br>// for /keyword nonTerminals = // //#empty::set.T:set.T /href empty:set.word /a, r ∈ rules<br>// do /keyword nonTerminals // //#+:set.T:T:set.T /href+/a leftside.r<br>// for /keyword acc1 = // //#empty::set.T:set.T /href empty:set.oneRule /a, r ∈ rules<br>// do /keyword // // if /keyword kind.r // //#/href ∈ /a //"*"/literal // then /keyword acc1 // //#+:set.T:T:set.T /href+/a oneRule(leftside.r, //""/literal, true)<br>// else /keyword // // for /keyword acc2 = acc1, p ∈ parts.r<br>// do /keyword // // for /keyword right = //""/literal, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, w ∈ part.p<br>// do /keyword // // if /keyword w // //#/href ∈ /a //"!"/literal // //#∨:boolean:boolean:boolean /href ∨ /a last // //#/href ∈ /a //"!"/literal // then /keyword next(right, w)<br>// else /keyword next(right // //#/href+/a w, w), /block acc2<br> // //#+:set.T:T:set.T /href+/a oneRule(leftside.r, right, // //#isempty:set.T:boolean /href isempty /a(// //#asset:seq.T:set.T /href asset /a.part.p // //#∩:set.T:set.T:set.T /href ∩ /a nonTerminals)), /block acc2 /block /block // for /keyword s = acc1, continue = true<br>// while /keyword continue<br>// do /keyword // // let /keyword f = // //#substitute:set.oneRule:oneRule:oneRule /href substitute /a(s, s // //#sub:set.T:int:T /href sub /a 1)<br>// for /keyword // acc = [f]<br>, last = f<br>, changed = right.f ≠ right.s // //#sub:set.T:int:T /href sub /a 1<br>, e0 ∈ toseq.s // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1 /block // do /keyword // // let /keyword e = // //#substitute:set.oneRule:oneRule:oneRule /href substitute /a(s, e0)<br>// let /keyword newchanged = changed // //#∨:boolean:boolean:boolean /href ∨ /a right.e ≠ right.e0,<br>// if /keyword left.last // //#=:word:word:boolean /href = /a left.e // //#∧:boolean:boolean:boolean /href ∧ /a allTerminals.last // then /keyword // // if /keyword allTerminals.e // then /keyword next(acc, last, true)<br>// else /keyword next(acc // //#/href+/a e, last, newchanged)/block // else /keyword next(acc // //#/href+/a e, e, newchanged), /block next(// //#asset:seq.T:set.T /href asset /a.acc, changed), /block s

 <p>type oneRule is left:word, right:seq.word, allTerminals:boolean

 <p>function // >1:oneRule:oneRule:ordering /id // #PEGrules /href /a >1(a:oneRule, b:oneRule) ordering<br>left.a // //#/href >1 /a left.b // //#∧:ordering:ordering:ordering /href ∧ /a right.a // //#>1:seq.T:seq.T:ordering /href >1 /a right.b

 <p>function // >2:oneRule:oneRule:ordering /id // #PEGrules /href /a >2(a:oneRule, b:oneRule) ordering left.a // //#/href >1 /a left.b

 <p>function // substitute:set.oneRule:oneRule:oneRule /id // #PEGrules /href /a substitute(z:set.oneRule, e:oneRule) oneRule<br>// if /keyword allTerminals.e // then /keyword e<br>// else /keyword // // for /keyword rightNew = //""/literal, all = true, w ∈ right.e<br>// do /keyword // // let /keyword find = // //#findelement2:set.T:T:set.T /href findelement2 /a(z, oneRule(w, [w], false)),<br>// if /keyword // //#n:set.T:int /href n /a.find // //#=:int:int:boolean /href = /a 1 // then /keyword // next(// rightNew // //#/href+/a right.find // //#sub:set.T:int:T /href sub /a 1<br>, all // //#∧:boolean:boolean:boolean /href ∧ /a allTerminals.find // //#sub:set.T:int:T /href sub /a 1 /block)/block // else /keyword next(rightNew // //#/href+/a w, all // //#∧:boolean:boolean:boolean /href ∧ /a // //#n:set.T:int /href n /a.find // //#=:int:int:boolean /href = /a 0), /block oneRule(left.e, rightNew, all)/block

 <p>-------------

 <p>function // %:pegrule:seq.word /id // #PEGrules /href /a %(r:pegrule) seq.word<br>[kind.r, leftside.r]<br> // //#/href+/a // for /keyword acc = //""/literal, e ∈ parts.r // do /keyword acc // //#/href+/a //"/"/literal // //#/href+/a part.e,<br>acc // //#/href+/a //"/sp /tag &lt;br /tag > /nsp"/literal

 <p>type pegrule is kind:word, leftside:word, parts:seq.pegpart, nostates:int, begin:state

 <p>type pegpart is part:seq.word, replacement:seq.word

 <p>type tableEntry is<br>action:state<br>, match:word<br>, Sstate:state<br>, Fstate:state<br>, recover:seq.word

 <p>Function // textGrammar:seq.pegrule:seq.word /id // #PEGrules /href /a textGrammar(g:seq.pegrule) seq.word<br>// for /keyword Non = // //#empty::set.T:set.T /href empty:set.word /a, rightsides = //""/literal, r ∈ g<br>// do /keyword // // for /keyword parts = //""/literal, e ∈ parts.r // do /keyword parts // //#/href+/a part.e,<br>next(Non // //#+:set.T:T:set.T /href+/a leftside.r, rightsides // //#/href+/a parts)/block // let /keyword terms = // // //#asset:seq.T:set.T /href asset /a.rightsides<br> // //#\:set.T:set.T:set.T /href \ /a Non<br> // //#\:set.T:set.T:set.T /href \ /a // //#asset:seq.T:set.T /href asset /a.//"/ ! /sp /tag &lt;br /tag > /nsp<br>"/literal /block // let /keyword unusedNon = // toseq(// Non // //#\:set.T:set.T:set.T /href \ /a // //#asset:seq.T:set.T /href asset /a.rightsides<br> // //#-:set.T:T:set.T /href-/a leftside.g // //#sub:seq.T:int:T /href sub /a 1 /block), /block // //#checkrules:seq.pegrule:seq.word /href checkrules /a.g<br> // //#/href+/a (// if /keyword // //#isempty:seq.T:boolean /href isempty /a.unusedNon // then /keyword //""/literal<br>// else /keyword //"/sp /tag &lt;br /tag > /nsp Unused non-terminals::(unusedNon)"/literal)<br> // //#/href+/a //"/sp /tag &lt;br /tag > /nsp Non-terminals::(// //#sort>alpha:seq.T:seq.T /href sort>alpha /a.toseq.Non)/sp /tag &lt;br /tag > /nsp Terminals::(// //#sort>alpha:seq.T:seq.T /href sort>alpha /a.toseq.terms)"/literal<br> // //#/href+/a // //#%:int:seq.pegrule:seq.word /href % /a(5, g)

 <p>Function // %:int:seq.pegrule:seq.word /id // #PEGrules /href /a %(format:int, newg:seq.pegrule) seq.word<br>//{1 as string 2-as table 3-as table with action 4-as txt 6-as code}/comment<br>// let /keyword action = [//"/action"/literal, //""/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //""/literal, //""/literal, // //#/href dq /a // //#/href+/a //"="/literal] // //#sub:seq.T:int:T /href sub /a format<br>// let /keyword part = [//"/sp /tag &lt;br /tag > /nsp /"/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //"/"/literal, //"/"/literal, //"/sp /tag &lt;br /tag > /nsp,:(// //#/href dq /a)/"/literal] // //#sub:seq.T:int:T /href sub /a format<br>// let /keyword rule = //[// //"/sp /tag &lt;br /tag > /nsp"/literal<br>, //"/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>, //"/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>, //"/sp /tag &lt;br /tag > /nsp:(// //#escapeformat:word /href escapeformat /a)/sp /tag &lt;br /tag > /nsp:(// //#escapeformat:word /href escapeformat /a)"/literal<br>, //"/sp /tag &lt;br /tag > /nsp"/literal<br>, //"/sp /tag &lt;br /tag > /nsp,:(// //#/href dq /a)"/literal /block]<br> // //#sub:seq.T:int:T /href sub /a format /block // let /keyword arrow = [//""/literal, //"/tag &lt;/td> /sp /tag &lt;td /tag > /nsp"/literal, //"/tag &lt;/td> /sp /tag &lt;th /tag > /nsp"/literal, //"←"/literal, //"←"/literal, //""/literal] // //#sub:seq.T:int:T /href sub /a format<br>// for /keyword txt0 = //""/literal, r ∈ newg<br>// do /keyword // // for /keyword txt1 = //""/literal, e ∈ parts.r<br>// do /keyword // txt1<br> // //#/href+/a (part.e<br> // //#/href+/a action<br> // //#/href+/a (// if /keyword // //#isempty:seq.T:boolean /href isempty /a.action // then /keyword //""/literal // else /keyword replacement.e)<br> // //#/href+/a part), /block txt0 // //#>>:seq.T:int:seq.T /href >> /a n.part<br> // //#/href+/a (rule<br> // //#/href+/a (// if /keyword kind.r // //#/href ∈ /a //"*+"/literal // then /keyword [kind.r] // else /keyword //""/literal)<br> // //#/href+/a // //#%:word:seq.word /href % /a.leftside.r<br> // //#/href+/a arrow<br> // //#/href+/a txt1), /block // if /keyword format // //#/href ∈ /a [2, 3] // then /keyword //"left /tag &lt;/th> /sp /tag &lt;th /tag > /nsp right /tag &lt;/th> /sp /tag &lt;th /tag > /nsp action /tag &lt;/th> /tag &lt;/tr>:(txt0)/tag &lt;/table> /sp /tag &lt;table /tag > /nsp /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>// else /keyword if format // //#=:int:int:boolean /href = /a 4 // then /keyword //"function genPEG(attributeType:word)seq.boolean[:(// //#subseq:seq.T:int:int:seq.T /href subseq /a(txt0, 3, n.txt0 // //#/href-/a 3))]"/literal<br>// else /keyword txt0 // //#>>:seq.T:int:seq.T /href >> /a 1

 <p>function // checkrules:seq.pegrule:seq.word /id // #PEGrules /href /a checkrules(g:seq.pegrule) seq.word<br>// let /keyword small = // //#smallest:seq.pegrule:set.oneRule /href smallest /a.g<br>// for /keyword acc = //""/literal, r ∈ g<br>// do /keyword // // if /keyword kind.r ∉ //"*+"/literal // then /keyword //""/literal<br>// else /keyword // // for /keyword message = //""/literal, p ∈ parts.r<br>// do /keyword // // for /keyword isempty = true, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, e ∈ part.p<br>// while /keyword isempty<br>// do /keyword // // if /keyword last // //#/href ∈ /a //"!"/literal // then /keyword next(true, e)<br>// else /keyword // // let /keyword t = // //#lookup:set.T:T:set.T /href lookup /a(small, oneRule(e, //""/literal, true)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.t // then /keyword next(false, e)<br>// else /keyword next(// //#isempty:seq.T:boolean /href isempty /a.right.t // //#sub:set.T:int:T /href sub /a 1, e), /block /block // if /keyword isempty // then /keyword message // //#/href+/a //"illegal rule *:(leftside.r):(part.p)/sp /tag &lt;br /tag > /nsp"/literal // else /keyword message, /block acc // //#/href+/a message, /block /block acc

 <p>function // >1:pegrule:pegrule:ordering /id // #PEGrules /href /a >1(a:pegrule, b:pegrule) ordering<br>leftside.a // //#/href >1 /a leftside.b // //#∧:ordering:ordering:ordering /href ∧ /a kind.a // //#/href ∈ /a //"!"/literal // //#>1:boolean:boolean:ordering /href >1 /a kind.a // //#/href ∈ /a //"!"/literal

 <p>function // =:tableEntry:tableEntry:boolean /id // #PEGrules /href /a =(a:tableEntry, b:tableEntry) boolean<br>action.a // //#=:state:state:boolean /href = /a action.b<br> // //#∧:boolean:boolean:boolean /href ∧ /a Fstate.a // //#=:state:state:boolean /href = /a Fstate.b<br> // //#∧:boolean:boolean:boolean /href ∧ /a Fstate.a // //#=:state:state:boolean /href = /a Fstate.b

 <p>Function // makeTbl:seq.pegrule:boolean:seq.tableEntry /id // #PEGrules /href /a makeTbl(gin:seq.pegrule, recover:boolean) seq.tableEntry<br>// let /keyword small = // // if /keyword recover // then /keyword // //#smallest:seq.pegrule:set.oneRule /href smallest /a.gin<br>// else /keyword // //#empty::set.T:set.T /href empty:set.oneRule /a /block // let /keyword gset = // //#asset:seq.T:set.T /href asset /a.gin<br>// for /keyword lambdas = //""/literal, r ∈ gin<br>// do /keyword // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.part.(parts.r) // //#sub:seq.T:int:T /href sub /a 1 // then /keyword lambdas // //#/href+/a leftside.r<br>// else /keyword lambdas /block // for /keyword // table = [// tableEntry(// // //#NT:int:state /href NT /a.2<br>, //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#Match:state /href Match /a<br>, // //#Failure:state /href Failure /a<br>, //""/literal /block)/block]<br>, reduce0 = 2<br>, s ∈ gin /block // do /keyword // // for /keyword isAll* = kind.s // //#/href ∈ /a //"*+"/literal, p ∈ parts.s<br>// while /keyword isAll*<br>// do /keyword replacement.p // //#=:seq.T:seq.T:boolean /href = /a //"/All"/literal<br>// for /keyword // lastnextstate2 = // //#/href NT /a<br>, nextstate2 = begin.s<br>, ruletable = table<br>, partno = 1<br>, lastpart = (parts.s) // //#sub:seq.T:int:T /href sub /a 1<br>, p ∈ parts.s /block // do /keyword // // let /keyword reduce = partno // //#+:int:int:int /href+/a reduce0 // //#/href-/a 1<br>// for /keyword nextpart = nextstate2, e ∈ part.p<br>// do /keyword // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword nextpart // else /keyword nextpart // //#+:state:int:state /href+/a 1,<br>// for /keyword // parttable = ruletable<br>, thisstate = nextstate2<br>, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, count = 1<br>, e ∈ part.p /block // do /keyword // // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword next(parttable, thisstate, e, count // //#+:int:int:int /href+/a 1)<br>// else /keyword // // let /keyword success1 = // // if /keyword count // //#=:int:int:boolean /href = /a n.part.p // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword // //#!Reduce:state /href !Reduce /a<br>// else /keyword if replacement.p // //#=:seq.T:seq.T:boolean /href = /a //"/All"/literal // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // if /keyword isAll* // then /keyword // //#/href Discard* /a.begin.s // else /keyword // //#All*:state /href All* /a<br>// else /keyword // //#All:state /href All /a /block // else /keyword if kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // //#Reduce*:int:state:state /href Reduce* /a(reduce, begin.s)<br>// else /keyword // //#Reduce:int:state /href Reduce /a.reduce /block // else /keyword // // let /keyword tmp = (part.p) // //#sub:seq.T:int:T /href sub /a (count // //#+:int:int:int /href+/a 1),<br>// if /keyword tmp // //#/href ∈ /a lambdas // then /keyword // // for /keyword x = 2, r ∈ gin // while /keyword leftside.r ≠ tmp // do /keyword x // //#+:int:int:int /href+/a n.parts.r,<br>// //#Lambda:int:state:state /href Lambda /a(// x<br>, // if /keyword count // //#+:int:int:int /href+/a 2 ≤ n.part.p // then /keyword thisstate // //#+:state:int:state /href+/a 2<br>// else /keyword // //#Reduce:int:state /href Reduce /a.reduce /block)/block // else /keyword thisstate // //#+:state:int:state /href+/a 1 /block /block // let /keyword failmatch = // // if /keyword n.parts.s // //#=:int:int:boolean /href = /a partno // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword // //#!Fail:state /href !Fail /a<br>// else /keyword if isAll* // then /keyword // //#All:state /href All /a<br>// else /keyword if kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // //#Success*:state /href Success* /a<br>// else /keyword // //#Fail:state /href Fail /a /block // else /keyword if // //#isempty:seq.T:boolean /href isempty /a.part.(parts.s) // //#sub:seq.T:int:T /href sub /a (partno // //#+:int:int:int /href+/a 1) // then /keyword // //#Reduce:int:state /href Reduce /a(reduce // //#+:int:int:int /href+/a 1)<br>// else /keyword nextpart /block // for /keyword // RecoverEnding = //""/literal<br>, last0 = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, w ∈ // if /keyword recover // then /keyword part.p // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (count // //#/href-/a 1) // else /keyword //""/literal /block // do /keyword // next(// // if /keyword w // //#/href ∈ /a //"!"/literal // //#∨:boolean:boolean:boolean /href ∨ /a last0 // //#/href ∈ /a //"!"/literal // then /keyword RecoverEnding<br>// else /keyword RecoverEnding // //#/href+/a // //#smallest:set.oneRule:word:seq.word /href smallest /a(small, w)<br>, w /block)/block // let /keyword C = // // if /keyword e // //#/href ∈ /a //"any Any"/literal // then /keyword tableEntry(// //#MatchAny:state /href MatchAny /a, //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, success1, failmatch, RecoverEnding)<br>// else /keyword // // let /keyword look = // //#lookup:set.T:T:set.T /href lookup /a(gset, pegrule(last, e, empty:seq.pegpart, 0, // //#/href NT /a)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.look // then /keyword // // if /keyword last // //#/href ∈ /a //"!"/literal // then /keyword tableEntry(// //#!T:state /href !T /a, e, failmatch, success1, RecoverEnding)<br>// else /keyword tableEntry(// //#/href T /a, e, success1, failmatch, RecoverEnding)/block // else /keyword // tableEntry(// // if /keyword kind.look // //#sub:set.T:int:T /href sub /a 1 // //#/href ∈ /a //"*+"/literal // then /keyword // //#/href NT* /a.begin.look // //#sub:set.T:int:T /href sub /a 1<br>// else /keyword // //#/href NT /a.begin.look // //#sub:set.T:int:T /href sub /a 1<br>, leftside.look // //#sub:set.T:int:T /href sub /a 1<br>, success1<br>, failmatch<br>, RecoverEnding /block), /block /block /block // let /keyword newpt = // // if /keyword partno // //#=:int:int:boolean /href = /a 1<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.lastpart, 1, count // //#/href-/a 1)<br> ≠ // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.p, 1, count // //#/href-/a 1) // then /keyword parttable<br>// else /keyword //{look for first rule that shared prefix with current rule}<br>// for /keyword // accT = empty:seq.int<br>, kidx2 = // //#index:state:int /href index /a.thisstate<br>, pt ∈ // //#reverse:seq.T:seq.T /href reverse /a.// //#subseq:seq.T:int:int:seq.T /href subseq /a(parts.s, 1, partno // //#/href-/a 1)/block // while /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.pt, 1, count)<br> // //#=:seq.T:seq.T:boolean /href = /a // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.p, 1, count)<br>// do /keyword // // let /keyword newk = kidx2 // //#/href-/a n.part.pt,<br>next(accT // //#/href+/a newk, newk)/block //{part shares prefix with previous part so avoid backtracking. }/comment<br>// if /keyword // //#isempty:seq.T:boolean /href isempty /a.accT // then /keyword // // let /keyword zidx = // //#index:state:int /href index /a.thisstate // //#/href-/a n.part.lastpart<br>// let /keyword z = parttable // //#sub:seq.T:int:T /href sub /a zidx,<br>// if /keyword action.z // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // // //#/href replace /a(// parttable<br>, zidx<br>, tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, thisstate, recover.z)/block)/block // else /keyword if // //#action:state:state /href action /a.action.z // //#/href ∈ /a [// //#/href NT /a, // //#/href NT* /a]<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#index:state:int /href index /a.action.z // //#=:int:int:boolean /href = /a // //#index:state:int /href index /a.action.C // then /keyword // // let /keyword look = // //#lookup:set.T:T:set.T /href lookup /a(gset, pegrule(last, match.z, empty:seq.pegpart, 0, // //#/href NT /a)),<br>// //#/href replace /a(parttable, zidx, tableEntry(action.z, match.z, Sstate.z, thisstate, recover.z))/block // else /keyword parttable /block // else /keyword if // //#action:state:state /href action /a.action.C<br> ∉ [// //#/href T /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword parttable<br>// else /keyword // // let /keyword kidx = accT // //#sub:seq.T:int:T /href sub /a n.accT<br>// let /keyword z = parttable // //#sub:seq.T:int:T /href sub /a kidx,<br>// if /keyword action.z // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // // //#/href replace /a(// parttable<br>, kidx<br>, // if /keyword count // //#=:int:int:boolean /href = /a 1<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#action:state:state /href action /a.action.parttable // //#sub:seq.T:int:T /href sub /a (kidx // //#/href-/a 1)<br> ∉ [// //#/href NT /a, // //#/href NT* /a] // then /keyword tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, Fstate.C, recover.z)<br>// else /keyword tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, thisstate, recover.z)/block)/block // else /keyword if count // //#=:int:int:boolean /href = /a n.part.p // //#∧:boolean:boolean:boolean /href ∧ /a e // //#/href ∈ /a lambdas // then /keyword // // for /keyword newtbl1 = parttable, l ∈ accT<br>// do /keyword // // let /keyword tidx = l // //#+:int:int:int /href+/a 1<br>// let /keyword z3 = parttable // //#sub:seq.T:int:T /href sub /a tidx,<br>// //#/href replace /a(newtbl1, tidx, tableEntry(action.z3, match.z3, Sstate.z3, Sstate.C, recover.z3)), /block newtbl1 /block // else /keyword //{action.action.z = NT}<br>// let /keyword newFstate = // // if /keyword // //#action:state:state /href action /a.Fstate.C<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword // //#/href S' /a.Fstate.C<br>// else /keyword Fstate.C /block // for /keyword newtbl1 = parttable, l ∈ accT<br>// do /keyword // // let /keyword e2 = parttable // //#sub:seq.T:int:T /href sub /a l,<br>// if /keyword // //#index:state:int /href index /a.Fstate.z // //#=:int:int:boolean /href = /a // //#index:state:int /href index /a.Fstate.e2<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#action:state:state /href action /a.Fstate.e2 ∉ [// //#Fail:state /href Fail /a] // then /keyword // // assert /keyword // //#action:state:state /href action /a.Fstate.e2<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a, // //#/href S' /a] // report /keyword //"ProBLEM:(Fstate.e2)"/literal,<br>// //#/href replace /a(// newtbl1<br>, l<br>, tableEntry(// action.e2<br>, match.e2<br>, Sstate.e2<br>, // if /keyword // //#action:state:state /href action /a.Fstate.C<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword // //#/href S' /a.Fstate.C<br>// else /keyword Fstate.C<br>, recover.e2 /block)/block)/block // else /keyword newtbl1, /block newtbl1, /block /block /block /block next(newpt // //#/href+/a C, thisstate // //#+:state:int:state /href+/a 1, e, count // //#+:int:int:int /href+/a 1), /block /block next(nextstate2, nextpart, parttable, partno // //#+:int:int:int /href+/a 1, p), /block next(ruletable, reduce0 // //#+:int:int:int /href+/a (// if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword 0 // else /keyword n.parts.s))/block // for /keyword table1 = table, r ∈ gin<br>// do /keyword // // if /keyword kind.r // //#/href ∈ /a //"+"/literal // then /keyword // // let /keyword thisrule = // // //#subseq:seq.T:int:int:seq.T /href subseq /a(// table1<br>, // //#index:state:int /href index /a.begin.r<br>, // //#index:state:int /href index /a.begin.r // //#+:int:int:int /href+/a nostates.r // //#/href-/a 1 /block), /block // //#fixPlus:seq.tableEntry:seq.tableEntry:seq.tableEntry:seq.tableEntry /href fixPlus /a(// // //#subseq:seq.T:int:int:seq.T /href subseq /a(table1, 1, // //#index:state:int /href index /a.begin.r // //#/href-/a 1)<br>, thisrule<br>, table1 // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (// //#index:state:int /href index /a.begin.r // //#+:int:int:int /href+/a n.thisrule // //#/href-/a 1)/block)/block // else /keyword table1, /block // //#removeIdx:seq.tableEntry:seq.tableEntry /href removeIdx /a.table1

 <p>function // fixPlus:seq.tableEntry:seq.tableEntry:seq.tableEntry:seq.tableEntry /id // #PEGrules /href /a fixPlus(<br>table0:seq.tableEntry<br>, thisrule:seq.tableEntry<br>, table1:seq.tableEntry<br>) seq.tableEntry<br>//{Change rule in table to handle first match and adds states to table handle following parts}/comment<br>// let /keyword adjust = n.thisrule // //#+:int:int:int /href+/a n.table1<br>// let /keyword low = n.table0 // //#+:int:int:int /href+/a 1<br>// let /keyword high = n.table0 // //#+:int:int:int /href+/a n.thisrule<br>// for /keyword firstPart = table0, afterPart = table1, e ∈ thisrule<br>// do /keyword // // let /keyword S = Sstate.e<br>// let /keyword newS = // // if /keyword S // //#/href ∈ /a [// //#Success*:state /href Success* /a, // //#All:state /href All /a] // then /keyword // //#Fail:state /href Fail /a<br>// else /keyword if // //#action:state:state /href action /a.S // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // // //#Reduce*:int:state:state /href Reduce* /a(// // //#reduceNo:state:int /href reduceNo /a.S<br>, // //#nextState:state:state /href nextState /a.S // //#+:state:int:state /href+/a adjust /block)/block // else /keyword if // //#action:state:state /href action /a.S // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a(// //#nextState:state:state /href nextState /a.S // //#+:state:int:state /href+/a adjust)<br>// else /keyword S /block // let /keyword F = Fstate.e<br>// let /keyword newF = // // if /keyword F // //#/href ∈ /a [// //#Success*:state /href Success* /a, // //#All:state /href All /a] // then /keyword // //#Fail:state /href Fail /a<br>// else /keyword F /block // let /keyword afterS = // //#adjust:state:int:int:int:state /href adjust /a(S, adjust, low, high),<br>// let /keyword afterF = // //#adjust:state:int:int:int:state /href adjust /a(F, adjust, low, high),<br>next(// firstPart // //#/href+/a tableEntry(action.e, match.e, newS, newF, recover.e)<br>, afterPart // //#/href+/a tableEntry(action.e, match.e, afterS, afterF, recover.e)/block), /block firstPart // //#/href+/a afterPart

 <p>function // adjust:state:int:int:int:state /id // #PEGrules /href /a adjust(s:state, adjust:int, low:int, high:int) state<br>// if /keyword // //#between:int:int:int:boolean /href between /a(// //#index:state:int /href index /a.s, low, high) // then /keyword // // if /keyword // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Idx:state /href Idx /a // then /keyword s // //#+:state:int:state /href+/a adjust<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // // //#Reduce*:int:state:state /href Reduce* /a(// // //#reduceNo:state:int /href reduceNo /a.s<br>, // //#nextState:state:state /href nextState /a.s // //#+:state:int:state /href+/a adjust /block)/block // else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a(// //#nextState:state:state /href nextState /a.s // //#+:state:int:state /href+/a adjust)<br>// else /keyword s /block // else /keyword s

 <p>function // removeIdx:seq.tableEntry:seq.tableEntry /id // #PEGrules /href /a removeIdx(tbl:seq.tableEntry) seq.tableEntry<br>// for /keyword acc = empty:seq.tableEntry, e ∈ tbl<br>// do /keyword // acc<br> // //#/href+/a tableEntry(// // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(action.e, tbl)<br>, match.e<br>, // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(Sstate.e, tbl)<br>, // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(Fstate.e, tbl)<br>, recover.e /block), /block acc

 <p>function // removeIdx:state:seq.tableEntry:state /id // #PEGrules /href /a removeIdx(s:state, tbl:seq.tableEntry) state<br>//{Remove Idx from table. The action of tableEntries will be !T T T' NT NT* or MatchAny.If Idx instruction points to the ith element in the table, it will be changed to !T.i, T.i, T'.i, NT.i, NT*.i to include the kind of the table element.The instruction S', Idx, Discard*, NT, Reduce*, also contains a pointer into the table so they also will be updated. }/comment<br>// if /keyword // //#index:state:int /href index /a.s // //#=:int:int:boolean /href = /a 0<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#action:state:state /href action /a.s<br> ∉ [// // //#/href S' /a<br>, // //#Idx:state /href Idx /a<br>, // //#/href Discard* /a<br>, // //#/href NT /a<br>, // //#/href NT* /a<br>, // //#Reduce*:state /href Reduce* /a<br>, // //#Lambda:state /href Lambda /a /block] // then /keyword s<br>// else /keyword // // let /keyword tblaction = // // //#action:state:state /href action /a.action.tbl // //#sub:seq.T:int:T /href sub /a // //#index:state:int /href index /a.s /block // let /keyword action = // // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#NT:int:state /href NT /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#NT*:int:state /href NT* /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // //#/href T /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#MatchAny:state /href MatchAny /a // then /keyword // //#MatchAny:int:state /href MatchAny /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#T':state /href T' /a // then /keyword // //#T':int:state /href T' /a.// //#index:state:int /href index /a.s<br>// else /keyword // // assert /keyword tblaction // //#=:state:state:boolean /href = /a // //#!T:state /href !T /a // report /keyword //"RemoveIdx Problem: Unexpected action in PEG table"/literal,<br>// //#!T:int:state /href !T /a.// //#index:state:int /href index /a.s, /block /block // if /keyword // //#action:state:state /href action /a.s // //#/href ∈ /a [// //#/href S' /a] // then /keyword // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#T':state /href T' /a // then /keyword action // else /keyword // //#/href S' /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#/href ∈ /a [// //#Idx:state /href Idx /a] // then /keyword // // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#/href NT /a.action<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#/href NT* /a.action<br>// else /keyword action /block // else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#/href NT /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#/href NT* /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // //#Reduce*:int:state:state /href Reduce* /a(// //#reduceNo:state:int /href reduceNo /a.s, action)<br>// else /keyword if // //#action:state:state /href action /a.// //#nextState2:state:state /href nextState2 /a.// //#Lambda:state /href Lambda /a<br> // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword s<br>// else /keyword // //#Lambda:int:state:state /href Lambda /a(// //#reduceNo:state:int /href reduceNo /a.s, action)/block

 <p>function // %:pegpart:seq.word /id // #PEGrules /href /a %(p:pegpart) seq.word //"/sp /tag &lt;br /tag > /nsp:(part.p)"/literal

 <p>Function // replaceWords:seq.word:seq.word:seq.word /id // #PEGrules /href /a replaceWords(str:seq.word, subs:seq.word) seq.word<br>//{subs is of format w1 r1, w2 r2,... , wn rn where w1 is a word and r1 is zero or more words./sp /tag &lt;br /tag > /nsp<br>Any occurrence of wi in str is replaced with ri /sp /tag &lt;br /tag > /nsp<br>Note that commas cannot occur in ri /sp /tag &lt;br /tag > /nsp<br>If wn rn contains /1 then any word w in str not eq to one of w1.. w(n-i)is replace with wn rn with the /1 replaced by w. }/comment<br>// for /keyword d1 = 0, d2 = 0, w ∈ // //#reverse:seq.T:seq.T /href reverse /a.subs<br>// while /keyword w ∉ //","/literal<br>// do /keyword next(d1 // //#+:int:int:int /href+/a 1, // if /keyword w // //#/href ∈ /a //"/1 $"/literal // then /keyword d1 // else /keyword d2)<br>// let /keyword z = subs // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (n.subs // //#/href-/a d1)<br>// let /keyword zidx = d1 // //#/href-/a d2<br>// let /keyword subs0 = // if /keyword d2 // //#=:int:int:boolean /href = /a 0 // then /keyword subs // //#/href+/a //","/literal // else /keyword subs // //#>>:seq.T:int:seq.T /href >> /a d1<br>// for /keyword acc = //""/literal, w ∈ str<br>// do /keyword // // for /keyword w2 = [w], replace = //""/literal, matched = false, e ∈ subs0<br>// while /keyword // //#not:boolean:boolean /href not /a.matched<br>// do /keyword // // if /keyword e // //#/href ∈ /a //","/literal // then /keyword // // if /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(replace, 1, 1) // //#=:seq.T:seq.T:boolean /href = /a [w] // then /keyword next(replace // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1, //""/literal, true)<br>// else /keyword next(w2, // if /keyword // //#isempty:seq.T:boolean /href isempty /a.replace // then /keyword //","/literal // else /keyword //""/literal, false)/block // else /keyword next(w2, replace // //#/href+/a e, false), /block acc<br> // //#/href+/a (// if /keyword d2 // //#=:int:int:boolean /href = /a 0 // //#∨:boolean:boolean:boolean /href ∨ /a matched // then /keyword w2<br>// else /keyword // //#/href replace /a(z, zidx, w)), /block acc

 <p>Function // postprocess:seq.tableEntry:seq.word:seq.tableEntry /id // #PEGrules /href /a postprocess(table:seq.tableEntry, subs:seq.word) seq.tableEntry<br>// if /keyword // //#isempty:seq.T:boolean /href isempty /a.subs // then /keyword table<br>// else /keyword // // for /keyword newtable = empty:seq.tableEntry, e ∈ table<br>// do /keyword // newtable<br> // //#/href+/a (// if /keyword action.e // //#/href ∈ /a [// //#/href T /a, // //#!T:state /href !T /a, // //#T':state /href T' /a] // then /keyword // // let /keyword m = // //#replaceWords:seq.word:seq.word:seq.word /href replaceWords /a([match.e], subs),<br>// if /keyword m // //#=:seq.T:seq.T:boolean /href = /a [match.e] // then /keyword e<br>// else /keyword tableEntry(action.e, m // //#sub:seq.T:int:T /href sub /a 1, Sstate.e, Fstate.e, recover.e)/block // else /keyword e), /block newtable /block

 <p>Function // isNonTerminal:word:seq.pegrule:boolean /id // #PEGrules /href /a isNonTerminal(e:word, g:seq.pegrule) boolean<br>// for /keyword // isT = e ∉ //"any Any"/literal // //#∨:boolean:boolean:boolean /href ∨ /a e // //#/href ∈ /a //"!"/literal<br>, r ∈ g /block // while /keyword isT<br>// do /keyword e ≠ leftside.r,<br>// //#not:boolean:boolean /href not /a.isT

 <p>Function // NTcount:pegpart:seq.pegrule:int /id // #PEGrules /href /a NTcount(p:pegpart, gin:seq.pegrule) int<br>// for /keyword count = 0, e ∈ part.p<br>// do /keyword // if /keyword // //#isNonTerminal:word:seq.pegrule:boolean /href isNonTerminal /a(e, gin) // then /keyword count // //#+:int:int:int /href+/a 1 // else /keyword count,<br>count

 <p>Function // %table:seq.tableEntry:seq.word /id // #PEGrules /href /a %table(t:seq.tableEntry) seq.word<br>// for /keyword acc = //""/literal, rowno = 1, a ∈ t<br>// do /keyword // next(// acc<br> // //#/href+/a (// if /keyword // //#action:state:state /href action /a.action.a // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword //"/sp /tag &lt;br /tag > /nsp:(rowno):(action.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Sstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Fstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(recover.a)/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>// else /keyword //"/sp /tag &lt;br /tag > /nsp:(rowno):(action.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(// //#escapeformat:word /href escapeformat /a):([match.a]):(// //#escapeformat:word /href escapeformat /a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Sstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Fstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(recover.a)/tag &lt;/td> /tag &lt;/tr>"/literal)<br>, rowno // //#+:int:int:int /href+/a 1 /block), /block //"PEG Rules:(acc)/tag &lt;/table> /sp /tag &lt;p /tag > /nsp"/literal

 <p>Function // >1:state:state:ordering /id // #PEGrules /href /a >1(a:state, b:state) ordering toint.a // //#>1:int:int:ordering /href >1 /a toint.b

 <p>Function // %:state:seq.word /id // #PEGrules /href /a %(s:state) seq.word<br>// let /keyword action = // //#action:state:state /href action /a.s,<br>// if /keyword s // //#=:state:state:boolean /href = /a // //#Match:state /href Match /a // then /keyword //"Match"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword //"Reduce.:(// //#reduceNo:state:int /href reduceNo /a.s)"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword //"Reduce*(:(// //#reduceNo:state:int /href reduceNo /a.s),:(// //#nextState:state:state /href nextState /a.s))"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Lambda:state /href Lambda /a // then /keyword //"Lambda(:(// //#reduceNo:state:int /href reduceNo /a.s),:(// //#nextState2:state:state /href nextState2 /a.s))"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#/href NT /a<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#action:state:state /href action /a.// //#nextState:state:state /href nextState /a.s<br> // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword //"NT.:(// //#index:state:int /href index /a.// //#nextState:state:state /href nextState /a.s)"/literal<br>// else /keyword if action // //#/href ∈ /a [// //#/href Discard* /a, // //#/href NT /a, // //#/href S' /a] // then /keyword // // //#decode:state:seq.word /href decode /a.action<br> // //#/href+/a //"."/literal<br> // //#/href+/a // //#%:state:seq.word /href % /a.// //#nextState:state:state /href nextState /a.s /block // else /keyword if // //#index:state:int /href index /a.s // //#=:int:int:boolean /href = /a 0 // then /keyword // //#decode:state:seq.word /href decode /a.action<br>// else /keyword // // //#decode:state:seq.word /href decode /a.action<br> // //#/href+/a //"."/literal<br> // //#/href+/a // //#%:int:seq.word /href % /a.// //#index:state:int /href index /a.s /block

 <p>function // actionBits:int /id // #PEGrules /href /a actionBits int 5

 <p>function // reduceBits:int /id // #PEGrules /href /a reduceBits int 15

 <p>function // shiftIndex:int /id // #PEGrules /href /a shiftIndex int<br>// //#actionBits:int /href actionBits /a<br> // //#+:int:int:int /href+/a // //#reduceBits:int /href reduceBits /a<br> // //#+:int:int:int /href+/a // //#actionBits:int /href actionBits /a

 <p>function // state:state:int:int:state:state /id // #PEGrules /href /a state(action:state, tblidx:int, reduceNo:int, tblaction:state) state<br>//{OPTION INLINE}/comment<br>state.toint(// // //#tobits:int:bits /href tobits /a.tblidx<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a 2 // //#*:int:int:int /href * /a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.tblaction<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.reduceNo // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a // //#actionBits:int /href actionBits /a<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.action /block)

 <p>function // state:state:int:state /id // #PEGrules /href /a state(action:state, tblidx:int) state<br>state.toint(// // //#tobits:int:bits /href tobits /a.tblidx<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a 2 // //#*:int:int:int /href * /a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.action /block)

 <p>Function // index:state:int /id // #PEGrules /href /a index(s:state) int<br>toint(// //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a // //#shiftIndex:int /href shiftIndex /a)

 <p>Function // reduceNo:state:int /id // #PEGrules /href /a reduceNo(s:state) int<br>toint(// // //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a // //#actionBits:int /href actionBits /a<br> // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#reduceBits:int /href reduceBits /a /block)

 <p>Function // action:state:state /id // #PEGrules /href /a action(s:state) state<br>state.toint(bits.toint.s // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#actionBits:int /href actionBits /a)

 <p>Function // NT:state:state /id // #PEGrules /href /a NT(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href NT /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // NT:int:state /id // #PEGrules /href /a NT(index:int) state // //#state:state:int:int:state:state /href state /a(// //#/href NT /a, index, 0, // //#/href NT /a)

 <p>Function // NT*:int:state /id // #PEGrules /href /a NT*(index:int) state // //#state:state:int:int:state:state /href state /a(// //#/href NT /a, index, 0, // //#/href NT /a)

 <p>Function // NT*:state:state /id // #PEGrules /href /a NT*(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href NT /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // S':state:state /id // #PEGrules /href /a S'(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href S' /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // T:int:state /id // #PEGrules /href /a T(i:int) state // //#state:state:int:state /href state /a(// //#/href T /a, i)

 <p>Function // T':int:state /id // #PEGrules /href /a T'(i:int) state // //#state:state:int:int:state:state /href state /a(// //#T':state /href T' /a, i, 0, // //#T':state /href T' /a)

 <p>Function // MatchAny:int:state /id // #PEGrules /href /a MatchAny(i:int) state // //#state:state:int:state /href state /a(// //#MatchAny:state /href MatchAny /a, i)

 <p>Function // !T:int:state /id // #PEGrules /href /a !T(i:int) state // //#state:state:int:state /href state /a(// //#!T:state /href !T /a, i)

 <p>Function // Reduce:int:state /id // #PEGrules /href /a Reduce(partno:int) state<br>// //#state:state:int:int:state:state /href state /a(// //#Reduce:state /href Reduce /a, 0, partno, state.0)

 <p>Function // Reduce*:int:state:state /id // #PEGrules /href /a Reduce*(partno:int, state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#Reduce*:state /href Reduce* /a<br>, // //#index:state:int /href index /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // Lambda:int:state:state /id // #PEGrules /href /a Lambda(partno:int, state:state) state<br>// if /keyword // //#action:state:state /href action /a.state // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword // // //#state:state:int:int:state:state /href state /a(// // //#Lambda:state /href Lambda /a<br>, // //#reduceNo:state:int /href reduceNo /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)/block // else /keyword // // //#state:state:int:int:state:state /href state /a(// // //#Lambda:state /href Lambda /a<br>, // //#index:state:int /href index /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)/block

 <p>Function // nextState:state:state /id // #PEGrules /href /a nextState(s:state) state<br>// let /keyword k = // //#actionBits:int /href actionBits /a // //#+:int:int:int /href+/a // //#reduceBits:int /href reduceBits /a,<br>state.toint(// // //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a k<br> // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#actionBits:int /href actionBits /a<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.s // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.k // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a k /block)

 <p>Function // nextState2:state:state /id // #PEGrules /href /a nextState2(s:state) state<br>// let /keyword t = // //#nextState:state:state /href nextState /a.s,<br>// if /keyword // //#action:state:state /href action /a.t // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword // //#Reduce:int:state /href Reduce /a.// //#index:state:int /href index /a.s<br>// else /keyword t

 <p>Function // Discard*:state:state /id // #PEGrules /href /a Discard*(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href Discard* /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>function //+:state:int:state /id // #PEGrules /href /a +(s:state, i:int) state<br>state(// toint.s<br> // //#+:int:int:int /href+/a toint(// //#tobits:int:bits /href tobits /a.i // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a // //#shiftIndex:int /href shiftIndex /a)/block)

 <p>Function // startstate:state /id // #PEGrules /href /a startstate state // //#NT:int:state /href NT /a.1

 <p>Function // Match:state /id // #PEGrules /href /a Match state // //#Reduce:state /href Reduce /a

 <p>Function // /All:seq.word /id // #PEGrules /href /a /All seq.word //"/All"/literal

 <p>The state T' is like T but does not rollback result on failure. Similarly actionP but does not rollback result on failure.

 <p>function // genEnum:seq.seq.word /id // #PEGrules /href /a genEnum seq.seq.word<br>[//"newType: state names: Failure Reduce Idx MatchAny T Fail Success* !T Discard* All Discard NT !Reduce !Fail Reduce* Lambda All* NT* S' T'"/literal]

 <p>&lt;&lt;&lt;&lt; Below is auto generated code >>>>

 <p>type state is toint:int

 <p>Export /keyword toint(state) int

 <p>Export /keyword state(i:int) state

 <p>Export /keyword type:state

 <p>Function // =:state:state:boolean /id // #PEGrules /href /a =(a:state, b:state) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>Function // Failure:state /id // #PEGrules /href /a Failure state state.0

 <p>Function // Reduce:state /id // #PEGrules /href /a Reduce state state.1

 <p>Function // Idx:state /id // #PEGrules /href /a Idx state state.2

 <p>Function // MatchAny:state /id // #PEGrules /href /a MatchAny state state.3

 <p>Function // T:state /id // #PEGrules /href /a T state state.4

 <p>Function // Fail:state /id // #PEGrules /href /a Fail state state.5

 <p>Function // Success*:state /id // #PEGrules /href /a Success* state state.6

 <p>Function // !T:state /id // #PEGrules /href /a !T state state.7

 <p>Function // Discard*:state /id // #PEGrules /href /a Discard* state state.8

 <p>Function // All:state /id // #PEGrules /href /a All state state.9

 <p>Function // Discard:state /id // #PEGrules /href /a Discard state state.10

 <p>Function // NT:state /id // #PEGrules /href /a NT state state.11

 <p>Function // !Reduce:state /id // #PEGrules /href /a !Reduce state state.12

 <p>Function // !Fail:state /id // #PEGrules /href /a !Fail state state.13

 <p>Function // Reduce*:state /id // #PEGrules /href /a Reduce* state state.14

 <p>Function // Lambda:state /id // #PEGrules /href /a Lambda state state.15

 <p>Function // All*:state /id // #PEGrules /href /a All* state state.16

 <p>Function // NT*:state /id // #PEGrules /href /a NT* state state.17

 <p>Function // S':state /id // #PEGrules /href /a S' state state.18

 <p>Function // T':state /id // #PEGrules /href /a T' state state.19

 <p>Function // decode:state:seq.word /id // #PEGrules /href /a decode(code:state) seq.word<br>// let /keyword discard = //[// // //#Failure:state /href Failure /a<br>, // //#Reduce:state /href Reduce /a<br>, // //#Idx:state /href Idx /a<br>, // //#MatchAny:state /href MatchAny /a<br>, // //#/href T /a<br>, // //#Fail:state /href Fail /a<br>, // //#Success*:state /href Success* /a<br>, // //#!T:state /href !T /a<br>, // //#/href Discard* /a<br>, // //#All:state /href All /a<br>, // //#Discard:state /href Discard /a<br>, // //#/href NT /a<br>, // //#!Reduce:state /href !Reduce /a<br>, // //#!Fail:state /href !Fail /a<br>, // //#Reduce*:state /href Reduce* /a<br>, // //#Lambda:state /href Lambda /a<br>, // //#All*:state /href All* /a<br>, // //#/href NT* /a<br>, // //#/href S' /a<br>, // //#T':state /href T' /a /block]/block // let /keyword i = toint.code,<br>// if /keyword // //#between:int:int:int:boolean /href between /a(i, 0, 19) // then /keyword // // let /keyword r = //[// //"Failure Reduce Idx MatchAny T Fail Success* !T Discard* All Discard NT !Reduce !Fail Reduce* Lambda All* NT* S' T'"/literal<br> // //#sub:seq.T:int:T /href sub /a (i // //#+:int:int:int /href+/a 1)/block], /block // if /keyword r ≠ //"?"/literal // then /keyword r // else /keyword //"state."/literal // //#/href+/a // //#toword:int:word /href toword /a.i /block // else /keyword //"state."/literal // //#/href+/a // //#toword:int:word /href toword /a.i

 <p>// // kernal /id Module /keyword kernal

 <p>Export /keyword type:boolean

 <p>Export /keyword type:char

 <p>Export /keyword toint(char) int

 <p>Export /keyword char(int) char

 <p>Export /keyword word(int) word

 <p>Export /keyword type:ordering

 <p>Export /keyword toint(ordering) int

 <p>Export /keyword type:word

 <p>Export /keyword rawvalue(word) int

 <p>type char is toint:int

 <p>type ordering is toint:int

 <p>Function // EQ:ordering /id // #kernal /href /a EQ ordering ordering.1

 <p>Function // GT:ordering /id // #kernal /href /a GT ordering ordering.2

 <p>Function // LT:ordering /id // #kernal /href /a LT ordering ordering.0

 <p>Function // =:char:char:boolean /id // #kernal /href /a =(a:char, b:char) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>Function // =:word:word:boolean /id // #kernal /href /a =(a:word, b:word) boolean<br>//{OPTION COMPILETIME}/comment<br>rawvalue.a // //#=:int:int:boolean /href = /a rawvalue.b

 <p>Function // >1:ordering:ordering:ordering /id // #kernal /href /a >1(a:ordering, b:ordering) ordering<br>//{possible results are: EQ GT LT}/comment<br>toint.a // //#>1:int:int:ordering /href >1 /a toint.b

 <p>Function // =:ordering:ordering:boolean /id // #kernal /href /a =(a:ordering, b:ordering) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>---------

 <p>Builtin /keyword representation(a:real) int

 <p>Function //-:int:int /id // #kernal /href /a -(i:int) int 0 // //#/href-/a i

 <p>Builtin /keyword // >1

 <p>Builtin /keyword //+

 <p>Builtin /keyword //-

 <p>Builtin /keyword // *

 <p>Builtin /keyword // /

 <p>Builtin /keyword // =

 <p>Function // abs:int:int /id // #kernal /href /a abs(x:int) int // if /keyword x // //#&lt;:int:int:boolean /href &lt; /a 0 // then /keyword 0 // //#/href-/a x // else /keyword x

 <p>Function // mod:int:int:int /id // #kernal /href /a mod(x:int, y:int) int<br>// if /keyword x // //#&lt;:int:int:boolean /href &lt; /a 0 // then /keyword x // //#/href-/a x // //#/:int:int:int /href / /a y // //#*:int:int:int /href * /a y // //#+:int:int:int /href+/a y // else /keyword x // //#/href-/a x // //#/:int:int:int /href / /a y // //#*:int:int:int /href * /a y

 <p>Builtin /keyword // >

 <p>Function // &lt;:int:int:boolean /id // #kernal /href /a &lt;(a:int, b:int) boolean b // //#>:int:int:boolean /href > /a a

 <p>Function // between:int:int:int:boolean /id // #kernal /href /a between(i:int, lower:int, upper:int) boolean i ≥ lower // //#∧:boolean:boolean:boolean /href ∧ /a i ≤ upper

 <p>Function // sup:int:int:int /id // #kernal /href /a sup(x:int, n:int) int<br>//{* nth power of i}/comment<br>// if /keyword n // //#=:int:int:boolean /href = /a 0 // then /keyword 1<br>// else /keyword if n // //#=:int:int:boolean /href = /a 1 // then /keyword x<br>// else /keyword if n // //#=:int:int:boolean /href = /a 2 // then /keyword x // //#*:int:int:int /href * /a x<br>// else /keyword if n // //#=:int:int:boolean /href = /a 3 // then /keyword x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x<br>// else /keyword // // assert /keyword n // //#>:int:int:boolean /href > /a 3 // report /keyword //"negative powers are not implemented"/literal<br>// for /keyword // acc = x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x<br>, k = 4 /block // while /keyword k // //#&lt;:int:int:boolean /href &lt; /a n<br>// do /keyword next(acc // //#*:int:int:int /href * /a x, k // //#+:int:int:int /href+/a 1),<br>acc /block

 <p>Function // max:int:int:int /id // #kernal /href /a max(a:int, b:int) int // if /keyword a // //#>:int:int:boolean /href > /a b // then /keyword a // else /keyword b

 <p>Function // min:int:int:int /id // #kernal /href /a min(a:int, b:int) int // if /keyword a // //#&lt;:int:int:boolean /href &lt; /a b // then /keyword a // else /keyword b

 <p>--------

 <p>type boolean is tointx:int

 <p>Builtin /keyword // true

 <p>Builtin /keyword // false

 <p>Builtin /keyword // not

 <p>Builtin /keyword // =

 <p>Function // ∧:boolean:boolean:boolean /id // #kernal /href /a ∧(a:boolean, b:boolean) boolean // if /keyword a // then /keyword b // else /keyword false

 <p>Function // ∨:boolean:boolean:boolean /id // #kernal /href /a ∨(a:boolean, b:boolean) boolean // if /keyword a // then /keyword true // else /keyword b

 <p>Builtin /keyword // stacktrace

 <p>type word is rawvalue:int

 <p>-----------

 <p>Export /keyword type:timestamp

 <p>Export /keyword seconds(timestamp) int

 <p>Export /keyword timestamp(int) timestamp

 <p>type timestamp is seconds:int

 <p>// // brandeskopf /id Module /keyword brandeskopf

 <p>Graph layout based on:Fast and Simple Horizontal Coordinate Assignment Ulrik Brandes and Boris Kopf, 2002

 <p>use seq1.block

 <p>use seq1.seq.block

 <p>use set.block

 <p>use seq1.int

 <p>use seq.int

 <p>use seq1.seq.int

 <p>use seq.seq.int

 <p>use set.int

 <p>use layernode

 <p>use seq1.layernode

 <p>use seq.layernode

 <p>use sort.layernode

 <p>use real

 <p>use standard

 <p>use seq1.seq.layernode

 <p>function // =:layernode:layernode:boolean /id // #brandeskopf /href /a =(a:layernode, b:layernode) boolean no.a // //#=:int:int:boolean /href = /a no.b

 <p>function // type1conflicts:graph.arc.layernode:int:seq.arc.layernode /id // #brandeskopf /href /a type1conflicts(g:graph.arc.layernode, orgNodeCount:int) seq.arc.layernode<br>// for /keyword // layers = empty:seq.seq.layernode<br>, b = 1<br>, idx = 1<br>, e ∈ toseq.nodes.g // //#/href+/a layernode(0, 0, 0)/block // do /keyword // // if /keyword n.layers // //#+:int:int:int /href+/a 1 // //#=:int:int:boolean /href = /a layer.e // then /keyword next(layers, b, idx // //#+:int:int:int /href+/a 1)<br>// else /keyword // next(// layers // //#/href+/a toseq.// //#subseq:set.T:int:int:set.T /href subseq /a(nodes.g, b, idx // //#/href-/a 1)<br>, idx<br>, idx // //#+:int:int:int /href+/a 1 /block)/block /block // for /keyword // acc0 = empty:seq.arc.layernode<br>, upperlayer = layers // //#sub:seq.T:int:T /href sub /a 1<br>, currentlayer ∈ layers // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1 /block // do /keyword //{In paper, upperlayer = L_i and currentlayer = L_(i+1)}<br>// for /keyword acc = empty:seq.arc.layernode, k0 = 0, l = 0, node ∈ currentlayer<br>// do /keyword // // let /keyword l1 = pos.node,<br>// if /keyword node ≠ currentlayer // //#sub:seq.T:int:T /href sub /a n.currentlayer // then /keyword next(acc, k0, l)<br>// else /keyword if no.node ≤ orgNodeCount // then /keyword {not inner segment}next(acc, k0, l)<br>// else /keyword // // let /keyword p = // //#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T /href predecessors /a(g, node),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.p // then /keyword next(acc, k0, l)<br>// else /keyword //{iis is upper neighbor of inner segment ending at node}<br>// let /keyword iis = p // //#sub:set.T:int:T /href sub /a 1<br>// let /keyword k1 = // //#findindex:seq.T:T:int /href findindex /a(upperlayer, iis),<br>// for /keyword // acc3 = empty:seq.arc.layernode<br>, start ∈ // //#subseq:seq.T:int:int:seq.T /href subseq /a(currentlayer, l // //#+:int:int:int /href+/a 1, l1 // //#+:int:int:int /href+/a 1)/block // do /keyword // // let /keyword k = // //#findindex:seq.T:T:int /href findindex /a(upperlayer, start),<br>acc3<br> // //#/href+/a (// if /keyword k // //#&lt;:int:int:boolean /href &lt; /a k0 // //#∨:boolean:boolean:boolean /href ∨ /a k // //#>:int:int:boolean /href > /a k1 // then /keyword [arc(start, {k1}iis)]<br>// else /keyword empty:seq.arc.layernode), /block next(acc // //#/href+/a acc3, k1, l1), /block /block /block next(acc0 // //#/href+/a acc, currentlayer), /block acc0

 <p>-------------------------------

 <p>function // findvertarcsUL:boolean:graph.arc.layernode:seq.seq.layernode:set.arc.layernode:seq.arc.layernode /id // #brandeskopf /href /a findvertarcsUL(<br>RtoL:boolean<br>, g:graph.arc.layernode<br>, layers2:seq.seq.layernode<br>, marked:set.arc.layernode<br>) seq.arc.layernode<br>//{Step 2 is to find vertical alignments. This will return arcs that will have the two nodes with the same x value. Inner arcs are prime canidates for this vertial alignment.}/comment<br>// for /keyword // result1 = empty:seq.arc.layernode<br>, lastlayer = layers2 // //#sub:seq.T:int:T /href sub /a 1<br>, currentlayer ∈ layers2 // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1 /block // do /keyword // // for /keyword result2 = empty:seq.arc.layernode, r = 0, assigned = empty:seq.int, node ∈ currentlayer<br>// do /keyword // // let /keyword preds = toseq.// //#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T /href predecessors /a(g, node),<br>// if /keyword n.preds // //#>:int:int:boolean /href > /a 0 // then /keyword // // for /keyword upperidx = empty:seq.int, @e ∈ preds<br>// do /keyword // // let /keyword t2 = // if /keyword RtoL // then /keyword n.lastlayer // //#+:int:int:int /href+/a 1 // //#/href-/a pos.@e // else /keyword pos.@e,<br>upperidx // //#/href+/a t2 /block // let /keyword tmp = (n.upperidx // //#+:int:int:int /href+/a 1) // //#/:int:int:int /href / /a 2,<br>// for /keyword // result3 = result2<br>, r1 = r<br>, assigned1 = assigned<br>, m ∈ // if /keyword tmp // //#*:int:int:int /href * /a 2 // //#=:int:int:boolean /href = /a n.upperidx // then /keyword [tmp, tmp // //#+:int:int:int /href+/a 1] // else /keyword [tmp]/block // do /keyword // // let /keyword m2 = upperidx // //#sub:seq.T:int:T /href sub /a m,<br>// if /keyword r1 // //#&lt;:int:int:boolean /href &lt; /a m2<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#between:int:int:int:boolean /href between /a(m2, 1, n.lastlayer)<br> // //#∧:boolean:boolean:boolean /href ∧ /a no.node ∉ assigned1 // then /keyword // // let /keyword newarc = arc(lastlayer // //#sub:seq.T:int:T /href sub /a m2, node),<br>// if /keyword newarc // //#/href ∈ /a marked // then /keyword next(result3, m2, assigned1)<br>// else /keyword next(result3 // //#/href+/a newarc, m2, assigned1 // //#/href+/a no.node)/block // else /keyword next(result3, r1, assigned1), /block next(result3, r1, assigned1)/block // else /keyword next(result2, r, assigned), /block next(result1 // //#/href+/a result2, currentlayer), /block result1

 <p>-----------

 <p>type block is levels:seq.layernode, start:layernode, blk:seq.int, class:int

 <p>function // block:seq.layernode:seq.int:block /id // #brandeskopf /href /a block(levels:seq.layernode, blk:seq.int) block<br>block(levels, levels // //#sub:seq.T:int:T /href sub /a (blk // //#sub:seq.T:int:T /href sub /a 1), blk, 1)

 <p>function // setclass:block:int:block /id // #brandeskopf /href /a setclass(b:block, class:int) block block(levels.b, start.b, blk.b, class)

 <p>function // >1:block:block:ordering /id // #brandeskopf /href /a >1(a:block, b:block) ordering<br>// let /keyword level = levels.a<br>// let /keyword l1 = start.a<br>// let /keyword l2 = start.b<br>// let /keyword diff = layer.l2 // //#/href-/a layer.l1,<br>// if /keyword diff // //#=:int:int:boolean /href = /a 0 // then /keyword pos.l1 // //#>1:int:int:ordering /href >1 /a pos.l2<br>// else /keyword if diff // //#>:int:int:boolean /href > /a 0 // then /keyword // // if /keyword diff // //#+:int:int:int /href+/a 1 // //#>:int:int:boolean /href > /a n.blk.a // then /keyword // //#LT:ordering /href LT /a<br>// else /keyword // pos.level // //#sub:seq.T:int:T /href sub /a ((blk.a) // //#sub:seq.T:int:T /href sub /a (diff // //#+:int:int:int /href+/a 1))<br> // //#>1:int:int:ordering /href >1 /a pos.l2 /block /block // else /keyword if -diff // //#+:int:int:int /href+/a 1 // //#>:int:int:boolean /href > /a n.blk.b // then /keyword // //#GT:ordering /href GT /a<br>// else /keyword pos.l1 // //#>1:int:int:ordering /href >1 /a pos.level // //#sub:seq.T:int:T /href sub /a ((blk.b) // //#sub:seq.T:int:T /href sub /a (-diff // //#+:int:int:int /href+/a 1))

 <p>function // %:block:seq.word /id // #brandeskopf /href /a %(b:block) seq.word //"{:(class.b)}{:(start.b)}:(blk.b)"/literal

 <p>function // align:boolean:graph.arc.layernode:set.arc.layernode:seq.layernode /id // #brandeskopf /href /a align(<br>RtoL:boolean<br>, gin:graph.arc.layernode<br>, marked:set.arc.layernode<br>) seq.layernode<br>//{For providing horizontal alignment. if RtoL then alignUR else alignUL}/comment<br>// for /keyword // layers4 = empty:seq.seq.layernode<br>, thislayer = empty:seq.layernode<br>, layerorder = empty:seq.layernode<br>, n2 ∈ toseq.nodes.gin // //#/href+/a layernode(0, 0, 0)/block // do /keyword // // let /keyword layerno = n.layers4 // //#+:int:int:int /href+/a 1,<br>// if /keyword layer.n2 // //#=:int:int:boolean /href = /a layerno // then /keyword // // let /keyword layer = // if /keyword RtoL // then /keyword [n2] // //#/href+/a thislayer // else /keyword thislayer // //#/href+/a n2,<br>next(layers4, layer, layerorder)/block // else /keyword // // let /keyword tmp = // // if /keyword RtoL // then /keyword // // for /keyword acc1 = empty:seq.layernode, i = 1, e ∈ thislayer<br>// do /keyword next(acc1 // //#/href+/a layernode(no.e, layerno, i), i // //#+:int:int:int /href+/a 1),<br>acc1 /block // else /keyword thislayer, /block next(layers4 // //#/href+/a thislayer, [n2], layerorder // //#/href+/a tmp)/block /block // let /keyword level = // //#sort>3:seq.T:seq.T /href sort>3 /a.layerorder<br>// let /keyword vertarcs = // //#findvertarcsUL:boolean:graph.arc.layernode:seq.seq.layernode:set.arc.layernode:seq.arc.layernode /href findvertarcsUL /a(RtoL, gin, layers4, marked)<br>// for /keyword blocks = empty:seq.seq.int, all = empty:seq.int, o5 = layerorder, aa ∈ vertarcs<br>// do /keyword // // for /keyword newo = o5, newblks = blocks, allx = empty:seq.int<br>// while /keyword no.tail.aa ≠ no.newo // //#sub:seq.T:int:T /href sub /a 1<br>// do /keyword // // if /keyword no.newo // //#sub:seq.T:int:T /href sub /a 1 // //#/href ∈ /a all // then /keyword next(newo // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1, newblks, allx)<br>// else /keyword // next(// newo // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1<br>, newblks // //#/href+/a [no.newo // //#sub:seq.T:int:T /href sub /a 1]<br>, allx // //#/href+/a no.newo // //#sub:seq.T:int:T /href sub /a 1 /block)/block /block // for /keyword i = 1, x ∈ newblks // while /keyword no.tail.aa ∉ x // do /keyword i // //#+:int:int:int /href+/a 1,<br>// if /keyword i // //#>:int:int:boolean /href > /a n.newblks // then /keyword // next(// newblks // //#/href+/a [no.tail.aa, no.head.aa]<br>, all // //#/href+/a allx // //#/href+/a [no.tail.aa, no.head.aa]<br>, newo /block)/block // else /keyword // next(// // //#subseq:seq.T:int:int:seq.T /href subseq /a(newblks, 1, i // //#/href-/a 1)<br> // //#/href+/a (newblks // //#sub:seq.T:int:T /href sub /a i // //#/href+/a no.head.aa)<br> // //#/href+/a newblks // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a i<br>, all // //#/href+/a allx // //#/href+/a no.head.aa<br>, newo /block)/block /block // let /keyword tmp = // //#asset:seq.T:set.T /href asset /a.all<br>// for /keyword more = blocks, e ∈ toseq.nodes.gin<br>// do /keyword // if /keyword no.e // //#/href ∈ /a tmp // then /keyword more // else /keyword more // //#/href+/a [no.e]<br>//{assert false report %n.blocks+"/sp /tag &lt;br /tag > /nsp<br>"+%.vertarcs+"/sp /tag &lt;br /tag > /nsp<br>"+%.toseq(nodes.g \ asset.all)}/comment<br>// for /keyword classlist = empty:seq.seq.block, maxlayer = 1, classno = 0, b ∈ more<br>// do /keyword // // let /keyword val = // //#block:seq.layernode:seq.int:block /href block /a(level, b)<br>// for /keyword class = 1, place = 0, blks ∈ classlist<br>// while /keyword place // //#=:int:int:boolean /href = /a 0<br>// do /keyword // // let /keyword i = // //#/href binarysearch /a(blks, val),<br>// if /keyword -i ≤ n.blks // //#∧:boolean:boolean:boolean /href ∧ /a maxlayer // //#&lt;:int:int:boolean /href &lt; /a layer.start.val // //#∧:boolean:boolean:boolean /href ∧ /a pos.start.val // //#&lt;:int:int:boolean /href &lt; /a pos.start.blks // //#sub:seq.T:int:T /href sub /a -i // then /keyword next(class // //#+:int:int:int /href+/a 1, 0)<br>// else /keyword next(class, -i), /block // let /keyword val2 = // //#setclass:block:int:block /href setclass /a(val, class),<br>next(// // if /keyword n.classlist // //#&lt;:int:int:boolean /href &lt; /a class.val2 // then /keyword classlist // //#/href+/a [val2]<br>// else /keyword // // let /keyword blks = classlist // //#sub:seq.T:int:T /href sub /a class.val2,<br>// //#/href replace /a(// classlist<br>, class.val2<br>, // //#subseq:seq.T:int:int:seq.T /href subseq /a(blks, 1, place // //#/href-/a 1)<br> // //#/href+/a [val2]<br> // //#/href+/a // //#subseq:seq.T:int:int:seq.T /href subseq /a(blks, place, n.blks)/block)/block, // //#max:int:int:int /href max /a(layer.start.val, maxlayer)<br>, // //#max:int:int:int /href max /a(classno, class.val)/block)/block //{assert false report"HH"+%n.classlist}/comment<br>// for /keyword assigned0 = empty:seq.layernode, blks ∈ classlist<br>// do /keyword // // for /keyword assigned = assigned0, x = {if not.RtoL then 1 else 18}1, b ∈ blks<br>// do /keyword // // for /keyword assigned1 = assigned, node ∈ blk.b<br>// do /keyword // // let /keyword l2 = layer.level // //#sub:seq.T:int:T /href sub /a node,<br>assigned1 // //#/href+/a layernode(node, l2, x), /block next(assigned1, {if not.RtoL then x+1 else x-1)}x // //#+:int:int:int /href+/a 1), /block assigned, /block assigned0

 <p>----------------------

 <p>use graph.arc.layernode

 <p>use set.layernode

 <p>use set.arc.layernode

 <p>use seq.arc.layernode

 <p>use arc.layernode

 <p>Function // assignx:graph.arc.layernode:int:int:seq.layernode /id // #brandeskopf /href /a assignx(gin:graph.arc.layernode, orgNodeCount:int, scaley:int) seq.layernode<br>//{Final step is to merge multiple layouts into one.}/comment<br>// let /keyword marked = // //#asset:seq.T:set.T /href asset /a.// //#type1conflicts:graph.arc.layernode:int:seq.arc.layernode /href type1conflicts /a(gin, orgNodeCount)<br>// let /keyword UL = // //#sort>3:seq.T:seq.T /href sort>3 /a.// //#align:boolean:graph.arc.layernode:set.arc.layernode:seq.layernode /href align /a(false, gin, marked)<br>// let /keyword UR = // //#sort>3:seq.T:seq.T /href sort>3 /a.// //#align:boolean:graph.arc.layernode:set.arc.layernode:seq.layernode /href align /a(true, gin, marked)<br>//{assert n.UL = n.nodes.g report"assignx:(n.UL):(n.nodes.g)"+%.UL+%n.layers}/comment<br>// for /keyword // maxlayer = empty:seq.int<br>, maxpos = 1<br>, lastlayer1 = 1<br>, e ∈ // //#sort:seq.T:seq.T /href sort /a.// //#align:boolean:graph.arc.layernode:set.arc.layernode:seq.layernode /href align /a(true, gin, marked)<br> // //#/href+/a layernode(0, 0, 0)/block // do /keyword // // if /keyword lastlayer1 // //#=:int:int:boolean /href = /a layer.e // then /keyword next(maxlayer, // //#max:int:int:int /href max /a(maxpos, pos.e), lastlayer1)<br>// else /keyword next(maxlayer // //#/href+/a maxpos, pos.e, layer.e)/block // for /keyword // acc = empty:seq.layernode<br>, i ∈ // //#arithseq:int:T:T:seq.T /href arithseq /a(n.UL, 1, 1)/block // do /keyword // // let /keyword ul = UL // //#sub:seq.T:int:T /href sub /a i<br>// let /keyword x = 2 // //#*:int:int:int /href * /a (pos.ul // //#+:int:int:int /href+/a maxlayer // //#sub:seq.T:int:T /href sub /a layer.ul // //#+:int:int:int /href+/a 1 // //#/href-/a pos.UR // //#sub:seq.T:int:T /href sub /a i) // //#/:int:int:int /href / /a 2,<br>next(acc // //#/href+/a layernode(no.ul, scaley // //#*:int:int:int /href * /a layer.ul, x))/block // let /keyword t = // //#sort:seq.T:seq.T /href sort /a.// //#align:boolean:graph.arc.layernode:set.arc.layernode:seq.layernode /href align /a(true, gin, marked)<br>// for /keyword // change = empty:seq.layernode<br>, last = layernode(1, 0, 0)<br>, e ∈ // //#sort:seq.T:seq.T /href sort /a.acc /block // do /keyword // // if /keyword layer.e ≠ layer.last // //#∨:boolean:boolean:boolean /href ∨ /a pos.e ≠ pos.last // then /keyword next(change // //#/href+/a e, e)<br>// else /keyword next(change // //#/href+/a layernode(no.e, layer.e, pos.e // //#+:int:int:int /href+/a 1), e), /block // //#sort>3:seq.T:seq.T /href sort>3 /a.change

 <p>-------------------------------

 <p>, xxseperation:int{seperation is"width"of node in layer.y is the layer value, x is the posistion within the layer.}

 <p>// // uniqueids /id Module /keyword uniqueids

 <p>use encoding.idrange

 <p>use seq.idrange

 <p>use standard

 <p>type idrange is next:int

 <p>function // =:idrange:idrange:boolean /id // #uniqueids /href /a =(a:idrange, b:idrange) boolean next.a // //#=:int:int:boolean /href = /a next.b

 <p>function // hash:idrange:int /id // #uniqueids /href /a hash(a:idrange) int next.a

 <p>Function // requestids:int:int /id // #uniqueids /href /a requestids(no:int) int<br>// let /keyword d = // //#encodingdata::T:seq.T /href encodingdata:idrange /a<br>// let /keyword firstno = // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.d // then /keyword 1 // else /keyword next.d // //#sub:seq.T:int:T /href sub /a n.d /block // let /keyword discard = // //#encode:T:encoding.T /href encode /a.idrange(firstno // //#+:int:int:int /href+/a no),<br>firstno

 <p>// // layernode /id Module /keyword layernode

 <p>/use brandeskopf

 <p>use seq1.int

 <p>use seq.seq.int

 <p>use arc.layernode

 <p>use graph.arc.layernode

 <p>use set.arc.layernode

 <p>use seq1.layernode

 <p>use set.layernode

 <p>use standard

 <p>Export /keyword type:layernode

 <p>Export /keyword layer(a:layernode) int

 <p>Export /keyword no(a:layernode) int

 <p>Export /keyword pos(a:layernode) int

 <p>Export /keyword layernode(int, int, int) layernode

 <p>Export /keyword type:path

 <p>Export /keyword path(tailidx:int, headidx:int, startdummy:int, enddummy:int, class:word) path

 <p>Export /keyword type:rr5

 <p>Export /keyword g(rr5) graph.arc.layernode

 <p>Export /keyword orgNodeCount(rr5) int

 <p>Export /keyword rr5(g:graph.arc.layernode, paths:seq.path, int) rr5

 <p>type layernode is no:int, layer:int, pos:int

 <p>Function // %:layernode:seq.word /id // #layernode /href /a %(a:layernode) seq.word //"{:(no.a):(layer.a):(pos.a)}"/literal

 <p>Function // >1:layernode:layernode:ordering /id // #layernode /href /a >1(a:layernode, b:layernode) ordering<br>layer.a // //#>1:int:int:ordering /href >1 /a layer.b // //#∧:ordering:ordering:ordering /href ∧ /a pos.a // //#>1:int:int:ordering /href >1 /a pos.b

 <p>Function // >2:layernode:layernode:ordering /id // #layernode /href /a >2(a:layernode, b:layernode) ordering layer.a // //#>1:int:int:ordering /href >1 /a layer.b

 <p>Function // >3:layernode:layernode:ordering /id // #layernode /href /a >3(a:layernode, b:layernode) ordering no.a // //#>1:int:int:ordering /href >1 /a no.b

 <p>type path is tailidx:int, headidx:int, startdummy:int, enddummy:int, class:word

 <p>Function // >1:path:path:ordering /id // #layernode /href /a >1(a:path, b:path) ordering tailidx.a // //#>1:int:int:ordering /href >1 /a tailidx.b

 <p>Function // %:path:seq.word /id // #layernode /href /a %(a:path) seq.word<br>//":(tailidx.a):(headidx.a):(startdummy.a):(enddummy.a):(class.a)"/literal

 <p>Export /keyword class(path) word

 <p>Function // nodes:path:seq.int /id // #layernode /href /a nodes(p:path) seq.int<br>// if /keyword startdummy.p // //#=:int:int:boolean /href = /a 0 // then /keyword [tailidx.p, headidx.p]<br>// else /keyword //[tailidx.p]<br> // //#/href+/a // //#arithseq:int:T:T:seq.T /href arithseq /a(enddummy.p // //#/href-/a startdummy.p // //#+:int:int:int /href+/a 1, 1, startdummy.p)<br> // //#/href+/a headidx.p /block

 <p>type rr5 is g:graph.arc.layernode, paths:seq.path, orgNodeCount:int

 <p>Export /keyword paths(rr5) seq.path

 <p>Function // reduceCrossings:graph.arc.layernode:graph.arc.layernode /id // #layernode /href /a reduceCrossings(gg1:graph.arc.layernode) graph.arc.layernode<br>//{reduce crossing using barycenter}/comment<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.nodes.gg1 // then /keyword gg1<br>// else /keyword // // let /keyword nodes = toseq.nodes.gg1<br>// for /keyword // acc5 = empty:seq.layernode<br>, layerno ∈ // //#arithseq:int:T:T:seq.T /href arithseq /a(layer.nodes // //#sub:seq.T:int:T /href sub /a n.nodes // //#/href-/a 1, 1, 2)/block // do /keyword // // for /keyword // ord = empty:seq.layernode<br>, bset = empty:seq.int<br>, e ∈ toseq.// //#findelement2:set.T:T:set.T /href findelement2 /a(nodes.gg1, layernode(0, layerno, 0))/block // do /keyword // // let /keyword preds = toseq.// //#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T /href predecessors /a(gg1, e)<br>// for /keyword sum = 0, p ∈ preds // do /keyword sum // //#+:int:int:int /href+/a pos.p<br>// let /keyword barycenter = 100 // //#*:int:int:int /href * /a sum // //#/:int:int:int /href / /a n.preds,<br>// let /keyword i = // //#abs:int:int /href abs /a.// //#/href binarysearch /a(bset, barycenter),<br>next(// // //#subseq:seq.T:int:int:seq.T /href subseq /a(ord, 1, i // //#/href-/a 1)<br> // //#/href+/a [e]<br> // //#/href+/a // //#subseq:seq.T:int:int:seq.T /href subseq /a(ord, i, n.ord)<br>, // //#subseq:seq.T:int:int:seq.T /href subseq /a(bset, 1, i // //#/href-/a 1)<br> // //#/href+/a [barycenter]<br> // //#/href+/a // //#subseq:seq.T:int:int:seq.T /href subseq /a(bset, i, n.bset)/block)/block //{assert n.nodes.gg1 /ne 13 report %.toseq.findelement2(nodes.gg1, layernode(0, 3, 0))+"ord::(ord)bary::(bset)"}/comment<br>// for /keyword acc6 = acc5, idx = 1, e ∈ ord<br>// do /keyword // next(// // if /keyword pos.e // //#=:int:int:boolean /href = /a idx // then /keyword acc6 // else /keyword acc6 // //#/href+/a layernode(no.e, layer.e, idx)<br>, idx // //#+:int:int:int /href+/a 1 /block), /block acc6, /block // if /keyword // //#isempty:seq.T:boolean /href isempty /a.acc5<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#n:set.T:int /href n /a.nodes.gg1 ≠ 13 // then /keyword gg1<br>// else /keyword // // let /keyword newnodes = // //#asset:seq.T:set.T /href asset /a.acc5 // //#/href ∪ /a nodes.gg1<br>// for /keyword newarcs = empty:seq.arc.layernode, a ∈ toseq.arcs.gg1<br>// do /keyword // newarcs<br> // //#/href+/a arc(newnodes // //#sub:set.T:int:T /href sub /a no.tail.a, newnodes // //#sub:set.T:int:T /href sub /a no.head.a), /block // //#newgraph:seq.T:graph.T /href newgraph /a.newarcs // //#/href+/a toseq.newnodes /block /block

 <p>// // orderNodes /id Module /keyword orderNodes.T

 <p>use graph.T

 <p>use set.T

 <p>use seq1.&lt;&lt;.T

 <p>use set.&lt;&lt;.T

 <p>use seq.set.&lt;&lt;.T

 <p>use standard

 <p>unbound /keyword addscc(order:seq.&lt;&lt;.T, scc:seq.&lt;&lt;.T) seq.&lt;&lt;.T

 <p>unbound /keyword toarc(&lt;&lt;.T) T

 <p>Function // orderNodes:set.&lt;&lt;.T:set.T:seq.&lt;&lt;.T /id // #orderNodes /href /a orderNodes(nodes:set.&lt;&lt;.T, arcs:set.T) seq.&lt;&lt;.T<br>//{forms a topological order of nodes in graph using a variant of Tarjan's algorithm for finding strongly connected compoents.}/comment<br>// for /keyword // order = empty:seq.&lt;&lt;.T<br>, orderset = // //#empty::set.T:set.T /href empty:set.&lt;&lt;.T /a<br>, remaining = nodes /block // while /keyword // //#n:set.T:int /href n /a.remaining // //#>:int:int:boolean /href > /a 0<br>// do /keyword // // let /keyword e = remaining // //#sub:set.T:int:T /href sub /a 1<br>// let /keyword succ = // //#successors:set.T:&lt;&lt;.T:set.&lt;&lt;.T:set.&lt;&lt;.T /href successors /a(arcs, e, orderset),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.succ // then /keyword // next(// // //#addscc:seq.&lt;&lt;.T:seq.&lt;&lt;.T:seq.&lt;&lt;.T /href addscc /a(order, [e])<br>, orderset // //#+:set.T:T:set.T /href+/a e<br>, // //#subseq:set.T:int:int:set.T /href subseq /a(remaining, 2, // //#n:set.T:int /href n /a.remaining)/block)/block // else /keyword // // let /keyword r = // //#f44:set.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:&lt;&lt;.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:r2.T /href f44 /a(arcs, order, orderset, e, empty:seq.&lt;&lt;.T, succ)<br>//{???? this messes up when accscc does not add all nodes to order}/comment<br>// let /keyword tmp = // //#asset:seq.T:set.T /href asset /a(order.r // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a n.order),<br>next(order.r, orderset // //#/href ∪ /a tmp, remaining // //#\:set.T:set.T:set.T /href \ /a tmp), /block /block order

 <p>Function // successors:set.T:&lt;&lt;.T:set.&lt;&lt;.T:set.&lt;&lt;.T /id // #orderNodes /href /a successors(arcs:set.T, n:&lt;&lt;.T, orderset:set.&lt;&lt;.T) set.&lt;&lt;.T<br>//{successors of n not in orderset}/comment<br>// for /keyword // acc = // //#empty::set.T:set.T /href empty:set.&lt;&lt;.T /a<br>, e ∈ toseq.// //#findelement2:set.T:T:set.T /href findelement2 /a(arcs, // //#toarc:T:arc.T /href toarc /a.n)/block // do /keyword // // if /keyword // //#head:barc.T:&lt;&lt;.T /href head /a.e // //#/href ∈ /a orderset // then /keyword acc<br>// else /keyword acc // //#+:set.T:T:set.T /href+/a // //#head:barc.T:&lt;&lt;.T /href head /a.e, /block acc

 <p>function // f44:set.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:&lt;&lt;.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:r2.T /id // #orderNodes /href /a f44(<br>arcs:set.T<br>, order0:seq.&lt;&lt;.T<br>, orderset0:set.&lt;&lt;.T<br>, this:&lt;&lt;.T<br>, stk0:seq.&lt;&lt;.T<br>, succ:set.&lt;&lt;.T<br>) r2.T<br>// for /keyword // order = order0<br>, orderset = orderset0<br>, stk = stk0 // //#/href+/a this<br>, lowlink = n.stk0 // //#+:int:int:int /href+/a 1<br>, e ∈ toseq.succ /block // do /keyword // // if /keyword e // //#/href ∈ /a orderset // then /keyword next(order, orderset, stk, lowlink)<br>// else /keyword // // let /keyword successors = // //#successors:set.T:&lt;&lt;.T:set.&lt;&lt;.T:set.&lt;&lt;.T /href successors /a(arcs, e, orderset),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.successors // then /keyword // next(// // //#addscc:seq.&lt;&lt;.T:seq.&lt;&lt;.T:seq.&lt;&lt;.T /href addscc /a(order, [e])<br>, orderset // //#+:set.T:T:set.T /href+/a e<br>, stk<br>, lowlink /block)/block // else /keyword // // let /keyword i = // //#findindex:seq.T:T:int /href findindex /a(stk, e),<br>// if /keyword i ≤ n.stk // then /keyword next(order, orderset, stk, // //#min:int:int:int /href min /a(i, lowlink))<br>// else /keyword // // let /keyword r = // //#f44:set.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:&lt;&lt;.T:seq.&lt;&lt;.T:set.&lt;&lt;.T:r2.T /href f44 /a(arcs, order, orderset, e, stk, successors),<br>next(order.r, orderset // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a(order.r // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a n.order), stk.r, // //#min:int:int:int /href min /a(lowlink, lowlink.r))/block /block /block /block // let /keyword i = // //#findindex:seq.T:T:int /href findindex /a(stk, this),<br>// if /keyword lowlink // //#=:int:int:boolean /href = /a i // then /keyword // r2(// // //#addscc:seq.&lt;&lt;.T:seq.&lt;&lt;.T:seq.&lt;&lt;.T /href addscc /a(order, stk // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (i // //#/href-/a 1))<br>, // //#subseq:seq.T:int:int:seq.T /href subseq /a(stk, 1, i // //#/href-/a 1)<br>, lowlink /block)/block // else /keyword r2(order, stk, lowlink)

 <p>type r2 is order:seq.&lt;&lt;.T, stk:seq.&lt;&lt;.T, lowlink:int

 <p>// // timestamp /id Module /keyword timestamp

 <p>use UTF8

 <p>use bits

 <p>use seq.byte

 <p>use standard

 <p>use kernal

 <p>Export /keyword type:timestamp

 <p>function // subseq:UTF8:int:int:UTF8 /id // #timestamp /href /a subseq(a:UTF8, i:int, j:int) UTF8 UTF8.// //#subseq:seq.T:int:int:seq.T /href subseq /a(toseqbyte.a, i, j)

 <p>Function // tojulian:int:int:int:int /id // #timestamp /href /a tojulian(year:int, month:int, day:int) int<br>// let /keyword ayear = // if /keyword month // //#>:int:int:boolean /href > /a 2 // then /keyword year // else /keyword year // //#/href-/a 1<br>// let /keyword amonth = // if /keyword month // //#>:int:int:boolean /href > /a 2 // then /keyword month // else /keyword month // //#+:int:int:int /href+/a 12,<br>(amonth // //#+:int:int:int /href+/a 1) // //#*:int:int:int /href * /a 306001 // //#/:int:int:int /href / /a 10000<br> // //#+:int:int:int /href+/a day<br> // //#+:int:int:int /href+/a 1720994<br> // //#+:int:int:int /href+/a 2<br> // //#/href-/a ayear // //#/:int:int:int /href / /a 100<br> // //#+:int:int:int /href+/a ayear // //#/:int:int:int /href / /a 100 // //#/:int:int:int /href / /a 4<br> // //#+:int:int:int /href+/a 1461 // //#*:int:int:int /href * /a ayear // //#/:int:int:int /href / /a 4

 <p>Function // dayofyear:timestamp:int /id // #timestamp /href /a dayofyear(t:timestamp) int<br>seconds.t // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60)<br> // //#/href-/a // //#tojulian:int:int:int:int /href tojulian /a(// // //#fromJuliantointseq:int:seq.int /href fromJuliantointseq /a(seconds.t // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60))<br> // //#sub:seq.T:int:T /href sub /a 1<br>, 1<br>, 1 /block)<br> // //#+:int:int:int /href+/a 1

 <p>Function // fromJuliantointseq:int:seq.int /id // #timestamp /href /a fromJuliantointseq(dt:int) seq.int<br>// let /keyword a = //((dt // //#+:int:int:int /href+/a 1) // //#*:int:int:int /href * /a 4 // //#/href-/a 7468865)<br> // //#/:int:int:int /href / /a 146097 /block // let /keyword b = dt // //#+:int:int:int /href+/a 1 // //#+:int:int:int /href+/a 1 // //#+:int:int:int /href+/a a // //#/href-/a a // //#/:int:int:int /href / /a 4 // //#+:int:int:int /href+/a 1524<br>// let /keyword c = (b // //#*:int:int:int /href * /a 20 // //#/href-/a 2442) // //#/:int:int:int /href / /a 7305<br>// let /keyword d = b // //#/href-/a 1461 // //#*:int:int:int /href * /a c // //#/:int:int:int /href / /a 4<br>// let /keyword e = d // //#*:int:int:int /href * /a 10000 // //#/:int:int:int /href / /a 306001<br>// let /keyword m = e // //#/href-/a (// if /keyword e // //#>:int:int:boolean /href > /a 13 // then /keyword 13 // else /keyword 1),<br>[// c // //#/href-/a (// if /keyword m // //#>:int:int:boolean /href > /a 2 // then /keyword 4716 // else /keyword 4715)<br>, m<br>, d // //#/href-/a e // //#*:int:int:int /href * /a 306001 // //#/:int:int:int /href / /a 10000 /block]

 <p>Function // timestamplit:UTF8:timestamp /id // #timestamp /href /a timestamplit(t:UTF8) timestamp<br>//{assumes t is in format 2019-12-12T12:48:11}/comment<br>// let /keyword year = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 1, 4)<br>// let /keyword month = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 6, 7)<br>// let /keyword day = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 9, 10)<br>// let /keyword hour = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 12, 13)<br>// let /keyword minutes = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 15, 16)<br>// let /keyword second = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 18, 19)<br>// let /keyword date = // //#tojulian:int:int:int:int /href tojulian /a(year, month, day),<br>timestamp(//((date // //#*:int:int:int /href * /a 24 // //#+:int:int:int /href+/a hour) // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a minutes)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a second /block)

 <p>Function // totimestamp:int:int:int:int:int:int:timestamp /id // #timestamp /href /a totimestamp(<br>year:int<br>, month:int<br>, day:int<br>, hour:int<br>, minute:int<br>, second:int<br>) timestamp<br>timestamp(//((// //#tojulian:int:int:int:int /href tojulian /a(year, month, day) // //#*:int:int:int /href * /a 24<br> // //#+:int:int:int /href+/a hour)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a minute)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a second /block)

 <p>Function // decompose:timestamp:seq.int /id // #timestamp /href /a decompose(ts:timestamp) seq.int<br>//{returns sequence of year, month, day, hour, minute, second}/comment<br>// let /keyword a = seconds.ts // //#mod:int:int:int /href mod /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60)<br>// let /keyword seconds = a // //#mod:int:int:int /href mod /a 60<br>// let /keyword minutes = a // //#/:int:int:int /href / /a 60 // //#mod:int:int:int /href mod /a 60<br>// let /keyword hours = a // //#/:int:int:int /href / /a 3600,<br>// //#fromJuliantointseq:int:seq.int /href fromJuliantointseq /a(seconds.ts // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60))<br> // //#/href+/a [hours, minutes, seconds]

 <p>Function // print:timestamp:seq.word /id // #timestamp /href /a print(ts:timestamp) seq.word<br>// let /keyword d = // //#decompose:timestamp:seq.int /href decompose /a.ts,<br>[// // //#/href merge /a.[// // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 1<br>, //"-"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 2<br>, //"-"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 3<br>, //"."/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 4<br>, //":"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 5<br>, //":"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 6 /block]/block]

 <p>Export /keyword seconds(t:timestamp) int

 <p>Export /keyword timestamp(seconds:int) timestamp

 <p>// // drawGraph /id Module /keyword drawGraph.&lt;&lt;.T

 <p>use arc.&lt;&lt;.T

 <p>use seq1.&lt;&lt;.T

 <p>use set.&lt;&lt;.T

 <p>use graph.T

 <p>use orderNodes.T

 <p>use set.T

 <p>use brandeskopf

 <p>use arc.int

 <p>use set.arc.int

 <p>use seq1.int

 <p>use layernode

 <p>use arc.layernode

 <p>use graph.arc.layernode

 <p>use seq.arc.layernode

 <p>use seq.layernode

 <p>use sort.layernode

 <p>use seq1.path

 <p>use sort.path

 <p>use standard

 <p>use svg

 <p>use uniqueids

 <p>use seq.seq.word

 <p>unbound /keyword %(&lt;&lt;.T) seq.word

 <p>unbound /keyword =(&lt;&lt;.T, &lt;&lt;.T) boolean

 <p>unbound /keyword nodeLabel(&lt;&lt;.T) seq.seq.word

 <p>unbound /keyword arcLabel(T) seq.seq.word

 <p>unbound /keyword head(T) &lt;&lt;.T

 <p>unbound /keyword tail(T) &lt;&lt;.T

 <p>unbound /keyword reverse(T) T

 <p>Function // drawgraph:seq.T:set.&lt;&lt;.T:set.&lt;&lt;.T:seq.word /id // #drawGraph /href /a drawgraph(arcs:seq.T, include:set.&lt;&lt;.T, exclude:set.&lt;&lt;.T) seq.word<br>// for /keyword arclist2 = empty:seq.T, a ∈ arcs<br>// do /keyword // // if /keyword // //#head:barc.T:&lt;&lt;.T /href head /a.a // //#/href ∈ /a exclude<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#not:boolean:boolean /href not /a.// //#isempty:set.T:boolean /href isempty /a.include<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#tail:barc.T:&lt;&lt;.T /href tail /a.a ∉ include // then /keyword arclist2<br>// else /keyword arclist2 // //#/href+/a a, /block // //#drawgraph:graph.T:seq.word /href drawgraph /a.// //#newgraph:seq.T:graph.T /href newgraph /a.arclist2

 <p>Function // drawgraph:graph.T:seq.word /id // #drawGraph /href /a drawgraph(g33:graph.T) seq.word<br>// let /keyword r = // //#layeredGraph:graph.T:rr5 /href layeredGraph /a.g33<br>// let /keyword nodepos = // //#assignx:graph.arc.layernode:int:int:seq.layernode /href assignx /a(g.r, orgNodeCount.r, 12)<br>// let /keyword nodes = toseq.nodes.g33<br>// let /keyword paths = // //#sort:seq.T:seq.T /href sort /a.paths.r<br>//{assert false report %n.paths}/comment<br>// let /keyword orgNodeCount = n.nodes<br>// let /keyword startid = // // //#requestids:int:int /href requestids /a(orgNodeCount // //#+:int:int:int /href+/a n.paths)<br> // //#+:int:int:int /href+/a // //#requestids:int:int /href requestids /a.1 /block // for /keyword txt = //""/literal, id2 = startid, i = 1<br>// while /keyword i ≤ orgNodeCount<br>// do /keyword // next(// txt // //#/href+/a // //#nodetext:layernode:int:seq.&lt;&lt;.T:seq.word /href nodetext /a(nodepos // //#sub:seq.T:int:T /href sub /a i, id2, nodes)<br>, id2 // //#+:int:int:int /href+/a 1<br>, i // //#+:int:int:int /href+/a 1 /block)/block // for /keyword out = txt, maxx0 = 0, maxy0 = 0, id = id2, lastno = 0, draw4 = //""/literal, path ∈ paths<br>// do /keyword // // let /keyword a = // //#nodes:path:seq.int /href nodes /a.path<br>//{assert false report"here:(path)"}/comment<br>// let /keyword startnode = nodepos // //#sub:seq.T:int:T /href sub /a (a // //#sub:seq.T:int:T /href sub /a 1)<br>// let /keyword newdraw = // // if /keyword no.startnode // //#=:int:int:boolean /href = /a lastno // then /keyword draw4 // //#/href+/a //",:(id)"/literal<br>// else /keyword // draw4<br> // //#/href+/a //"],[:(startid // //#+:int:int:int /href+/a (no.startnode // //#/href-/a 1)),:(id)"/literal /block /block // let /keyword from = // if /keyword n.a // //#=:int:int:boolean /href = /a 2 // then /keyword pos.startnode // else /keyword 0<br>// for /keyword // d = //"M 0 0"/literal<br>, from0 = 0<br>, from1 = from<br>, maxx1 = maxx0<br>, maxy1 = maxy0<br>, p ∈ a // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1 /block // do /keyword // // let /keyword xy = nodepos // //#sub:seq.T:int:T /href sub /a p<br>// let /keyword nodex = layer.xy,<br>// let /keyword nodey = pos.xy,<br>next(// d // //#/href+/a //"L"/literal // //#/href+/a // //#%:int:seq.word /href % /a.nodex // //#/href+/a // //#%:int:seq.word /href % /a.nodey<br>, from1<br>, pos.xy<br>, // //#max:int:int:int /href max /a(nodex, maxx1)<br>, // //#max:int:int:int /href max /a(nodey, maxy1)/block)/block // let /keyword pth = // //#svgpath:seq.word:seq.word:seq.word:seq.word /href svgpath /a([class.path], [// //#toword:int:word /href toword /a.id], d)<br>// let /keyword label = // //#arcLabel:set.arc.T:T:T:seq.seq.word /href arcLabel /a(arcs.g33, (nodes.g33) // //#sub:set.T:int:T /href sub /a (a // //#sub:seq.T:int:T /href sub /a 1), (nodes.g33) // //#sub:set.T:int:T /href sub /a (a // //#sub:seq.T:int:T /href sub /a n.a)),<br>// let /keyword arclabel = // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.label // then /keyword //""/literal<br>// else /keyword //{"/tag &lt;text /sp class = /tag:(dq."nodes")> /tag &lt;textPath /sp href = /tag:(dq.[merge("#"+toword.id)])startOffset = /tag:(dq."100%")text-anchor = /tag:(dq."end")> /tag &lt;tspan /sp = /tag:(dq."-0.1")>:(label sub 2)/tag &lt;/tspan>&lt;/textPath>&lt;/text>"}<br>// //#atts:seq.word:seq.word /href atts /a.//"/tag &lt;text = class = nodes /sp /tag &lt;br /tag > /nsp<br>/tag >&lt;textPath = href = # /nsp:(// //#toword:int:word /href toword /a.id)= startOffset = 100% = text-anchor = end /sp /tag &lt;br /tag > /nsp<br>/tag >&lt;tspan>:(label // //#sub:seq.T:int:T /href sub /a 2)/tag &lt;/tspan>&lt;/textPath>&lt;/text>"/literal<br> // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[char.10], /block /block next(// out // //#/href+/a pth // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[char.10] // //#/href+/a arclabel<br>, maxx1<br>, maxy1<br>, id // //#+:int:int:int /href+/a 1<br>, no.startnode<br>, newdraw /block), /block // //#svg:seq.seq.word:seq.seq.word:seq.word:seq.word /href svg /a(//[// //".reversed{fill:none ; stroke:red ; stroke-width:.07 ; stroke-dasharray:1 1 ;}"/literal<br>, //".both{fill:none ; stroke:black ; stroke-width:0.14 ;}"/literal<br>, //".arc{fill:none ; stroke:black ; stroke-width:.07 ;}"/literal<br>, //".nodes{dominant-baseline:hanging; font: 1px sans-serif ; stroke-width:.1 ;}"/literal<br>, //"svg g:hover text{opacity:1;}"/literal<br>, //"svg g:hover rect{opacity:1;}"/literal /block]<br>, [// //"id = svg10"/literal<br>, //"viewBox 5 /sp-1:(maxx0 // //#+:int:int:int /href+/a 5):(maxy0 // //#+:int:int:int /href+/a 5)"/literal<br>, //"onload[:(draw4 // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 2)]].forEach(shiftstart)"/literal /block]<br>, out /block)<br> // //#/href+/a // //#drawscript:seq.word /href drawscript /a

 <p>Function // layeredGraph:graph.T:rr5 /id // #drawGraph /href /a layeredGraph(org:graph.T) rr5<br>// let /keyword arcstoreverse2 = // //#arcsToReverse:graph.T:seq.T /href arcsToReverse /a.org<br>// for /keyword // reversed2 = // //#empty::set.T:set.T /href empty:set.arc.int /a<br>, reversedarcs = empty:seq.T<br>, arc ∈ arcstoreverse2 /block // do /keyword // next(// reversed2<br> // //#+:set.T:T:set.T /href+/a arc(// // //#findindex:set.T:T:int /href findindex /a(nodes.org, // //#head:barc.T:&lt;&lt;.T /href head /a.arc)<br>, // //#findindex:set.T:T:int /href findindex /a(nodes.org, // //#tail:barc.T:&lt;&lt;.T /href tail /a.arc)/block)<br>, reversedarcs // //#/href+/a // //#/href reverse /a.arc /block)/block // let /keyword gin = // // //#replacearcs:graph.T:set.T:set.T:graph.T /href replacearcs /a(// org<br>, // //#asset:seq.T:set.T /href asset /a.arcstoreverse2<br>, // //#asset:seq.T:set.T /href asset /a.reversedarcs /block)/block // for /keyword // g = gin<br>, xx = empty:seq.arc.layernode<br>, lowlayersnodes = empty:seq.layernode<br>, remaining = nodes.gin<br>, nextpos = [1]<br>, lastNodeNo = // //#n:set.T:int /href n /a.nodes.gin<br>, paths1 = empty:seq.path /block // while /keyword // //#not:boolean:boolean /href not /a.// //#isempty:set.T:boolean /href isempty /a.remaining<br>// do /keyword // // for /keyword // xx2 = xx<br>, acc2 = lowlayersnodes<br>, handled = // //#empty::set.T:set.T /href empty:set.&lt;&lt;.T /a<br>, lastNodeNo2 = lastNodeNo<br>, nextpos2a = nextpos<br>, paths2 = paths1<br>, n ∈ toseq.remaining /block // do /keyword // // let /keyword preds = toseq.// //#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T /href predecessors /a(g, n)<br>// for /keyword nopred = true, e ∈ preds // while /keyword nopred // do /keyword e ∉ remaining,<br>// if /keyword // //#not:boolean:boolean /href not /a.nopred // then /keyword next(xx2, acc2, handled, lastNodeNo2, nextpos2a, paths2)<br>// else /keyword // // let /keyword newnode = // layernode(// // //#findindex:set.T:T:int /href findindex /a(nodes.g, n)<br>, n.nextpos<br>, nextpos2a // //#sub:seq.T:int:T /href sub /a n.nextpos /block)/block // let /keyword nextpos2 = nextpos2a // //#>>:seq.T:int:seq.T /href >> /a 1 // //#/href+/a (pos.newnode // //#+:int:int:int /href+/a 1)<br>// for /keyword xx3 = xx2, lastNodeNo3 = lastNodeNo2, nextpos3 = nextpos2, paths3 = paths2, e ∈ preds<br>// do /keyword // // let /keyword find = // //#findindex:set.T:T:int /href findindex /a(nodes.g, e)<br>// let /keyword t = lowlayersnodes // //#sub:seq.T:int:T /href sub /a // //#/href binarysearch>3 /a(lowlayersnodes, layernode(find, 0, 0))<br>//{adding new arc(t, newnode)}/comment<br>// let /keyword nodummynodes = layer.newnode // //#/href-/a layer.t // //#/href-/a 1<br>// let /keyword a = // //#lookup:set.T:T:set.T /href lookup /a(reversed2, arc(no.t, no.newnode))<br>// let /keyword class = // // if /keyword // //#isempty:set.T:boolean /href isempty /a.a // then /keyword //"arc"/literal // //#sub:seq.T:int:T /href sub /a 1<br>// else /keyword if e // //#/href ∈ /a // //#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T /href predecessors /a(org, n) // then /keyword //"both"/literal // //#sub:seq.T:int:T /href sub /a 1<br>// else /keyword //"reversed"/literal // //#sub:seq.T:int:T /href sub /a 1, /block // let /keyword path = // path(// no.t<br>, no.newnode<br>, // if /keyword nodummynodes // //#=:int:int:boolean /href = /a 0 // then /keyword 0 // else /keyword lastNodeNo3 // //#+:int:int:int /href+/a 1<br>, lastNodeNo3 // //#+:int:int:int /href+/a nodummynodes<br>, class /block), /block // if /keyword nodummynodes // //#=:int:int:boolean /href = /a 0 // then /keyword next(xx3 // //#/href+/a arc(t, newnode), lastNodeNo3, nextpos3, paths3 // //#/href+/a path)<br>// else /keyword // // for /keyword // newarcs = empty:seq.arc.layernode<br>, last = t<br>, nextpos4 = // //#subseq:seq.T:int:int:seq.T /href subseq /a(nextpos3, 1, layer.t)<br>, nn ∈ // //#arithseq:int:T:T:seq.T /href arithseq /a(nodummynodes, 1, lastNodeNo3 // //#+:int:int:int /href+/a 1)/block // do /keyword // // let /keyword tmp = layernode(nn, layer.last // //#+:int:int:int /href+/a 1, nextpos3 // //#sub:seq.T:int:T /href sub /a (layer.last // //#+:int:int:int /href+/a 1)),<br>next(newarcs // //#/href+/a arc(last, tmp), tmp, nextpos4 // //#/href+/a (pos.tmp // //#+:int:int:int /href+/a 1))/block // let /keyword newarcs1 = newarcs // //#/href+/a arc(last, newnode),<br>// let /keyword z = nextpos4 // //#/href+/a nextpos3 // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a n.nextpos4,<br>next(xx3 // //#/href+/a newarcs1, lastNodeNo3 // //#+:int:int:int /href+/a nodummynodes, z, paths3 // //#/href+/a path), /block /block //{end adding new arc(t, newnode)}/comment<br>next(xx3, acc2 // //#/href+/a newnode, handled // //#+:set.T:T:set.T /href+/a n, lastNodeNo3, nextpos3, paths3)/block /block // assert /keyword // //#n:set.T:int /href n /a.handled // //#>:int:int:boolean /href > /a 0 // report /keyword // // let /keyword on = // //#orderNodes:set.&lt;&lt;.T:set.T:seq.&lt;&lt;.T /href orderNodes /a(nodes.g, arcs.g)<br>// for /keyword txt = //""/literal, k = empty:seq.&lt;&lt;.T, e ∈ on<br>// do /keyword // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.k // then /keyword next(txt, k // //#/href+/a e)<br>// else /keyword if k // //#sub:seq.T:int:T /href sub /a 1 = e // then /keyword // // if /keyword n.k // //#=:int:int:boolean /href = /a 1 // then /keyword next(txt, empty:seq.&lt;&lt;.T)<br>// else /keyword next(txt // //#/href+/a //"/sp /tag &lt;br /tag > /nsp:(k)"/literal, empty:seq.&lt;&lt;.T)/block // else /keyword next(txt, k // //#/href+/a e), /block //"XXX:(toseq.remaining)/sp /tag &lt;br /tag > /nsp:(txt)"/literal, /block next(// g<br>, xx2<br>, // //#sort>3:seq.T:seq.T /href sort>3 /a.acc2<br>, remaining // //#\:set.T:set.T:set.T /href \ /a handled<br>, nextpos2a // //#/href+/a [1]<br>, lastNodeNo2<br>, paths2 /block)/block // for /keyword txt = //""/literal, e ∈ xx<br>// do /keyword txt // //#/href+/a //"/sp /tag &lt;br /tag > /nsp:(tail.e)----:(head.e):(layer.tail.e // //#/href-/a layer.head.e)"/literal<br>// let /keyword gg1 = // //#newgraph:seq.T:graph.T /href newgraph /a.xx // //#/href+/a lowlayersnodes,<br>rr5(// // //#reduceCrossings:graph.arc.layernode:graph.arc.layernode /href reduceCrossings /a.gg1<br>, paths1<br>, // //#n:set.T:int /href n /a.nodes.org /block)

 <p>function // %:arc.&lt;&lt;.T:seq.word /id // #drawGraph /href /a %(a:arc.&lt;&lt;.T) seq.word //"{:(tail.a):(head.a)}"/literal

 <p>function // =:arc.&lt;&lt;.T:arc.&lt;&lt;.T:boolean /id // #drawGraph /href /a =(a:arc.&lt;&lt;.T, b:arc.&lt;&lt;.T) boolean tail.a = tail.b // //#∧:boolean:boolean:boolean /href ∧ /a head.a = head.b

 <p>function // arcsToReverse:graph.T:seq.T /id // #drawGraph /href /a arcsToReverse(g3:graph.T) seq.T<br>// let /keyword on = // //#orderNodes:set.&lt;&lt;.T:set.T:seq.&lt;&lt;.T /href orderNodes /a(nodes.g3, arcs.g3)<br>// for /keyword arcstoreverse2 = empty:seq.T, k = empty:seq.&lt;&lt;.T, e ∈ on<br>// do /keyword // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.k // then /keyword next(arcstoreverse2, k // //#/href+/a e)<br>// else /keyword if k // //#sub:seq.T:int:T /href sub /a 1 = e // then /keyword // // if /keyword n.k // //#=:int:int:boolean /href = /a 1 // then /keyword next(arcstoreverse2, empty:seq.&lt;&lt;.T)<br>// else /keyword // // for /keyword arcstoreverse3 = arcstoreverse2, e2 ∈ k<br>// do /keyword // // for /keyword // arcstoreverse4 = arcstoreverse3<br>, arc ∈ toseq.// //#arcstosuccessors:graph.T:&lt;&lt;.T:set.T /href arcstosuccessors /a(g3, e2)/block // do /keyword // // let /keyword e3 = // //#head:barc.T:&lt;&lt;.T /href head /a.arc,<br>// if /keyword // //#findindex:seq.T:T:int /href findindex /a(k, e2) // //#>:int:int:boolean /href > /a // //#findindex:seq.T:T:int /href findindex /a(k, e3) // then /keyword arcstoreverse4 // //#/href+/a arc<br>// else /keyword arcstoreverse4, /block arcstoreverse4, /block next(arcstoreverse3, empty:seq.&lt;&lt;.T)/block /block // else /keyword next(arcstoreverse2, k // //#/href+/a e), /block arcstoreverse2

 <p>Function // addscc:seq.&lt;&lt;.T:seq.&lt;&lt;.T:seq.&lt;&lt;.T /id // #drawGraph /href /a addscc(s:seq.&lt;&lt;.T, scc:seq.&lt;&lt;.T) seq.&lt;&lt;.T<br>//{if n.scc = 1 then s else}/comment<br>s // //#/href+/a scc // //#/href+/a scc // //#sub:seq.T:int:T /href sub /a 1

 <p>unbound /keyword arcLabel(set.T, &lt;&lt;.T, &lt;&lt;.T) seq.seq.word

 <p>function // nodetext:layernode:int:seq.&lt;&lt;.T:seq.word /id // #drawGraph /href /a nodetext(startnode:layernode, htmlid:int, nodes:seq.&lt;&lt;.T) seq.word<br>// let /keyword nodex = layer.startnode<br>// let /keyword nodey = pos.startnode<br>// let /keyword tmp0 = nodeLabel.nodes // //#sub:seq.T:int:T /href sub /a no.startnode<br>// let /keyword name = tmp0 // //#sub:seq.T:int:T /href sub /a 2<br>// let /keyword hover = tmp0 // //#sub:seq.T:int:T /href sub /a 3,<br>// //#text:seq.word:seq.word:int:int:seq.word:seq.word /href text /a(//"nodes"/literal, [// //#toword:int:word /href toword /a.htmlid], nodex, nodey, name)<br> // //#/href+/a // //#hovertext:int:int:int:seq.word:seq.word /href hovertext /a(no.startnode, nodex, nodey, hover)<br> // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[char.10]

 <p>// // svg /id Module /keyword svg

 <p>use seq1.int

 <p>use seq1.seq.int

 <p>use sort.seq.int

 <p>use layernode

 <p>use seq.layernode

 <p>use standard

 <p>use uniqueids

 <p>Function // text:seq.word:seq.word:int:int:seq.word:seq.word /id // #svg /href /a text(class:seq.word, id:seq.word, x:int, y:int, w:seq.word) seq.word<br>//{"/tag &lt;text /sp class = /tag:(dq.class):(if id =""then id else"id = /tag:(dq.id)")x = /tag:(dq.%.x)y = /tag:(dq.%.y)>:(w)/tag &lt;/text>"}/comment<br>// //#atts:seq.word:seq.word /href atts /a.//"/tag &lt;text = class =:(class)=:((// if /keyword id // //#=:seq.T:seq.T:boolean /href = /a //""/literal // then /keyword id // else /keyword //"id =:(id)="/literal))x =:(x)= y =:(y)/sp /tag &lt;br /tag > /nsp >:(w)/tag &lt;/text>"/literal

 <p>Function // svgpath:seq.word:seq.word:seq.word:seq.word /id // #svg /href /a svgpath(class:seq.word, id:seq.word, path:seq.word) seq.word<br>// //#atts:seq.word:seq.word /href atts /a.//"/tag &lt;path = class =:(class)=:((// if /keyword id // //#=:seq.T:seq.T:boolean /href = /a //""/literal // then /keyword id // else /keyword //"id =:(id)="/literal))d =:(path)/sp /tag &lt;br /tag > /nsp />"/literal

 <p>"<path class =:(dq.class):(if id =""then id else"id =:(dq.id)")d =:(dq.path)/>"

 <p>Function // svg:seq.seq.word:seq.seq.word:seq.word:seq.word /id // #svg /href /a svg(classes2:seq.seq.word, otherAttributes:seq.seq.word, body:seq.word) seq.word<br>// for /keyword att = //""/literal, e ∈ otherAttributes<br>// do /keyword // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.e // then /keyword //""/literal<br>// else /keyword // att<br> // //#/href+/a //":(e // //#sub:seq.T:int:T /href sub /a 1)=:(// //#/href dq /a.//"/nsp:(e // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1)"/literal)"/literal /block /block // for /keyword // acc = //""/literal<br>, e ∈ // for /keyword acc2 = empty:seq.seq.word, e ∈ classes2 // do /keyword acc2 // //#/href+/a //""/literal // //#/href+/a e,<br>acc2 /block // do /keyword acc // //#/href+/a e<br>// let /keyword classdefs = // // //#atts:seq.word:seq.word /href atts /a.//"/tag &lt;style = type = text/css /sp /tag &lt;br /tag > /nsp<br>> /tag &lt;"/literal<br> // //#/href+/a acc<br> // //#/href+/a //"/tag >&lt;/style>"/literal, /block //"/tag &lt;svg /sp:(att)>:(classdefs):(body)Your browser does not support inline SVG. /tag &lt;/svg>"/literal

 <p>Function // drawscript:seq.word /id // #svg /href /a drawscript seq.word<br>//{Adjust beginning of paths so the start at the end of the word}/comment<br>//"/tag &lt;script> function shiftstart(arcs){let bb = document.getElementById(arcs[0]).getBBox(); arcs.forEach(function(idval, index){if(index > 0){let element = document.getElementById(idval); let d = /tag:(// //#/href dq /a.//"M"/literal)+(bb.x+bb.width)+/tag:(// //#/href dq /a.//","/literal)+(bb.y+bb.height / 2)+element.getAttribute(/tag:(// //#/href dq /a.//"/nsp d"/literal)).substring(5); element.setAttribute(/tag:(// //#/href dq /a.//"/nsp d"/literal), d);}});}/tag &lt;/script>"/literal<br> // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[char.10]

 <p>Function // atts:seq.word:seq.word /id // #svg /href /a atts(s:seq.word) seq.word<br>// for /keyword state = 0, acc = //""/literal, acc2 = //""/literal, w ∈ s<br>// do /keyword // // let /keyword new = // // if /keyword w // //#/href ∈ /a //"/tag /sp"/literal // then /keyword acc2 // //#/href+/a // //#/href merge /a(//"?"/literal // //#/href+/a w) // else /keyword acc2 // //#/href+/a //"::(state)"/literal // //#/href+/a w, /block // if /keyword state // //#=:int:int:boolean /href = /a 0 // //#∧:boolean:boolean:boolean /href ∧ /a w // //#/href ∈ /a //"="/literal // then /keyword next(1, acc // //#/href+/a //"/sp"/literal, new)<br>// else /keyword if state // //#=:int:int:boolean /href = /a 1 // //#∧:boolean:boolean:boolean /href ∧ /a w // //#/href ∈ /a //"="/literal // then /keyword next(2, acc // //#/href+/a //"/nsp ="/literal // //#/href+/a // //#/href dq /a // //#/href+/a //"/nsp"/literal, new)<br>// else /keyword if state // //#=:int:int:boolean /href = /a 2 // //#∧:boolean:boolean:boolean /href ∧ /a w // //#/href ∈ /a //"="/literal // then /keyword next(1, acc // //#/href+/a //"/nsp"/literal // //#/href+/a // //#/href dq /a // //#/href+/a //"/sp"/literal, new)<br>// else /keyword if state // //#=:int:int:boolean /href = /a 2 // //#∧:boolean:boolean:boolean /href ∧ /a w // //#/href ∈ /a //"/sp /tag &lt;br /tag > /nsp"/literal // then /keyword next(0, acc // //#/href+/a //"/nsp"/literal // //#/href+/a // //#/href dq /a, new)<br>// else /keyword next(state, acc // //#/href+/a w, new)/block // assert /keyword state // //#=:int:int:boolean /href = /a 0 // report /keyword //{for txt2 ="", w ∈ s do if w ∈"/tag /sp"then txt2+merge("?"+w)else txt2+w}<br>//"incorrect format on atts"/literal<br> // //#/href+/a acc2, /block acc

 <p>Function // hovertext:int:int:int:seq.word:seq.word /id // #svg /href /a hovertext(n:int, nodex:int, nodey:int, hovertext:seq.word) seq.word<br>// //#atts:seq.word:seq.word /href atts /a.//"/tag &lt;g>&lt;rect = opacity = 0.0 = x =:(nodex)= y =:(nodey)= height = 0.5 = width = 1 /sp /tag &lt;br /tag > /nsp<br>/tag >&lt;/rect>&lt;rect = pointer-events = none = fill = white = opacity = 0.0 = x =:(nodex)= y =:(nodey)= height = 1 = width = 100 /sp /tag &lt;br /tag > /nsp<br>/tag >&lt;/rect>&lt;text = pointer-events = none = class = nodes = x =:(nodex)= y =:(nodey)= opacity = 0.0 = x =:(nodex)= y =:(nodey)/sp /tag &lt;br /tag > /nsp >:(hovertext)/tag &lt;/text>&lt;/g>"/literal<br> // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[char.10]

 <p>Function // nodeLabel:int:seq.seq.word /id // #svg /href /a nodeLabel(i:int) seq.seq.word [//""/literal, // //#%:int:seq.word /href % /a.i, //""/literal]

 <p>Function // nodeLabel:word:seq.seq.word /id // #svg /href /a nodeLabel(n:word) seq.seq.word [//""/literal, // //#%:word:seq.word /href % /a.n, //""/literal]

 <p>Function // nodeLabel:seq.word:seq.seq.word /id // #svg /href /a nodeLabel(n:seq.word) seq.seq.word [//""/literal, n, //""/literal]

 <p>// // stateFunctions /id Module /keyword stateFunctions

 <p>use kernal

 <p>Builtin /keyword // spacecount

 <p>Builtin /keyword // clock

 <p>Builtin /keyword // randomint

 <p>Builtin /keyword // currenttime

 <p>  