<!doctype html> <html lang="en"> <meta charset="utf-8"> <p> <link rel="stylesheet" href="../daws/codeExample.css"> <p> <br> <p> <span class="keyword" id="webIOtypes">Module</span> webIOtypes <p>use JS.HTTPresult <p>use UTF8 <p>use bits <p>use seq.byte <p>use bitcast.seq.byte <p>use bitcast.int <p>use ptr <p>use real <p>use standard <p>use textio <p> <a id="set2zero:ptr:int:ptr" href="#webIOtypes">Function</a> set2zero(p:ptr, size:int) ptr <br> <span class="comment">{used in wasm2.ls}</span> <br> <span class="keyword">if</span> size <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> p <span class="keyword">else</span> <a href="#set2zero:ptr:int:ptr">set2zero</a>(set(p, 0), size <a href="#">-</a> 1) <p> <a id="empty::JS.HTTPresult:JS.HTTPresult" href="#webIOtypes">Function</a> empty:JS.HTTPresult JS.HTTPresult <br> <a href="#toJS:T:JS.T">toJS</a>.HTTPresult( <a href="#emptyUTF8:UTF8">emptyUTF8</a>, empty:seq.byte) <p>type jsbytes is toreal:real <p> <span class="keyword">Export</span> toreal(jsbytes) real <p> <span class="keyword">Export</span> jsbytes(real) jsbytes <p> <span class="keyword">Export</span> type:jsbytes <p> <span class="keyword">Export</span> type:HTTPresult <p> <span class="keyword">Export</span> type:jsbytes <p>type HTTPresult is header:UTF8, result:seq.byte <p> <span class="keyword">Export</span> HTTPresult(header:UTF8, result:seq.byte) HTTPresult <p> <span class="keyword">Export</span> result(HTTPresult) seq.byte <p> <span class="keyword">Export</span> header(HTTPresult) UTF8 <p> <a id="aborted:HTTPresult:boolean" href="#webIOtypes">Function</a> aborted(h:HTTPresult) boolean <br> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseqbyte.header.h, 1, 1) <br> ≠ [ <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"2"</span>] <p> <a id="token:seq.word:jsbytes" href="#webIOtypes">Function</a> token(s:seq.word) jsbytes <br> <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte( <span class="block"> <span class="keyword">for</span> acc = <a href="#emptyUTF8:UTF8">emptyUTF8</a>, w ∈ s <br> <span class="keyword">do</span> acc <a href="#+:UTF8:seq.char:UTF8">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.w, <br>acc</span>) <p> <a id="jsUTF8:seq.byte:jsbytes" href="#webIOtypes">Function</a> jsUTF8(t:seq.byte) jsbytes <br> <span class="comment">{OPTION NOINLINE}</span> <br>jsbytes. <a href="#toreal:int:real">toreal</a>.bitcast:int(toptr. <a href="#T:state">packed</a>.t) <p> <a id="towords:jsbytes:seq.word" href="#webIOtypes">Function</a> towords(a:jsbytes) seq.word <br> <a href="#towords:UTF8:seq.word">towords</a>.UTF8. <a href="#toseqbyte:jsbytes:seq.byte">toseqbyte</a>.a <p> <a id="toseqbyte:jsbytes:seq.byte" href="#webIOtypes">Function</a> toseqbyte(a:jsbytes) seq.byte bitcast:seq.byte(toptr. <a href="#">intpart</a>.toreal.a) <p> <span class="keyword" id="webIO">Module</span> webIO <p>use SpecialImports <p>use UTF8 <p>use bits <p>use file <p>use real <p>use standard <p>use textio <p>use webIOtypes <p>use webHTTP.seq.word <p>use JS.HTTPresult <p> <span class="keyword">Export</span> type:jsbytes <p> <span class="keyword">Export</span> towords(a:jsbytes) seq.word <p> <span class="keyword">Export</span> setElementValue(id:seq.word, text:seq.word) real <p> <span class="keyword">Export</span> getattributes(id:seq.word, attributes:seq.word) seq.word <p> <span class="keyword">Export</span> setAttribute(id:seq.word, att:seq.word, value:seq.word) real <p> <span class="keyword">Export</span> replaceSVG(name:seq.word, xml0:seq.word) real <p> <span class="keyword">Export</span> getElementValue(id:seq.word) seq.word <p> <span class="keyword">Export</span> getElementValue:jsbytes(id:seq.word) jsbytes <p> <span class="keyword">Export</span> jsUTF8(t:seq.byte) jsbytes <p> <span class="keyword">Export</span> callevent(id:seq.word, event:seq.word) real <p> <a id="setElementValue:seq.word:jsbytes:real" href="#webIO">Function</a> setElementValue(id:seq.word, text:jsbytes) real <br> <span class="comment">{OPTION NOINLINE}</span> <br> <a href="#setelementvalue:jsbytes:jsbytes:real">setelementvalue</a>( <a href="#token:seq.word:jsbytes">token</a>.id, text) <p> <a id="setElementValue:seq.word:seq.word:real" href="#webIO">Function</a> setElementValue(id:seq.word, text:seq.word) real <br> <span class="comment">{OPTION NOINLINE}</span> <br> <a href="#setelementvalue:jsbytes:jsbytes:real">setelementvalue</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.id <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#HTMLformat:seq.word:UTF8">HTMLformat</a>.text</span>) <p> <a id="getElementValue:seq.word:seq.word" href="#webIO">Function</a> getElementValue(id:seq.word) seq.word <br> <a href="#towords:jsbytes:seq.word">towords</a>. <a href="#getelementvalue:jsbytes:jsbytes">getelementvalue</a>. <a href="#token:seq.word:jsbytes">token</a>.id <p> <a id="getElementValue::jsbytes:seq.word:jsbytes" href="#webIO">Function</a> getElementValue:jsbytes(id:seq.word) jsbytes <br> <a href="#getelementvalue:jsbytes:jsbytes">getelementvalue</a>. <a href="#token:seq.word:jsbytes">token</a>.id <p> <a id="getattributes:seq.word:seq.word:seq.word" href="#webIO">Function</a> getattributes(id:seq.word, attributes:seq.word) seq.word <br> <a href="#towords:jsbytes:seq.word">towords</a>. <a href="#getattributes2:jsbytes:jsbytes:jsbytes">getattributes2</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.id <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#HTMLformat:seq.word:UTF8">HTMLformat</a>.attributes</span>) <p> <a id="getURLargs:seq.word" href="#webIO">Function</a> getURLargs seq.word <a href="#towords:jsbytes:seq.word">towords</a>.URLargs <p> <a id="getLines:seq.word:seq.seq.word" href="#webIO">Function</a> getLines(id:seq.word) seq.seq.word <br> <span class="keyword">let</span> a = <span class="block"> <a href="#toseqbyte:jsbytes:seq.byte">toseqbyte</a>. <a href="#getattributes2:jsbytes:jsbytes:jsbytes">getattributes2</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.id <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#HTMLformat:seq.word:UTF8">HTMLformat</a>. <span class="literal">"textContent"</span></span>)</span> <span class="keyword">for</span> acc = empty:seq.seq.word, l ∈ <a href="#breaklines:seq.byte:seq.UTF8">breaklines</a>.a <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#towords:UTF8:seq.word">towords</a>.l, <br>acc <p> <a id="setAttribute:seq.word:seq.word:seq.word:real" href="#webIO">Function</a> setAttribute(id:seq.word, att:seq.word, value:seq.word) real <br> <a href="#setattribute2:jsbytes:jsbytes:jsbytes:real">setattribute2</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.id <br>, <a href="#token:seq.word:jsbytes">token</a>.att <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#HTMLformat:seq.word:UTF8">HTMLformat</a>.value</span>) <p> <a id="openWindow:seq.word:real" href="#webIO">Function</a> openWindow(name:seq.word) real <br> <a href="#openWindow2:jsbytes:real">openWindow2</a>. <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#HTMLformat:seq.word:UTF8">HTMLformat</a>.name <p> <a id="callevent:seq.word:seq.word:real" href="#webIO">Function</a> callevent(id:seq.word, event:seq.word) real <br> <span class="comment">{OPTION NOINLINE}</span> <br> <a href="#callevent2:jsbytes:jsbytes:real">callevent2</a>( <a href="#token:seq.word:jsbytes">token</a>.id, <a href="#token:seq.word:jsbytes">token</a>.event) <p> <a id="replaceSVG:seq.word:seq.word:real" href="#webIO">Function</a> replaceSVG(name:seq.word, xml0:seq.word) real <br> <span class="keyword">let</span> none = <span class="literal">"N"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">let</span> xml = <span class="block"> <span class="keyword">for</span> xml = <span class="literal">""</span>, hasquote = none, w ∈ xml0 <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <a href="#">dq</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> hasquote <a href="#=:word:word:boolean">=</a> none <span class="keyword">then</span> next(xml <a href="#">+</a> <span class="literal">"/tag"</span> <a href="#">+</a> w, w) <br> <span class="keyword">else</span> next(xml <a href="#">+</a> w, none)</span> <span class="keyword">else</span> if w <a href="#=:word:word:boolean">=</a> <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> next(xml <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.[char.10], hasquote) <br> <span class="keyword">else</span> next(xml <a href="#">+</a> w, hasquote),</span> xml,</span> <a href="#replacesvg:jsbytes:jsbytes:real">replacesvg</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.name <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#textformat:seq.word:UTF8">textformat</a>.xml</span>) <p> <a id="HTTPwords:JS.HTTPstate.seq.word:JS.HTTPresult:real" href="#webIO">Function</a> HTTPwords(h2:JS.HTTPstate.seq.word, h:JS.HTTPresult) real <a href="#decodeZ:JS.HTTPstate.T:JS.HTTPresult:real">decodeZ</a>(h2, h) <p> <a id="writefiles:seq.file:seq.word:seq.word:real" href="#webIO">Function</a> writefiles(files:seq.file, state:seq.word, callback:seq.word) real <br> <a href="#HTTPwords:JS.HTTPstate.seq.word:JS.HTTPresult:real">HTTPwords</a>( <span class="block"> <a href="#writearg:seq.file:T:seq.word:seq.word:JS.HTTPstate.T">writearg</a>(files, state, callback, <span class="literal">"HTTPwords"</span>) <br>, <a href="#empty::JS.HTTPresult:JS.HTTPresult">empty:JS.HTTPresult</a></span>) <p> <a id="readfiles:seq.file:seq.word:seq.word:real" href="#webIO">Function</a> readfiles(files:seq.file, state:seq.word, callback:seq.word) real <br> <a href="#HTTPwords:JS.HTTPstate.seq.word:JS.HTTPresult:real">HTTPwords</a>( <span class="block"> <a href="#readarg:seq.file:T:seq.word:seq.word:JS.HTTPstate.T">readarg</a>(files, state, callback, <span class="literal">"HTTPwords"</span>) <br>, <a href="#empty::JS.HTTPresult:JS.HTTPresult">empty:JS.HTTPresult</a></span>) <p> <span class="keyword" id="SpecialExports">Module</span> SpecialExports <p>This module is contains functions that must be included in exports of the wasm module because the functions are use by template.js. <p>use JS.HTTPresult <p>use SpecialImports <p>use bits <p>use bitcast.int <p>use ptr <p>use real <p>use standard <p>use tausupport <p>use webIOtypes <span class="keyword">Builtin</span> <p>handleerror <span class="keyword">Builtin</span> <p>processbody <span class="keyword">Builtin</span> <p>reclaimspace <p>use UTF8 <p> <a id="jsmakepair:jsbytes:jsbytes:JS.HTTPresult" href="#SpecialExports">Function</a> jsmakepair(data:jsbytes, msgUTF8:jsbytes) JS.HTTPresult <br> <a href="#toJS:T:JS.T">toJS</a>.HTTPresult( <span class="block">UTF8. <a href="#toseqbyte:jsbytes:seq.byte">toseqbyte</a>.msgUTF8 <br>, <a href="#toseqbyte:jsbytes:seq.byte">toseqbyte</a>.data</span>) <p> <a id="allocatespace3:real:real" href="#SpecialExports">Function</a> allocatespace3(i:real) real <br> <span class="comment">{used by template.js}</span> <br> <a href="#toreal:int:real">toreal</a>.bitcast:int( <a href="#allocatespace:int:ptr">allocatespace</a>. <a href="#">intpart</a>.i) <p> <a id="randomintimp:int:seq.int" href="#SpecialExports">Function</a> randomintimp(i:int) seq.int <br> <span class="keyword">for</span> acc = empty:seq.int, e ∈ <a href="#constantseq:int:T:seq.T">constantseq</a>(i, 0) <br> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> toint( <span class="block"> <a href="#tobits:int:bits">tobits</a>. <a href="#representation:real:int">representation</a>.randomfunc <br> <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 16 <br> <a href="#⊻:bits:bits:bits">⊻</a> ( <a href="#tobits:int:bits">tobits</a>. <a href="#representation:real:int">representation</a>.randomfunc <br> <a href="#⊻:bits:bits:bits">⊻</a> ( <a href="#tobits:int:bits">tobits</a>. <a href="#representation:real:int">representation</a>.randomfunc <br> <a href="#>>:bits:int:bits">>></a> 16 <br> <a href="#⊻:bits:bits:bits">⊻</a> <a href="#tobits:int:bits">tobits</a>. <a href="#representation:real:int">representation</a>.randomfunc <br> <a href="#>>:bits:int:bits">>></a> 32))</span>),</span> acc <p> <a id="blockseqtype:real" href="#SpecialExports">Function</a> blockseqtype real <br> <span class="comment">{used by template.js}</span> <br> <a href="#toreal:int:real">toreal</a>. <a href="#blockseqtype::T:int">blockseqtype:byte</a> <p> <span class="keyword" id="JS">Module</span> JS.T <p>use bitcast.JS.T <p>use bitcast.int <p>use real <p>type JS is val:T <p> <span class="keyword">Export</span> type:JS.T <p> <a id="toJS:T:JS.T" href="#JS">Function</a> toJS(a:T) JS.T <br>bitcast:JS.T( <span class="block">toptr. <a href="#representation:real:int">representation</a>. <a href="#toreal:int:real">toreal</a>.bitcast:int(toptr.JS.a)</span>) <p> <a id="fromJS:JS.T:T" href="#JS">Function</a> fromJS(a:JS.T) T <br>val.bitcast:JS.T(toptr. <a href="#">intpart</a>. <a href="#casttoreal:int:real">casttoreal</a>.bitcast:int(toptr.a)) <p> <span class="keyword" id="webHTTP">Module</span> webHTTP.T <p>use JS.HTTPresult <p>use SpecialImports <p>use JS.HTTPstate.T <p>use bitcast.JS.HTTPstate.T <p>use UTF8 <p>use bits <p>use seq.byte <p>use file <p>use seq1.file <p>use real <p>use standard <p>use webIOtypes <p>use bitcast.JS.HTTPstate.seq.word <p>type HTTPstate is <br>files:seq.file <br>, args:T <br>, idx:int <br>, finalcall:seq.word <br>, method:seq.word <br>, funcname:seq.word <p> <span class="keyword">Export</span> type:HTTPstate.T <p> <span class="keyword">Export</span> files(HTTPstate.T) seq.file <p> <span class="keyword">Export</span> args(HTTPstate.T) T <p> <span class="keyword">Export</span> idx(HTTPstate.T) int <p> <span class="keyword">Export</span> finalcall(HTTPstate.T) seq.word <p> <span class="keyword">Export</span> method(HTTPstate.T) seq.word <p> <span class="keyword">Export</span> HTTPstate( <br>files:seq.file <br>, args:T <br>, idx:int <br>, finalcall:seq.word <br>, method:seq.word <br>, funcname:seq.word <br>) HTTPstate.T <br> <p> <a id="HTTP:seq.word:seq.word:seq.byte:seq.word:HTTPstate.T:real" href="#webHTTP">function</a> HTTP( <br>name:seq.word <br>, header:seq.word <br>, body:seq.byte <br>, followfunc:seq.word <br>, state:HTTPstate.T <br>) real <br> <span class="comment">{OPTION INLINE}</span> <br> <a href="#jsHTTP:jsbytes:jsbytes:jsbytes:jsbytes:JS.HTTPstate.seq.word:real">jsHTTP</a>( <span class="block"> <a href="#token:seq.word:jsbytes">token</a>.name <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.toseqbyte. <a href="#textformat:seq.word:UTF8">textformat</a>.header <br>, <a href="#jsUTF8:seq.byte:jsbytes">jsUTF8</a>.body <br>, <a href="#token:seq.word:jsbytes">token</a>.followfunc <br>, bitcast:JS.HTTPstate.seq.word(toptr. <a href="#toJS:T:JS.T">toJS</a>.state)</span>) <p> <a id="decodeZ:JS.HTTPstate.T:JS.HTTPresult:real" href="#webHTTP">Function</a> decodeZ(h2:JS.HTTPstate.T, h:JS.HTTPresult) real <br> <span class="keyword">let</span> s = <a href="#fromJS:JS.T:T">fromJS</a>.h2 <br> <span class="keyword">let</span> newfiles = <span class="block"> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(idx.s, 1, n.files.s) <span class="keyword">then</span> <span class="block">{update file with result ???? need to handle errors} <br> <span class="keyword">let</span> tmp = <a href="#fromJS:JS.T:T">fromJS</a>.h, <br> <a href="#">replace</a>( <span class="block">files.s <br>, idx.s <br>, file(fn.(files.s) <a href="#sub:seq.T:int:T">sub</a> idx.s, [result.tmp], header.tmp)</span>)</span> <span class="keyword">else</span> files.s</span> <span class="keyword">let</span> newstate = HTTPstate(newfiles, args.s, idx.s <a href="#+:int:int:int">+</a> 1, finalcall.s, method.s, funcname.s), <br> <span class="keyword">if</span> idx.s <a href="#=:int:int:boolean">=</a> n.files.s <span class="keyword">then</span> <span class="block">{all files have been processed} <br> <span class="keyword">let</span> t = <a href="#HTTP:seq.word:seq.word:seq.byte:seq.word:HTTPstate.T:real">HTTP</a>( <span class="literal">""</span>, <span class="literal">"NONE"</span>, empty:seq.byte, finalcall.s, newstate) <br> <span class="comment">{never gets here}</span> <br>0.0</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nameprefix = <span class="keyword">if</span> method.s = <span class="literal">"GET"</span> <span class="keyword">then</span> <span class="literal">"/"</span> <span class="keyword">else</span> <span class="literal">"../cgi-bin/putfile.cgi?"</span> <br> <span class="keyword">let</span> this = (files.s) <a href="#sub:seq.T:int:T">sub</a> idx.newstate <br> <span class="keyword">let</span> t = <span class="block"> <a href="#HTTP:seq.word:seq.word:seq.byte:seq.word:HTTPstate.T:real">HTTP</a>( <span class="block">nameprefix <a href="#">+</a> <a href="#fullname:filename:word">fullname</a>.fn.this <br>, method.s <br>, <a href="#data:file:seq.byte">data</a>.this <br>, funcname.s <br>, newstate</span>),</span> <span class="comment">{never gets here}</span> <br>0.0</span> <p> <a id="readarg:seq.file:T:seq.word:seq.word:JS.HTTPstate.T" href="#webHTTP">Function</a> readarg( <br>files:seq.file <br>, args:T <br>, callback:seq.word <br>, funcname:seq.word <br>) JS.HTTPstate.T <br> <a href="#toJS:T:JS.T">toJS</a>.HTTPstate(files, args, 0, callback, <span class="literal">"GET"</span>, funcname) <p> <a id="writearg:seq.file:T:seq.word:seq.word:JS.HTTPstate.T" href="#webHTTP">Function</a> writearg( <br>files:seq.file <br>, args:T <br>, callback:seq.word <br>, funcname:seq.word <br>) JS.HTTPstate.T <br> <a href="#toJS:T:JS.T">toJS</a>.HTTPstate(files, args, 0, callback, <span class="literal">"PUT Content-Type:application/text"</span>, funcname) <p> <span class="keyword" id="SpecialImports">Module</span> SpecialImports <p>This module is used to built the imports of the wasm module. <p>use standard <p>use real <p>use webIOtypes <p>use webHTTP.seq.word <p>use JS.HTTPstate.seq.word <span class="keyword">Builtin</span> <p>clockReal <span class="keyword">Builtin</span> <p>randomfunc <span class="keyword">Builtin</span> <p>setelementvalue <span class="keyword">Builtin</span> <p>getelementvalue <span class="keyword">Builtin</span> <p>getattributes2 <span class="keyword">Builtin</span> <p>setattribute2 <span class="keyword">Builtin</span> <p>openWindow2 <span class="keyword">Builtin</span> <p>callevent2 <span class="keyword">Builtin</span> <p>replacesvg <span class="keyword">Builtin</span> <p>URLargs <span class="keyword">Builtin</span> <p>jsHTTP <p> <span class="keyword">Builtin</span> arcsin(real) real <p> <span class="keyword">Builtin</span> arccos(real) real <p> <span class="keyword">Builtin</span> sqrt(real) real <p> <span class="keyword">Builtin</span> cos(real) real <p> <span class="keyword">Builtin</span> tan(real) real <p> <span class="keyword">Builtin</span> sin(real) real <span class="keyword">Builtin</span> <p>callprocess <span class="keyword">Builtin</span> <p>abortfunc <p> <span class="keyword" id="taublockseq">Module</span> taublockseq.T <p>use bitcast.T <p>use seq.T <p>use bitcast.seq.T <p>use bitcast.int <p>use seq1.int <p>use kernal <p>use ptr <p>use bitcast.ptr <p> <span class="keyword">Export</span> type:blockseq.T <p> <span class="keyword">Export</span> type:seq.T{From seq.T} <p> <span class="keyword">builtin</span> getfld(address:blockseq.T, offset:int) seq.T{load value of type T at address} <p>type blockseq is sequence, dummy:seq.T <p> <a id="blocksize::T:int" href="#taublockseq">Function</a> blocksize:T int 8160 <p> <a id="blockseqtype::T:int" href="#taublockseq">Function</a> blockseqtype:T int getseqtype.toseq.blockseq(1, empty:seq.T) <p> <a id="sequenceIndex:blockseq.T:int:T" href="#taublockseq">function</a> sequenceIndex(a:blockseq.T, i:int) T <br> <span class="keyword">assert</span> <a href="#between:int:int:int:boolean">between</a>(i, 1, n.toseq.a) <span class="keyword">report</span> <span class="literal">"out of bounds"</span> <br> <span class="keyword">let</span> blksz = n.dummy.a <br> <span class="keyword">let</span> blk = getfld(a, (i <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <a href="#+:int:int:int">+</a> 2), <br>blk <a href="#sub:seq.T:int:T">sub</a> ((i <a href="#">-</a> 1) <a href="#mod:int:int:int">mod</a> blksz <a href="#+:int:int:int">+</a> 1) <p> <a id="_:blockseq.T:int:T" href="#taublockseq">Function</a> _(a:blockseq.T, i:int) T <br> <span class="keyword">assert</span> <a href="#between:int:int:int:boolean">between</a>(i, 1, n.toseq.a) <span class="keyword">report</span> <span class="literal">"out of bounds"</span> <br> <span class="keyword">let</span> blksz = n.dummy.a <br> <span class="keyword">let</span> blk = getfld(a, (i <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <a href="#+:int:int:int">+</a> 2), <br>blk <a href="#sub:seq.T:int:T">sub</a> ((i <a href="#">-</a> 1) <a href="#mod:int:int:int">mod</a> blksz <a href="#+:int:int:int">+</a> 1) <p> <a id="blockit3:seq.T:seq.T" href="#taublockseq">Function</a> blockit3(s:seq.T) seq.T <br> <span class="keyword">let</span> blksz = <a href="#blocksize::T:int">blocksize:T</a>, <br> <span class="keyword">if</span> n.s ≤ blksz <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newseq = <a href="#allocatespace:int:ptr">allocatespace</a>(n.s <a href="#+:int:int:int">+</a> 2), <br> <span class="keyword">if</span> getseqtype.s <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> discard = <a href="#">blockcopy</a>(newseq, s, n.s <a href="#+:int:int:int">+</a> 2), <br>bitcast:seq.T(newseq)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> acc = set(set(newseq, 0), n.s), e ∈ s <span class="keyword">do</span> <a href="#set:ptr:real:ptr">set</a>(acc, e), <br>bitcast:seq.T(newseq)</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> noblks = (n.s <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <br> <span class="keyword">let</span> blockseqtype = getseqtype.toseq.blockseq(1, empty:seq.T) <br> <span class="keyword">let</span> blkseq = <a href="#allocatespace:int:ptr">allocatespace</a>(noblks <a href="#+:int:int:int">+</a> 2), <br> <span class="keyword">for</span> <span class="block">acc = set(set(blkseq, blockseqtype), n.s) <br>, @e ∈ <a href="#arithseq:int:T:T:seq.T">arithseq</a>(noblks, blksz, 1)</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> newseq = <a href="#allocatespace:int:ptr">allocatespace</a>(blksz <a href="#+:int:int:int">+</a> 2) <br> <span class="keyword">let</span> k = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, @e, @e <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1), <br> <span class="keyword">let</span> d = <span class="block"> <span class="keyword">for</span> acc2 = set(set(newseq, 0), n.k), e ∈ k <span class="keyword">do</span> <a href="#set:ptr:real:ptr">set</a>(acc2, e), <br>acc2,</span> set(acc, newseq),</span> bitcast:seq.T(blkseq)</span> <p> <a id="blockcopy:ptr:seq.T:int:ptr" href="#taublockseq">function</a> blockcopy(p:ptr, b:seq.T, n:int) ptr <br> <span class="keyword">for</span> acc = p, i = 0 <br> <span class="keyword">while</span> i <a href="#&lt;:int:int:boolean">&lt;</a> n <br> <span class="keyword">do</span> next(set(acc, fld:int(toptr.b, i)), i <a href="#+:int:int:int">+</a> 1), <br>acc <p> <a id="blockcopy:ptr:T:int:ptr" href="#taublockseq">function</a> blockcopy(p:ptr, b:T, n:int) ptr <br> <span class="comment">{if n = 3 then set(set(set(p, fld:int(toptr.b, 0)), fld:int(toptr.b, 1)), fld:int(toptr.b, 2))else}</span> <br> <span class="keyword">for</span> acc = p, i = 0 <br> <span class="keyword">while</span> i <a href="#&lt;:int:int:boolean">&lt;</a> n <br> <span class="keyword">do</span> next(set(acc, fld:int(toptr.b, i)), i <a href="#+:int:int:int">+</a> 1), <br>acc <p> <a id="blockit2:seq.T:int:seq.T" href="#taublockseq">Function</a> blockit2(s:seq.T, ds:int) seq.T <br> <span class="keyword">assert</span> ds <a href="#>:int:int:boolean">></a> 1 <span class="keyword">report</span> <span class="literal">"blockit problem"</span> <br> <span class="keyword">let</span> blksz = <a href="#blocksize::T:int">blocksize:T</a> <a href="#/:int:int:int">/</a> ds, <br> <span class="keyword">if</span> n.s ≤ blksz <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newseq = <a href="#allocatespace:int:ptr">allocatespace</a>(n.s <a href="#*:int:int:int">*</a> ds <a href="#+:int:int:int">+</a> 2) <br> <span class="keyword">for</span> acc = set(set(newseq, 1), n.s), e ∈ s <span class="keyword">do</span> <a href="#">blockcopy</a>(acc, e, ds), <br>bitcast:seq.T(newseq)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> noblks = (n.s <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <br> <span class="keyword">let</span> blockseqtype = getseqtype.toseq.blockseq(1, empty:seq.T) <br> <span class="keyword">let</span> blkseq = <a href="#allocatespace:int:ptr">allocatespace</a>(noblks <a href="#+:int:int:int">+</a> 2), <br> <span class="keyword">for</span> <span class="block">acc = set(set(blkseq, blockseqtype), n.s) <br>, @e ∈ <a href="#arithseq:int:T:T:seq.T">arithseq</a>(noblks, blksz, 1)</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> s2 = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, @e, @e <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <br> <span class="keyword">let</span> newseq = <a href="#allocatespace:int:ptr">allocatespace</a>(n.s2 <a href="#*:int:int:int">*</a> ds <a href="#+:int:int:int">+</a> 2), <br> <span class="keyword">let</span> d = <span class="block"> <span class="keyword">for</span> acc2 = set(set(newseq, 1), n.s2), e ∈ s2 <span class="keyword">do</span> <a href="#">blockcopy</a>(acc, e, ds), <br>acc2,</span> set(acc, newseq),</span> bitcast:seq.T(blkseq)</span> <p> <span class="keyword" id="bitcast">Module</span> bitcast.T <p>use ptr <p> <span class="keyword">Builtin</span> bitcast:T(ptr) T <p> <span class="keyword">Builtin</span> bitcast:T(int) T <p> <span class="keyword">Builtin</span> fld:T(ptr, int) T <p> <span class="keyword">Builtin</span> toptr(T) ptr <p> <span class="keyword">Builtin</span> set(ptr, T) ptr <p> <span class="keyword" id="tausupport">Module</span> tausupport <p>use bits <p>use seq.bits <p>use bitcast.seq.bits <p>use seq.byte <p>use bitcast.seq.byte <p>use seq.seq.byte <p>use taublockseq.byte <p>use encoding.seq.char <p>use encodingsupport <p>use bitcast.int <p>use seq1.int <p>use bitcast.seq.int <p>use taublockseq.int <p>use kernal <p>use taublockseq.packed2 <p>use taublockseq.packed3 <p>use taublockseq.packed4 <p>use taublockseq.packed5 <p>use taublockseq.packed6 <p>use ptr <p>use bitcast.ptr <p>use seq.ptr <p>use bitcast.seq.ptr <p>use taublockseq.ptr <p>use bitcast.real <p>use seq.real <p>use bitcast.seq.real <p>use taublockseq.real <p>use word <p>use seq.word <p>use stateFunctions <p> <span class="keyword">Export</span> type:packed2 <p> <span class="keyword">Export</span> type:packed3 <p> <span class="keyword">Export</span> type:packed4 <p> <span class="keyword">Export</span> type:packed5 <p> <span class="keyword">Export</span> type:packed6 <p> <span class="keyword">Export</span> decode(encoding.seq.char) seq.char{From encoding.seq.char} <p> <span class="keyword">Export</span> encode(seq.char) encoding.seq.char{From encoding.seq.char} <p> <span class="keyword">Export</span> addencodings(seq.seq.char) int{From encoding.seq.char} <p> <span class="keyword">Export</span> type:einfo{From encodingsupport} <p> <span class="keyword">Export</span> evectorUpdate(b:ptr) ptr{From encodingsupport} <p> <span class="keyword">Export</span> geteinfo(gl:ptr, name:seq.word) einfo{From encodingsupport} <p> <span class="keyword">Export</span> geteinfo2(int, int) einfo{From encodingsupport} <p> <span class="keyword">Export</span> type:ptr{From ptr} <p> <span class="keyword">Export</span> blockseqtype:byte int{From taublockseq.byte} <p> <span class="keyword">Export</span> blockit3(seq.int) seq.int{From taublockseq.int} <p> <span class="keyword">Export</span> _(blockseq.int, int) int{From taublockseq.int} <p> <span class="keyword">Export</span> _(blockseq.packed2, int) packed2{From taublockseq.packed2} <p> <span class="keyword">Export</span> blockit2(seq.packed2, int) seq.packed2{From taublockseq.packed2} <p> <span class="keyword">Export</span> _(blockseq.packed3, int) packed3{From taublockseq.packed3} <p> <span class="keyword">Export</span> blockit2(seq.packed3, int) seq.packed3{From taublockseq.packed3} <p> <span class="keyword">Export</span> _(blockseq.packed4, int) packed4{From taublockseq.packed4} <p> <span class="keyword">Export</span> blockit2(seq.packed4, int) seq.packed4{From taublockseq.packed4} <p> <span class="keyword">Export</span> _(blockseq.packed5, int) packed5{From taublockseq.packed5} <p> <span class="keyword">Export</span> blockit2(seq.packed5, int) seq.packed5{From taublockseq.packed5} <p> <span class="keyword">Export</span> _(blockseq.packed6, int) packed6{From taublockseq.packed6} <p> <span class="keyword">Export</span> blockit2(seq.packed6, int) seq.packed6{From taublockseq.packed6} <p> <span class="keyword">Export</span> blockit3(seq.ptr) seq.ptr{From taublockseq.ptr} <p> <span class="keyword">Export</span> _(blockseq.ptr, int) ptr{From taublockseq.ptr} <p> <span class="keyword">Export</span> blockit3(seq.real) seq.real{From taublockseq.real} <p> <span class="keyword">Export</span> _(blockseq.real, int) real{From taublockseq.real} <span class="keyword">Builtin</span> <p>getseqlength <span class="keyword">Builtin</span> <p>getseqtype <p> <a id="set:ptr:real:ptr" href="#tausupport">Function</a> set(i:ptr, b:real) ptr <br>set(i, <a href="#representation:real:int">representation</a>.b) <p> <a id="deepcopy:int:int" href="#tausupport">Function</a> deepcopy(a:int) int a <p> <a id="deepcopy:real:real" href="#tausupport">Function</a> deepcopy(a:real) real a <span class="keyword">Builtin</span> <p>abort <span class="keyword">Builtin</span> <p>abort <span class="keyword">Builtin</span> <p>abort <span class="keyword">Builtin</span> <p>abort <p> <a id="outofbounds:seq.word" href="#tausupport">Function</a> outofbounds seq.word <span class="literal">"out of bounds:(stacktrace)"</span> <p> <a id="packedbytes:seq.byte:seq.byte" href="#tausupport">function</a> packedbytes(a:seq.byte) seq.byte <br> <span class="keyword">let</span> c = <a href="#T:state">packed</a>([bits.1, bits.n.a] <a href="#">+</a> <a href="#toseqbits:seq.byte:seq.bits">toseqbits</a>.a) <br> <span class="keyword">assert</span> getseqtype.c <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">report</span> <span class="literal">"to big byte sequence to pack"</span>, <br>bitcast:seq.byte(set(set(toptr.c, getseqtype.c), n.c)) <p> <a id="blockIt:seq.byte:seq.byte" href="#tausupport">Function</a> blockIt(s:seq.byte) seq.byte <br> <span class="keyword">let</span> blksz = 8128 <a href="#*:int:int:int">*</a> 8, <br> <span class="keyword">if</span> n.s ≤ blksz <span class="keyword">then</span> <a href="#packedbytes:seq.byte:seq.byte">packedbytes</a>.s <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> noblks = (n.s <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <br> <span class="keyword">let</span> blkseq = <a href="#allocatespace:int:ptr">allocatespace</a>(noblks <a href="#+:int:int:int">+</a> 2), <br> <span class="keyword">let</span> discard = <span class="block"> <span class="keyword">for</span> <span class="block">acc = set(set(blkseq, <a href="#blockseqtype::T:int">blockseqtype:byte</a>), n.s) <br>, @e ∈ <a href="#arithseq:int:T:T:seq.T">arithseq</a>(noblks, blksz, 1)</span> <span class="keyword">do</span> <span class="block">set( <span class="block">acc <br>, bitcast:int( <span class="block">toptr. <a href="#packedbytes:seq.byte:seq.byte">packedbytes</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, @e, @e <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1)</span>)</span>),</span> acc,</span> bitcast:seq.byte(blkseq)</span> <p> <a id="toseqseqbyte:seq.bits:int:seq.seq.byte" href="#tausupport">Function</a> toseqseqbyte(b:seq.bits, bytestowrite:int) seq.seq.byte <br> <span class="keyword">let</span> blksz = 8128 <br> <span class="keyword">let</span> noblks = (n.b <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.seq.byte <br>, byteswritten ∈ <a href="#arithseq:int:T:T:seq.T">arithseq</a>(noblks, blksz <a href="#*:int:int:int">*</a> 8, 0)</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> new = <span class="block"> <a href="#T:state">packed</a>( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">b <br>, byteswritten <a href="#/:int:int:int">/</a> 8 <a href="#+:int:int:int">+</a> 1 <br>, byteswritten <a href="#/:int:int:int">/</a> 8 <a href="#+:int:int:int">+</a> blksz</span>) <br> <a href="#">+</a> bits.0</span>)</span> <span class="keyword">let</span> z = set(set(toptr.new, 1), <a href="#min:int:int:int">min</a>(bytestowrite <a href="#">-</a> byteswritten, blksz <a href="#*:int:int:int">*</a> 8)), <br>acc <a href="#">+</a> bitcast:seq.byte(toptr.new),</span> acc <p> <a id="toseqseqbyte:seq.byte:seq.seq.byte" href="#tausupport">Function</a> toseqseqbyte(s:seq.byte) seq.seq.byte <br> <span class="keyword">let</span> blksz = 8128 <a href="#*:int:int:int">*</a> 8 <br> <span class="keyword">let</span> noblks = (n.s <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1) <a href="#/:int:int:int">/</a> blksz <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.seq.byte <br>, start ∈ <a href="#arithseq:int:T:T:seq.T">arithseq</a>(noblks, blksz, 1)</span> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> <a href="#packedbytes:seq.byte:seq.byte">packedbytes</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, start, start <a href="#+:int:int:int">+</a> blksz <a href="#">-</a> 1),</span> acc <p>------------------------------- <p> <a id="profileUpdate:int:int:ptr:int" href="#tausupport">Function</a> profileUpdate(time:int, beforeSpace:int, p:ptr) int <br> <span class="keyword">let</span> p1 = set(p, fld:int(p, 0) <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> p2 = set(p1, fld:int(p1, 0) <a href="#+:int:int:int">+</a> (clock <a href="#">-</a> time)) <br> <span class="keyword">let</span> p3 = set(p2, fld:int(p2, 0) <a href="#+:int:int:int">+</a> (spacecount <a href="#">-</a> beforeSpace)), <br>0 <p>type packed2 is fld1:int, fld2:int <p>type packed3 is fld1:int, fld2:int, fld3:int <p>type packed4 is fld1:int, fld2:int, fld3:int, fld4:int <p>type packed5 is fld1:int, fld2:int, fld3:int, fld4:int, fld5:int <p>type packed6 is fld1:int, fld2:int, fld3:int, fld4:int, fld5:int, fld6:int <p> <a id="blocktype:word:int" href="#tausupport">Function</a> blocktype(typ:word) int <br> <span class="keyword">if</span> typ <a href="#">∈</a> <span class="literal">"int"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:int</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"real"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:real</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"ptr"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:int</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"packed2"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:packed2</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"packed3"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:packed3</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"packed4"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:packed4</a> <br> <span class="keyword">else</span> if typ <a href="#">∈</a> <span class="literal">"packed5"</span> <span class="keyword">then</span> <a href="#blockseqtype::T:int">blockseqtype:packed5</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> typ <a href="#">∈</a> <span class="literal">"packed6"</span> <span class="keyword">report</span> <span class="literal">"packing not found"</span> <a href="#">+</a> typ, <br> <a href="#blockseqtype::T:int">blockseqtype:packed6</a></span> <p> <span class="keyword" id="encodingsupport">Module</span> encodingsupport <p>use bitcast.einfo <p>use seq1.einfo <p>use bitcast.seq.einfo <p>use bitcast.evector <p>use bitcast.int <p>use kernal <p>use indirect.processflds <p>use seq.processflds <p>use ptr <p>use bitcast.ptr <p>use encoding.typename <p>use bitcast.encodingstate.typename <p>use word <p>use seq.word <p> <span class="keyword">Export</span> type:einfo <p> <span class="keyword">Export</span> type:processflds <p> <span class="keyword">Export</span> type:typename <p>type typename is name:seq.word <p> <a id="geteinfo:ptr:seq.word:einfo" href="#encodingsupport">Function</a> geteinfo(gl:ptr, name:seq.word) einfo <br> <span class="keyword">let</span> no = fld:int(gl, 0) <br> <span class="keyword">let</span> encodingno = <span class="block"> <span class="keyword">if</span> no <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> no <br> <span class="keyword">else</span> if {subseq(name, 1, 2)="char kernal"} <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(name, 1, 1) <br> = <span class="literal">"char"</span> <span class="keyword">then</span> 1 <br> <span class="keyword">else</span> if <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(name, 1, 2) = <span class="literal">"typename encodingsupport"</span> <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> newno = <a href="#addorder:T:int">addorder</a>.typename.name <a href="#+:int:int:int">+</a> 2 <br> <span class="keyword">let</span> discard = set(gl, newno), <br>newno,</span></span> <a href="#geteinfo2:int:int:einfo">geteinfo2</a>(encodingno, 0) <p> <a id="geteinfo2:int:int:einfo" href="#encodingsupport">Function</a> geteinfo2(encodingno:int, dummy:int) einfo <br> <span class="keyword">let</span> cp = currentprocess <br> <span class="keyword">let</span> a = evector.cp, <br> <span class="keyword">if</span> encodingno <a href="#=:int:int:boolean">=</a> encodingno.thisone.a <span class="keyword">then</span> thisone.a <br> <span class="keyword">else</span> if encodingno ≤ n.vector.a <br> <a href="#∧:boolean:boolean:boolean">∧</a> encodingno.(vector.a) <a href="#sub:seq.T:int:T">sub</a> encodingno <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> this = (vector.a) <a href="#sub:seq.T:int:T">sub</a> encodingno <br> <span class="keyword">let</span> discard = set(set(toptr.a, toptr.vector.a), toptr.this), <br>this</span> <span class="keyword">else</span> <span class="block"> <a href="#evectorUpdate:einfo:einfo">evectorUpdate</a>. <a href="#einfo:encodingstate.typename:int:processflds:einfo">einfo</a>( <span class="block"> <a href="#empty::encodingstate.T:encodingstate.T">empty:encodingstate.typename</a> <br>, encodingno <br>, cp</span>)</span> <p> <a id="evectorUpdate:ptr:ptr" href="#encodingsupport">Function</a> evectorUpdate(b:ptr) ptr <br>toptr. <a href="#evectorUpdate:einfo:einfo">evectorUpdate</a>.bitcast:einfo(b) <p> <a id="evectorUpdate:einfo:einfo" href="#encodingsupport">Function</a> evectorUpdate(b:einfo) einfo <br> <span class="keyword">let</span> cp = currentprocess <br> <span class="keyword">let</span> a = evector.cp <br> <span class="keyword">let</span> encodingno = encodingno.b <br> <span class="keyword">let</span> vin = vector.a <br> <span class="keyword">let</span> newlen = <a href="#max:int:int:int">max</a>(encodingno, n.vin) <br> <span class="keyword">let</span> t = <a href="#allocatespace:int:ptr">allocatespace</a>(newlen <a href="#+:int:int:int">+</a> 2) <br> <span class="keyword">let</span> newvector = bitcast:seq.einfo(t) <br> <span class="keyword">let</span> discard = <span class="block"> <span class="keyword">for</span> <span class="block">acc = set(set(t, 0), newlen) <br>, cnt = 1 <br>, e ∈ vin <br> <a href="#">+</a> <a href="#constantseq:int:T:seq.T">constantseq</a>( <span class="block">encodingno <a href="#">-</a> n.vin <br>, <a href="#einfo:encodingstate.typename:int:processflds:einfo">einfo</a>( <a href="#empty::encodingstate.T:encodingstate.T">empty:encodingstate.typename</a>, 0, cp)</span>)</span> <span class="keyword">do</span> <span class="block">next( <span class="block">set(acc, toptr( <span class="keyword">if</span> cnt <a href="#=:int:int:boolean">=</a> encodingno <span class="keyword">then</span> b <span class="keyword">else</span> e)) <br>, cnt <a href="#+:int:int:int">+</a> 1</span>),</span> 0</span> <span class="keyword">let</span> discard2 = set(set(toptr.a, toptr.newvector), toptr.b), <br>b <p> <a id="=:typename:typename:boolean" href="#encodingsupport">function</a> =(a:typename, b:typename) boolean name.a = name.b <p> <a id="hash:typename:int" href="#encodingsupport">function</a> hash(a:typename) int <a href="#hash:seq.word:int">hash</a>.name.a <p>type processflds is <br>aborted:boolean <br>, message:int <br>, messageUTF8:int <br>, body:int <br>, body2:int <br>, evector:evector <br>, parentprocess:ptr <span class="keyword">builtin</span> <p>currentprocess <p>type einfo is state45:ptr, encodingno:int, allocatein:indirect.processflds <p>type evector is vector:seq.einfo, thisone:einfo <p> <a id="einfo:encodingstate.typename:int:processflds:einfo" href="#encodingsupport">function</a> einfo( <br>state45:encodingstate.typename <br>, encodingno:int <br>, allocatein:processflds <br>) einfo <br>einfo(toptr.state45, encodingno, indirect.allocatein) <p> <span class="keyword" id="bits">Module</span> bits <p>use seq.bits <p>use seq.int <p>use kernal <p> <span class="keyword">Export</span> type:bits <p> <span class="keyword">Export</span> toint(bits) int <p> <span class="keyword">Export</span> type:byte <p> <span class="keyword">Export</span> bits(int) bits <p>type bits is toint:int <p> <a id="tobits:int:bits" href="#bits">Function</a> tobits(a:int) bits bits.a <span class="keyword">Builtin</span> <p>∨ <span class="keyword">Builtin</span> <p>∧ <span class="keyword">Builtin</span> <p>>> <span class="keyword">Builtin</span> <p>&lt;&lt; <span class="keyword">Builtin</span> <p>⊻ <p> <a id="=:bits:bits:boolean" href="#bits">Function</a> =(a:bits, b:bits) boolean toint.a <a href="#=:int:int:boolean">=</a> toint.b <p> <a id="mask:int:bits" href="#bits">Function</a> mask(n:int) bits <br> <span class="comment">{returns mask of n 1s in right bits. }</span> <br> <a href="#tobits:int:bits">tobits</a>.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> n) <p> <a id=">1:byte:byte:ordering" href="#bits">Function</a> >1(a:byte, b:byte) ordering <br> <a href="#toint:byte:int">toint</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#toint:byte:int">toint</a>.b <p> <a id="floorLog2:int:int" href="#bits">Function</a> floorLog2(a:int) int <br> <span class="keyword">let</span> d64 = <a href="#tobits:int:bits">tobits</a>.a <br> <span class="keyword">let</span> b32 = d64 <a href="#>>:bits:int:bits">>></a> 32 <br> <span class="keyword">let</span> t32 = <span class="keyword">if</span> b32 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 32 <br> <span class="keyword">let</span> d32 = <span class="keyword">if</span> b32 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFFFFFFFF <a href="#∧:bits:bits:bits">∧</a> d64 <span class="keyword">else</span> b32 <br> <span class="keyword">let</span> b16 = d32 <a href="#>>:bits:int:bits">>></a> 16 <br> <span class="keyword">let</span> t16 = <span class="keyword">if</span> b16 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 16 <br> <span class="keyword">let</span> d16 = <span class="keyword">if</span> b16 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFFFF <a href="#∧:bits:bits:bits">∧</a> d32 <span class="keyword">else</span> b16 <br> <span class="keyword">let</span> b8 = d16 <a href="#>>:bits:int:bits">>></a> 8 <br> <span class="keyword">let</span> t8 = <span class="keyword">if</span> b8 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 8 <br> <span class="keyword">let</span> d8 = <span class="keyword">if</span> b8 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xFF <a href="#∧:bits:bits:bits">∧</a> d16 <span class="keyword">else</span> b8 <br> <span class="keyword">let</span> b4 = d8 <a href="#>>:bits:int:bits">>></a> 4 <br> <span class="keyword">let</span> t4 = <span class="keyword">if</span> b4 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0 <span class="keyword">else</span> 4 <br> <span class="keyword">let</span> d4 = <span class="keyword">if</span> b4 <a href="#=:bits:bits:boolean">=</a> 0x0 <span class="keyword">then</span> 0xF <a href="#∧:bits:bits:bits">∧</a> d8 <span class="keyword">else</span> b4, <br>t32 <br> <a href="#+:int:int:int">+</a> t16 <br> <a href="#+:int:int:int">+</a> t8 <br> <a href="#+:int:int:int">+</a> t4 <br> <a href="#+:int:int:int">+</a> [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3] <a href="#sub:seq.T:int:T">sub</a> (toint.d4 <a href="#+:int:int:int">+</a> 1) <p>type byte is rep:int <p> <a id="=:byte:byte:boolean" href="#bits">Function</a> =(a:byte, b:byte) boolean <br> <a href="#toint:byte:int">toint</a>.a <a href="#=:int:int:boolean">=</a> <a href="#toint:byte:int">toint</a>.b <p> <a id="tobits:byte:bits" href="#bits">Function</a> tobits(a:byte) bits <br> <a href="#tobits:int:bits">tobits</a>. <a href="#toint:byte:int">toint</a>.a <span class="keyword">Builtin</span> <p>toint <p> <a id="tobyte:int:byte" href="#bits">Function</a> tobyte(a:int) byte byte.a <p> <a id="toseqbits:seq.byte:seq.bits" href="#bits">Function</a> toseqbits(a:seq.byte) seq.bits <br> <span class="keyword">for</span> acc = empty:seq.bits, current = bits.0, shift = 0, b ∈ a <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> shift <a href="#=:int:int:boolean">=</a> 64 <span class="keyword">then</span> next(acc <a href="#">+</a> current, bits. <a href="#toint:byte:int">toint</a>.b <a href="#∧:bits:bits:bits">∧</a> 0xFF, 8) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">acc <br>, current <br> <a href="#∨:bits:bits:bits">∨</a> (bits. <a href="#toint:byte:int">toint</a>.b <a href="#∧:bits:bits:bits">∧</a> 0xFF) <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> shift <br>, shift <a href="#+:int:int:int">+</a> 8</span>),</span></span> acc <a href="#">+</a> current <p> <span class="keyword" id="encoding">Module</span> encoding.T <p>use seq.encodingpair.T <p>use seq1.seq.encodingpair.T <p>use indirect.encodingstate.T <p>use seq.T <p>use bits <p>use kernal <p>use ptr <p>use word <p>use seq.word <p> <span class="keyword">Export</span> type:encoding.T <p> <span class="keyword">Export</span> valueofencoding(a:encoding.T) int <p> <span class="keyword">Export</span> type:encodingstate.T <p> <span class="keyword">Export</span> length(encodingstate.T) int <p> <span class="keyword">builtin</span> set(ptr, encodingstate.T) ptr <p>type encoding is valueofencoding:int <p> <a id="to::encoding.T:int:encoding.T" href="#encoding">Function</a> to:encoding.T(i:int) encoding.T encoding.i <p>type encodingstate is <br>all:seq.encodingpair.T <br>, length:int <br>, encodetable:seq.seq.encodingpair.T <br>, lastadd:encoding.T <p> <a id="startInParent::T:boolean" href="#encoding">Function</a> startInParent:T boolean <br> <span class="keyword">let</span> inst = getinstance3:T, <br> <span class="keyword">if</span> length.fromindirect.state.inst <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> false <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> discard = finishStart:T(encodingnumber.inst), <br>true</span> <p> <span class="keyword">builtin</span> finishStart:T(eno:int) einfo.T <p> <a id="empty::encodingstate.T:encodingstate.T" href="#encoding">Function</a> empty:encodingstate.T encodingstate.T <br> <span class="keyword">let</span> e = empty:seq.encodingpair.T, <br>encodingstate(e, 0, [e, e, e, e], <a href="#T:state">to:encoding.T</a>(0)) <p>type encodingpair is data:T, code:encoding.T, hash:int <p> <a id="=:encodingpair.T:encodingpair.T:boolean" href="#encoding">function</a> =(a:encodingpair.T, b:encodingpair.T) boolean <br>hash.a <a href="#=:int:int:boolean">=</a> hash.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> valueofencoding.code.a <a href="#=:int:int:boolean">=</a> valueofencoding.code.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> data.a <a href="#">=</a> data.b <p> <span class="keyword">unbound</span> hash(T) int <p> <span class="keyword">unbound</span> =(T, T) boolean <p> <a id="lastadded:encodingstate.T:encoding.T" href="#encoding">Function</a> lastadded(h:encodingstate.T) encoding.T code.(all.h) <a href="#sub:seq.T:int:T">sub</a> n.all.h <p> <a id="notsamehash::T:int:int:bits:boolean" href="#encoding">function</a> notsamehash:T(a:int, b:int, mask:bits) boolean <br>(bits.a <a href="#∧:bits:bits:bits">∧</a> mask) ≠ (bits.b <a href="#∧:bits:bits:bits">∧</a> mask) <p> <span class="keyword">builtin</span> deepcopy(T) T <p> <a id="addencoding:encodingstate.T:T:encodingstate.T" href="#encoding">Function</a> addencoding(h:encodingstate.T, data:T) encodingstate.T <br> <span class="comment">{this is the add that is called by primitiveadd}</span> <br> <span class="keyword">let</span> datav = <a href="#">deepcopy</a>.data <br> <span class="keyword">let</span> hashv = <a href="#">hash</a>.datav <br> <span class="keyword">let</span> tablesize = n.encodetable.h <br> <span class="keyword">let</span> mask = bits.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> <a href="#floorLog2:int:int">floorLog2</a>.tablesize) <br> <span class="keyword">let</span> dataindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>.hashv <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1</span> <span class="keyword">let</span> existingcode = <a href="#lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T">lookuprep2</a>(datav, (encodetable.h) <a href="#sub:seq.T:int:T">sub</a> dataindex), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.existingcode <span class="keyword">then</span> <span class="block">{already present} <br> <span class="keyword">let</span> c = code.existingcode <a href="#sub:seq.T:int:T">sub</a> 1, <br> <span class="keyword">if</span> lastadd.h <a href="#=:encoding.T:encoding.T:boolean">=</a> c <span class="keyword">then</span> h <span class="keyword">else</span> encodingstate(all.h, length.h, encodetable.h, c)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> code = <a href="#T:state">to:encoding.T</a>(n.all.h <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> p = encodingpair(datav, code, hashv) <br> <span class="keyword">let</span> codeindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>.valueofencoding.code <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1</span> <span class="keyword">for</span> listencode = [p], e ∈ (encodetable.h) <a href="#sub:seq.T:int:T">sub</a> dataindex <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> data.e <a href="#">=</a> data.p <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#notsamehash::T:int:int:bits:boolean">notsamehash:T</a>(hash.p, hash.e, mask) <span class="keyword">then</span> listencode <br> <span class="keyword">else</span> listencode <a href="#">+</a> e</span> <span class="keyword">let</span> etable = encodetable.h <br> <span class="keyword">let</span> newencode = <a href="#">replace</a>(encodetable.h, dataindex, listencode), <br> <span class="comment">{subseq(etable, 1, dataindex-1)+listencode+subseq(etable, dataindex+1, n.etable)}</span> <br> <span class="keyword">if</span> 3 <a href="#*:int:int:int">*</a> length.h <a href="#>:int:int:boolean">></a> 2 <a href="#*:int:int:int">*</a> tablesize <span class="keyword">then</span> <span class="block">encodingstate( <span class="block">all.h <a href="#">+</a> p <br>, length.h <a href="#+:int:int:int">+</a> 1 <br>, newencode <a href="#">+</a> newencode <a href="#">+</a> newencode <a href="#">+</a> newencode <br>, code.p</span>)</span> <span class="keyword">else</span> encodingstate(all.h <a href="#">+</a> p, length.h <a href="#+:int:int:int">+</a> 1, newencode, code.p)</span> <p> <a id="addencodings:seq.T:int" href="#encoding">Function</a> addencodings(l:seq.T) int <br> <span class="keyword">let</span> inst = getinstance3:T <br> <span class="keyword">for</span> acc = <a href="#T:state">to:encoding.T</a>(0), @e ∈ l <span class="keyword">do</span> primitiveadd(inst, @e), <br>0 <p> <a id="decode:encoding.T:T" href="#encoding">Function</a> decode(t:encoding.T) T <br> <span class="keyword">let</span> h = <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T <br> <span class="keyword">assert</span> <a href="#between:int:int:int:boolean">between</a>(valueofencoding.t, 1, n.all.h) <span class="keyword">report</span> <span class="literal">"no such encoding"</span> <a href="#">+</a> <a href="#toword:int:word">toword</a>.valueofencoding.t <a href="#">+</a> stacktrace, <br>data.(all.h) <a href="#sub:seq.T:int:T">sub</a> valueofencoding.t <p>type einfo is state:indirect.encodingstate.T, encodingnumber:int, allocatein:ptr <p> <a id="encodingstate:einfo.T:encodingstate.T" href="#encoding">function</a> encodingstate(e:einfo.T) encodingstate.T fromindirect.state.e <p> <span class="keyword">builtin</span> getinstance3:T einfo.T <p> <a id="add1encoding:ptr:T:encoding.T" href="#encoding">Function</a> add1encoding(p:ptr, data:T) encoding.T <br> <span class="comment">{ptr is used instead of einfo since einfo is also defined in encodingsupport}</span> <br> <span class="keyword">let</span> t = <a href="#addencoding:encodingstate.T:T:encodingstate.T">addencoding</a>(fromindirect.state.bitcast2:einfo.T(p), data) <br> <span class="keyword">let</span> discard = set(p, t), <br>lastadd.t <p> <span class="keyword">builtin</span> bitcast2:einfo.T(ptr) einfo.T <p> <span class="keyword">builtin</span> primitiveadd(e:einfo.T, s:T) encoding.T <p>type e3 is sequence, data:seq.encodingpair.T <p> <a id="sequenceIndex:e3.T:int:T" href="#encoding">function</a> sequenceIndex(a:e3.T, i:int) T data.(data.a) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="encodingdata::T:seq.T" href="#encoding">Function</a> encodingdata:T seq.T <br> <span class="keyword">let</span> t = all. <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T, <br>toseq.e3(n.t, t) <p> <a id="encode:T:encoding.T" href="#encoding">Function</a> encode(t:T) encoding.T <br> <span class="keyword">let</span> instance = getinstance3:T <br> <span class="keyword">let</span> r = <span class="block"> <a href="#lookuprep:T:encodingstate.T:seq.encodingpair.T">lookuprep</a>(t, <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.instance),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> primitiveadd(instance, t) <br> <span class="keyword">else</span> code.r <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="=:encoding.T:encoding.T:boolean" href="#encoding">Function</a> =(a:encoding.T, b:encoding.T) boolean valueofencoding.a <a href="#=:int:int:boolean">=</a> valueofencoding.b <p> <a id=">1:encoding.T:encoding.T:ordering" href="#encoding">Function</a> >1(a:encoding.T, b:encoding.T) ordering valueofencoding.a <a href="#>1:T:T:ordering">>1</a> valueofencoding.b <p> <a id="hash:encoding.T:int" href="#encoding">Function</a> hash(a:encoding.T) int valueofencoding.a <p> <a id="lookuprep:T:encodingstate.T:seq.encodingpair.T" href="#encoding">function</a> lookuprep(t:T, inst:encodingstate.T) seq.encodingpair.T <br> <span class="keyword">let</span> mask = bits.-1 <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> <a href="#floorLog2:int:int">floorLog2</a>.n.encodetable.inst) <br> <span class="keyword">let</span> dataindex = <span class="block">toint( <a href="#tobits:int:bits">tobits</a>. <a href="#">hash</a>.t <a href="#∧:bits:bits:bits">∧</a> mask) <br> <a href="#+:int:int:int">+</a> 1,</span> <a href="#lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T">lookuprep2</a>(t, (encodetable.inst) <a href="#sub:seq.T:int:T">sub</a> dataindex) <p> <a id="lookuprep2:T:seq.encodingpair.T:seq.encodingpair.T" href="#encoding">function</a> lookuprep2(t:T, s:seq.encodingpair.T) seq.encodingpair.T <br> <span class="keyword">for</span> acc = empty:seq.encodingpair.T, e ∈ s <br> <span class="keyword">do</span> <span class="keyword">if</span> t <a href="#">=</a> data.e <span class="keyword">then</span> acc <a href="#">+</a> e <span class="keyword">else</span> acc, <br>acc <p> <a id="findencode:T:seq.T" href="#encoding">Function</a> findencode(t:T) seq.T <br> <span class="keyword">let</span> r = <span class="block"> <a href="#lookuprep:T:encodingstate.T:seq.encodingpair.T">lookuprep</a>(t, <a href="#encodingstate:einfo.T:encodingstate.T">encodingstate</a>.getinstance3:T),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> empty:seq.T <span class="keyword">else</span> [data.r <a href="#sub:seq.T:int:T">sub</a> 1] <p> <a id="addorder:T:int" href="#encoding">Function</a> addorder(t:T) int valueofencoding. <a href="#encode:T:encoding.T">encode</a>.t <p> <a id="analyze:encodingstate.T:seq.word" href="#encoding">function</a> analyze(t:encodingstate.T) seq.word <br> <span class="literal">"numele ="</span> <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>.n.all.t <br> <a href="#">+</a> <span class="literal">"encodecounts"</span> <br> <a href="#">+</a> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(encodetable.t, 1, 0, 0, 0) <p> <a id="counts:seq.seq.encodingpair.T:int:int:int:int:seq.word" href="#encoding">function</a> counts(s:seq.seq.encodingpair.T, i:int, one:int, two:int, big:int) seq.word <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> acc = <span class="literal">""</span>, @e ∈ [n.s, one, two, big] <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#toword:int:word">toword</a>.@e, <br>acc</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> t = n.s <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> t <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two, big) <br> <span class="keyword">else</span> if t <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one <a href="#+:int:int:int">+</a> 1, two, big) <br> <span class="keyword">else</span> if t <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two <a href="#+:int:int:int">+</a> 1, big) <br> <span class="keyword">else</span> <a href="#counts:seq.seq.encodingpair.T:int:int:int:int:seq.word">counts</a>(s, i <a href="#+:int:int:int">+</a> 1, one, two, big <a href="#+:int:int:int">+</a> 1)</span> <p> <span class="keyword" id="markup">Module</span> markup <p>use standard <p>use classinfo <p>use set.classinfo <p>use seq1.classinfo <p>use seq1.mark <p>use stack.mark <p>use UTF8 <p>use seq1.char <p>use stack.seq.word <p>use seq1.seq.word <p>use seq1.word <p>use format1a <p>/Export txt2html(z:seq.seq.word, replacements:set.classinfo, xhtml:boolean)seq.word <p> <span class="keyword">Export</span> textFormat1a(myinput:seq.word) UTF8 <p> <span class="keyword">Export</span> HTMLformat1a(myinput:seq.word) UTF8 <p> <span class="keyword">Export</span> type:classinfo <p> <span class="keyword">Export</span> esc(z:seq.word) seq.word <p> <a id="dawsextensions:word:stack.seq.word:stack.seq.word" href="#markup">Function</a> dawsextensions(op:word, argstk:stack.seq.word) stack.seq.word <br> <span class="comment">{???? show paramaterized markup so this function can be changed}</span> <br> <span class="comment">{return empty:stack.seq.word if not defined}</span> <br> <span class="comment">{if op ∈"/pretty"then push(pop.argstk, pretty.top.argstk)else}</span> <br> <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <p> <a id="stdCSS:seq.classinfo" href="#markup">Function</a> stdCSS seq.classinfo <br> <span class="keyword">let</span> data = <span class="block"> <span class="literal">"span.avoidwrap{display:inline-block ;}span.keyword{color:blue ;}span.literal{color:red ; transform: }span.comment{color:green ;}span.block{padding:0px 0px 0px 0px ; margin:0px 0px 0px 20px ; display:block ;}"</span>,</span> <a href="#processCSS:seq.seq.word:seq.classinfo:seq.classinfo">processCSS</a>([data], <a href="#defaults:seq.classinfo">defaults</a>) <p> <a id="processTXT:seq.seq.word:seq.classinfo:boolean:seq.word:UTF8" href="#markup">Function</a> processTXT( <br>z:seq.seq.word <br>, replacements:seq.classinfo <br>, xhtml:boolean <br>, lang:seq.word <br>) UTF8 <br> <span class="keyword">let</span> p1 = z <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">for</span> header = 0, idx = 1, w ∈ p1 <br> <span class="keyword">do</span> next( <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">"/base /link /title"</span> <span class="keyword">then</span> idx <span class="keyword">else</span> header, idx <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">let</span> newz = <span class="block">[ <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p1, 1, header) <a href="#">+</a> <span class="literal">"/head"</span> <br>, p1 <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> header</span>] <br> <a href="#">+</a> z <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1</span> <span class="keyword">let</span> final = <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>( <span class="keyword">if</span> xhtml <span class="keyword">then</span> <span class="literal">"/tag &lt;/body>&lt;/html>"</span> <span class="keyword">else</span> <span class="literal">""</span>), <br> <a href="#header1:boolean:seq.word:UTF8">header1</a>(xhtml, lang) <br> <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#HTMLformat1a:seq.word:UTF8">HTMLformat1a</a>. <a href="#txt2html:seq.seq.word:set.classinfo:boolean:seq.word">txt2html</a>(newz, <a href="#asset:seq.T:set.T">asset</a>.replacements, xhtml) <br> <a href="#+:UTF8:UTF8:UTF8">+</a> final <p> <a id="header1:boolean:seq.word:UTF8" href="#markup">function</a> header1(xhtml:boolean, lang:seq.word) UTF8 <br> <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>( <span class="block"> <span class="keyword">if</span> xhtml <span class="keyword">then</span> <span class="literal">"&lt;?xml version =:( <a href="#">dq</a>. <span class="literal">"1.0"</span>)encoding =:( <a href="#">dq</a>. <span class="literal">"utf-8"</span>)?> &lt;html xmlns =:( <a href="#">dq</a>. <span class="literal">"http://www.w3.org/1999/xhtml"</span>)xmlns:epub =:( <a href="#">dq</a>. <span class="literal">"http://www.idpf.org/2007/ops"</span>)>"</span> <br> <span class="keyword">else</span> <span class="literal">"&lt;!doctype html> &lt;html lang /nsp =:( <a href="#">dq</a>. <span class="literal">":(lang)"</span>)> &lt;meta charset /nsp =:( <a href="#">dq</a>. <span class="literal">"utf-8"</span>)>"</span></span>) <p>type mark is kind:word, place:int <p> <a id="%:mark:seq.word" href="#markup">function</a> %(m:mark) seq.word <span class="literal">":(kind.m):(place.m)"</span> <p> <a id="push:stack.mark:int:stack.mark" href="#markup">function</a> push(s:stack.mark, i:int) stack.mark <br>push(s, mark( <span class="literal">"mark"</span> <a href="#sub:seq.T:int:T">sub</a> 1, i)) <p> <a id="txt2html:seq.seq.word:set.classinfo:boolean:seq.word" href="#markup">Function</a> txt2html(z:seq.seq.word, replacements:set.classinfo, xhtml:boolean) seq.word <br> <span class="comment">{covert paragraph to html}</span> <br> <span class="keyword">let</span> gdefatt = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, <span class="literal">"/global$defs"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">let</span> globaldefs = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.gdefatt <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> def.gdefatt <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">let</span> pdef = <span class="block">def. <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">for</span> <span class="block">acc0 = <span class="literal">""</span> <br>, mark0 = push( <span class="block"> <a href="#empty::stack.T:stack.T">empty:stack.mark</a> <br>, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, 0)</span>) <br>, p ∈ z</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">assert</span> place. <a href="#">top</a>.mark0 <a href="#=:int:int:boolean">=</a> n.acc0 <span class="keyword">report</span> <span class="literal">"check23:( <a href="#">top</a>.mark0):(n.acc0)"</span> <br> <span class="keyword">for</span> skip = false, defines = <span class="literal">""</span>, marks = mark0, acc = acc0, e ∈ p <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <a href="#=:word:word:boolean">=</a> <a href="#escapeformat:word">escapeformat</a> <span class="keyword">then</span> <span class="block">next( <span class="block"> <a href="#not:boolean:boolean">not</a>.skip <br>, defines <br>, marks <br>, acc <a href="#">+</a> <a href="#escapeformat:word">escapeformat</a></span>)</span> <span class="keyword">else</span> if skip <span class="keyword">then</span> next(skip, defines, marks, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> if e <a href="#">∈</a> <span class="literal">"//"</span> <span class="keyword">then</span> next(skip, defines, <a href="#">push</a>(marks, n.acc), acc) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> r = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(replacements, e), <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.r <span class="keyword">then</span> next(skip, defines, marks, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> att = r <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">let</span> basedon = baseon.att, <br> <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.att <a href="#∧:boolean:boolean:boolean">∧</a> key.att <a href="#=:word:word:boolean">=</a> tag.att <span class="keyword">then</span> <span class="block">{marks beginning of tag} <br> <span class="keyword">let</span> newmarks = push(push( <a href="#">pop</a>.marks, mark(basedon, n.acc)), <a href="#">top</a>.marks), <br>next(skip, defines, newmarks, acc)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> acc1 = acc <br> <span class="keyword">let</span> marks1 = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/li"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> n.toseq.marks <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> new = <span class="block">push( <span class="block">push( <span class="block"> <a href="#">pop</a>.marks <br>, mark( <span class="literal">"/ul"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>) <br>, mark( <span class="literal">"/li"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>),</span> new</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> mark2 = <span class="block"> <a href="#advance:stack.mark:mark:stack.mark">advance</a>( <span class="block"> <a href="#">pop</a>.marks <br>, mark( <span class="literal">"/li"</span> <a href="#sub:seq.T:int:T">sub</a> 1, place. <a href="#">top</a>.marks)</span>),</span> mark2</span></span> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/div"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> place. <a href="#">top</a>.marks <a href="#=:int:int:boolean">=</a> n.acc1 <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> marks2 = <span class="block"> <span class="keyword">if</span> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"block"</span> <a href="#∧:boolean:boolean:boolean">∧</a> place. <a href="#">top</a>.marks <a href="#=:int:int:boolean">=</a> n.acc1 <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> marks</span> <span class="keyword">assert</span> kind. <a href="#">top</a>.marks2 <a href="#">∈</a> <span class="literal">"/li"</span> <span class="keyword">report</span> <span class="literal">"problem 890:( <a href="#%n:seq.T:seq.word">%n</a>.toseq.marks):(p)"</span> <br> <span class="comment">{let acc2 = if place.top.marks2 = n.acc1 then acc1 else finishp(acc1, marks2, xhtml, replacements, defines+pdef),}</span> <br> <span class="comment">{???? should do more than just popstack doesnot assign class or and end tag}</span> <br> <a href="#">pop</a>.marks2</span> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/tr"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"/td"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/table"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks <a href="#">∈</a> <span class="literal">"/tr"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks <br> <span class="keyword">else</span> marks</span> <span class="keyword">assert</span> basedon ∉ <span class="literal">"/div"</span> <a href="#∨:boolean:boolean:boolean">∨</a> kind. <a href="#">top</a>.marks1 <a href="#=:word:word:boolean">=</a> basedon <span class="keyword">report</span> <span class="literal">":(key.att)does not have matching start"</span> <br> <span class="keyword">assert</span> basedon ∉ <span class="literal">"/ul /ol"</span> <a href="#∨:boolean:boolean:boolean">∨</a> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"/ul /ol /div"</span> <span class="keyword">report</span> <span class="literal">":(key.att)does not have matching start:( <a href="#%n:seq.T:seq.word">%n</a>.toseq.marks1)/p:(p)"</span> <br> <span class="keyword">let</span> lastplace = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/head"</span> <span class="keyword">then</span> 0 <br> <span class="keyword">else</span> if ( <a href="#ismark:classinfo:boolean">ismark</a>.att <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#isdefine:classinfo:boolean">isdefine</a>.att) <br> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.marks1 ∉ <span class="literal">"mark"</span> <span class="keyword">then</span> n.acc1 <a href="#">-</a> 1 <br> <span class="keyword">else</span> place. <a href="#">top</a>.marks1</span> <span class="keyword">let</span> smallacc = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc1, 1, lastplace) <br> <span class="keyword">let</span> content = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc1, lastplace <a href="#+:int:int:int">+</a> 1, n.acc1), <br> <span class="keyword">let</span> combinedDef = defines <a href="#">+</a> def.att <a href="#">+</a> globaldefs, <br> <span class="keyword">if</span> <a href="#isdefine:classinfo:boolean">isdefine</a>.att <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> eval = <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>( <span class="literal">""</span>, combinedDef, content, replacements, xhtml) <br> <span class="keyword">let</span> stk2 = <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"mark"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1, <br>next(skip, defines <a href="#">+</a> eval, stk2, smallacc)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> new = <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>(smallacc, combinedDef, content, replacements, xhtml) <br> <span class="keyword">let</span> stk2 = <span class="block"> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/caption"</span> <span class="keyword">then</span> push(marks1, mark( <span class="literal">"/tr"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if <a href="#ismark:classinfo:boolean">ismark</a>.att <span class="keyword">then</span> <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"mark"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1 <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/br"</span> <span class="keyword">then</span> marks <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/tr"</span> <span class="keyword">then</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"/tr"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/td /th"</span> <span class="keyword">then</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"/td"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> if basedon <a href="#">∈</a> <span class="literal">"/div"</span> <span class="keyword">then</span> push( <a href="#">pop</a>.marks1, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> stk3 = <span class="keyword">if</span> kind. <a href="#">top</a>.marks1 <a href="#">∈</a> <span class="literal">"block"</span> <span class="keyword">then</span> <a href="#">pop</a>.marks1 <span class="keyword">else</span> marks1, <br> <span class="keyword">if</span> basedon <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <a href="#∧:boolean:boolean:boolean">∧</a> kind. <a href="#">top</a>.stk3 <a href="#">∈</a> <span class="literal">"/ol /ul"</span> <span class="keyword">then</span> push( <a href="#">pop</a>.stk3, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)) <br> <span class="keyword">else</span> <a href="#advance:stack.mark:mark:stack.mark">advance</a>(marks1, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.new)),</span></span> next(skip, <span class="literal">""</span>, stk2, new),</span></span></span></span></span> <span class="keyword">let</span> newacc = <a href="#finishp:seq.word:stack.mark:boolean:set.classinfo:seq.word:seq.word">finishp</a>(acc, marks, xhtml, replacements, defines <a href="#">+</a> pdef), <br> <span class="keyword">if</span> newacc = acc <span class="keyword">then</span> next(acc, marks) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">newacc <br>, push( <a href="#">pop</a>.marks, mark( <span class="literal">"block"</span> <a href="#sub:seq.T:int:T">sub</a> 1, n.newacc))</span>)</span></span> <span class="comment">{assert false report"Final"+esc.acc0}</span> <br>acc0 <p> <a id="advance:stack.mark:mark:stack.mark" href="#markup">function</a> advance(stk:stack.mark, m:mark) stack.mark <br>push( <span class="block"> <span class="keyword">if</span> kind.m <a href="#=:word:word:boolean">=</a> kind. <a href="#">top</a>.stk <span class="keyword">then</span> <a href="#">pop</a>.stk <span class="keyword">else</span> stk <br>, m</span>) <p> <a id="finishp:seq.word:stack.mark:boolean:set.classinfo:seq.word:seq.word" href="#markup">function</a> finishp( <br>acc:seq.word <br>, marks:stack.mark <br>, xhtml:boolean <br>, replacements:set.classinfo <br>, defs:seq.word <br>) seq.word <br> <span class="keyword">if</span> n.acc <a href="#=:int:int:boolean">=</a> place. <a href="#">top</a>.marks <span class="keyword">then</span> acc <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> top = place. <a href="#">top</a>.marks <br> <span class="keyword">let</span> content = <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, top <a href="#+:int:int:int">+</a> 1, n.acc) <br> <span class="keyword">let</span> new = <span class="block"> <a href="#evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word">evaldef</a>( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, 1, top) <br>, defs <br>, content <br>, replacements <br>, xhtml</span>),</span> <span class="comment">{assert"zzz"sub 1 ∉ acc report"HJK"+showZ.new}</span> <br>new</span> <p> <a id="evaldef:seq.word:seq.word:seq.word:set.classinfo:boolean:seq.word" href="#markup">function</a> evaldef( <br>smallacc:seq.word <br>, defs:seq.word <br>, content:seq.word <br>, replacements:set.classinfo <br>, xhtml:boolean <br>) seq.word <br> <span class="keyword">let</span> evalstr = <a href="#">extractdef</a>(defs, <span class="literal">"output"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">for</span> <span class="block">haveatt = <span class="literal">""</span> <br>, stk = <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc = smallacc <br>, intag = false <br>, e3 ∈ evalstr <a href="#">+</a> <span class="literal">"?"</span></span> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"="</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:stack.T:boolean">isempty</a>.stk <span class="keyword">then</span> next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>(stk, <span class="literal">"bottom"</span>), acc, intag) <br> <span class="keyword">else</span> if intag <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <span class="keyword">then</span> <span class="block">next( <span class="block"> <span class="literal">""</span> <br>, <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>( <a href="#">top</a>.stk, haveatt <a href="#sub:seq.T:int:T">sub</a> 1) <br>, intag</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block">haveatt <br>, <a href="#empty::stack.T:stack.T">empty:stack.seq.word</a> <br>, acc <a href="#">+</a> <a href="#">top</a>.stk <br>, intag</span>)</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> info = <a href="#lookuptag:set.classinfo:word:seq.classinfo">lookuptag</a>(replacements, e3), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.info <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isendtag:classinfo:boolean">isendtag</a>.info <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> new = <span class="keyword">if</span> xhtml <a href="#∨:boolean:boolean:boolean">∨</a> e3 ∉ <span class="literal">"&lt;/p> &lt;/li>"</span> <span class="keyword">then</span> acc <a href="#">+</a> <span class="literal">"/tag"</span> <a href="#">+</a> e3 <span class="keyword">else</span> acc, <br>next(haveatt, stk, new, intag)</span> <span class="keyword">else</span> <span class="block">{assert e3 ∈"&lt;titlex"report"here gg JKL:(e3):(intag)"+acc+"/p"+evalstr} <br> <span class="keyword">let</span> acc1 = <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"&lt;sub &lt;sup"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#last:seq.T:T">last</a>.acc <a href="#">∈</a> <span class="literal">"/tag"</span> <span class="keyword">then</span> acc <a href="#">+</a> e3 <br> <span class="keyword">else</span> acc <a href="#">+</a> <span class="literal">"/tag"</span> <a href="#">+</a> e3</span> <span class="keyword">else</span> acc <a href="#">+</a> <span class="literal">"/sp /tag"</span> <a href="#">+</a> e3,</span> next( <span class="literal">""</span>, stk, acc1, true)</span></span> <span class="keyword">else</span> if e3 <a href="#">∈</a> <span class="literal">"> />"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> end = <span class="keyword">if</span> xhtml <a href="#∧:boolean:boolean:boolean">∧</a> e3 <a href="#">∈</a> <span class="literal">"/>"</span> <span class="keyword">then</span> <span class="literal">"/tag /> /nsp"</span> <span class="keyword">else</span> <span class="literal">"/tag > /nsp"</span> <br> <span class="keyword">let</span> lastatt = <span class="block"> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <br> <a href="#∧:boolean:boolean:boolean">∧</a> intag <span class="keyword">then</span> <span class="block">acc <br> <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>( <span class="block"> <a href="#">extractdef</a>(defs, haveatt <a href="#sub:seq.T:int:T">sub</a> 1, content) <br>, haveatt <a href="#sub:seq.T:int:T">sub</a> 1</span>)</span> <span class="keyword">else</span> acc,</span> next( <span class="literal">""</span>, stk, lastatt <a href="#">+</a> end, false)</span> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>. <a href="#isempty:stack.T:boolean">isempty</a>.stk <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> e3 <a href="#">∈</a> <span class="literal">"/post /pre"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">assert</span> n.toseq.stk <a href="#>:int:int:boolean">></a> 2 <span class="keyword">report</span> <span class="literal">"XXX B"</span> <br> <span class="keyword">let</span> second = <a href="#">top</a>.stk <br> <span class="keyword">let</span> first = <a href="#">top</a>. <a href="#">pop</a>.stk, <br> <span class="keyword">let</span> val = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.first <a href="#∧:boolean:boolean:boolean">∧</a> e3 <a href="#">∈</a> <span class="literal">"/pre"</span> <span class="keyword">then</span> second <br> <span class="keyword">else</span> first <a href="#">+</a> <span class="literal">"/nsp"</span> <a href="#">+</a> second,</span> next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>( <a href="#">pop</a>(stk, 2), val), acc, intag)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> result = <a href="#dawsextensions:word:stack.seq.word:stack.seq.word">dawsextensions</a>(e3, stk), <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:stack.T:boolean">isempty</a>.result <span class="keyword">then</span> next(haveatt, result, acc, intag) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> value = <a href="#">extractdef</a>(defs, e3, content), <br>next(haveatt, <a href="#push:stack.T:T:stack.T">push</a>(stk, value), acc, intag)</span></span></span> <span class="keyword">else</span> if intag <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.haveatt <span class="keyword">then</span> next([e3], stk, acc, intag) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> val = <a href="#">extractdef</a>(defs, haveatt <a href="#sub:seq.T:int:T">sub</a> 1, content) <br> <span class="keyword">assert</span> haveatt <a href="#">∈</a> [ <span class="literal">"rel"</span>, <span class="literal">"class"</span>, <span class="literal">"id"</span>, <span class="literal">"alt"</span>] <span class="keyword">report</span> <span class="literal">"val att:(haveatt)this"</span> <a href="#">+</a> e3 <a href="#">+</a> acc <a href="#>>:seq.T:int:seq.T">>></a> (n.acc <a href="#">-</a> 4), <br>next([e3], stk, acc <a href="#">+</a> <a href="#attribute:seq.word:word:seq.word">attribute</a>(val, haveatt <a href="#sub:seq.T:int:T">sub</a> 1), intag)</span></span> <span class="keyword">else</span> next(haveatt, stk, acc <a href="#">+</a> <a href="#">extractdef</a>(defs, e3, content), intag),</span></span> acc <p> <a id="extractdef:seq.word:word:seq.word:seq.word" href="#markup">function</a> extractdef(defs:seq.word, name:word, content:seq.word) seq.word <br> <span class="keyword">if</span> name <a href="#">∈</a> <span class="literal">"content"</span> <span class="keyword">then</span> content <br> <span class="keyword">else</span> if name <a href="#">∈</a> <span class="literal">"colon"</span> <span class="keyword">then</span> <span class="literal">": "</span> <br> <span class="keyword">else</span> <a href="#">extractdef</a>(defs, name) <p> <a id="attribute:seq.word:word:seq.word" href="#markup">Function</a> attribute(val:seq.word, att:word) seq.word <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.val <span class="keyword">then</span> <span class="literal">""</span> <br> <span class="keyword">else</span> <span class="literal">"/sp:(att)/nsp =:(( <a href="#">dq</a> <a href="#">+</a> <span class="literal">"/nsp"</span> <a href="#">+</a> val <a href="#">+</a> <a href="#">dq</a>))"</span> <p> <span class="keyword" id="classinfo">Module</span> classinfo <p>precedence > for >1 >2 <p>use bits <p>use seq.char <p>use seq.classinfo <p>use set.classinfo <p>use sort.classinfo <p>use standard <p> <span class="keyword">Export</span> type:classinfo <p> <span class="keyword">Export</span> type:tagorder <p> <span class="keyword">Export</span> key(classinfo) word <p> <span class="keyword">Export</span> baseon(classinfo) word <p> <span class="keyword">Export</span> def(classinfo) seq.word <p> <span class="keyword">Export</span> tag(classinfo) word <p> <span class="keyword">Export</span> toseq(tagorder) seq.classinfo <p>type classinfo is key:word, baseon:word, def:seq.word, tag:word, flags:bits <p>type tagorder is toseq:seq.classinfo <p>The set.classinfo will be ordered by key. The taginfo will be ordered by tag. <p> <a id="totagorder:seq.classinfo:tagorder" href="#classinfo">Function</a> totagorder(a:seq.classinfo) tagorder <br>tagorder. <a href="#sort>3:seq.T:seq.T">sort>3</a>.a <p> <a id="lookuptag:set.classinfo:word:seq.classinfo" href="#classinfo">Function</a> lookuptag(lst:set.classinfo, tag:word) seq.classinfo <br> <a href="#lookuptag:tagorder:word:seq.classinfo">lookuptag</a>( <a href="#totagorder:seq.classinfo:tagorder">totagorder</a>.toseq.lst, tag) <p> <a id="lookupkey:set.classinfo:word:seq.classinfo" href="#classinfo">Function</a> lookupkey(lst:set.classinfo, key:word) seq.classinfo <br>toseq. <a href="#lookup:set.T:T:set.T">lookup</a>(lst, classinfo(key, key, <span class="literal">""</span>, key, <a href="#tobits:int:bits">tobits</a>.0)) <p> <a id="lookuptag:tagorder:word:seq.classinfo" href="#classinfo">Function</a> lookuptag(s:tagorder, tag:word) seq.classinfo <br> <span class="keyword">let</span> j = <span class="block"> <a href="#">binarysearch>3</a>(toseq.s, classinfo(tag, tag, <span class="literal">""</span>, tag, <a href="#tobits:int:bits">tobits</a>.0)),</span> <span class="keyword">if</span> j <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> empty:seq.classinfo <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> low = j, high = j, up = true, down = true <br> <span class="keyword">while</span> up <a href="#∨:boolean:boolean:boolean">∨</a> down <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> newdown = <span class="block">low <a href="#>:int:int:boolean">></a> 1 <a href="#∧:boolean:boolean:boolean">∧</a> tag <a href="#=:word:word:boolean">=</a> tag.(toseq.s) <a href="#sub:seq.T:int:T">sub</a> (low <a href="#">-</a> 1)</span> <span class="keyword">let</span> newup = <span class="block">high <a href="#&lt;:int:int:boolean">&lt;</a> n.toseq.s <a href="#∧:boolean:boolean:boolean">∧</a> tag <a href="#=:word:word:boolean">=</a> tag.(toseq.s) <a href="#sub:seq.T:int:T">sub</a> (high <a href="#+:int:int:int">+</a> 1)</span> <span class="keyword">let</span> newlow = <span class="keyword">if</span> newdown <span class="keyword">then</span> low <a href="#">-</a> 1 <span class="keyword">else</span> low, <br> <span class="keyword">let</span> newhigh = <span class="keyword">if</span> newup <span class="keyword">then</span> high <a href="#+:int:int:int">+</a> 1 <span class="keyword">else</span> high, <br>next(newlow, newhigh, newup, newdown),</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.s, low, high)</span> <p> <a id="%:classinfo:seq.word" href="#classinfo">Function</a> %(a:classinfo) seq.word <br> <a href="#esc:seq.word:seq.word">esc</a>.[key.a, baseon.a, tag.a] <a href="#">+</a> def.a <p> <a id=">1:classinfo:classinfo:ordering" href="#classinfo">Function</a> >1(a:classinfo, b:classinfo) ordering key.a <a href="#">>1</a> key.b <p> <a id=">3:classinfo:classinfo:ordering" href="#classinfo">function</a> >3(a:classinfo, b:classinfo) ordering tag.a <a href="#">>1</a> tag.b <p> <a id="=:classinfo:classinfo:boolean" href="#classinfo">function</a> =(a:classinfo, b:classinfo) boolean key.a <a href="#=:word:word:boolean">=</a> key.b <p> <a id="tokey:word:word" href="#classinfo">Function</a> tokey(w:word) word <br> <span class="keyword">let</span> a = <a href="#decodeword:word:seq.char">decodeword</a>.w, <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> 2 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span> <span class="keyword">then</span> w <br> <span class="keyword">else</span> <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block">[ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>] <br> <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.w <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1</span>)</span> <p> <a id="esc:seq.word:seq.word" href="#classinfo">Function</a> esc(z:seq.word) seq.word <br> <span class="keyword">for</span> dd = <span class="literal">""</span>, e ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <br> <a href="#">∈</a> <span class="literal">"/p /br<br>/sp /tag /keyword &lt;* *>"</span> <span class="keyword">then</span> dd <a href="#">+</a> <span class="literal">"/sp /tag:(e)/sp"</span> <br> <span class="keyword">else</span> dd <a href="#">+</a> e,</span> dd <p> <a id="removeesc:seq.word:seq.word" href="#classinfo">Function</a> removeesc(z:seq.word) seq.word <br> <span class="keyword">for</span> dd = <span class="literal">""</span>, e ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e <br> <a href="#">∈</a> <span class="literal">"/p /br<br>/sp /tag"</span> <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(dd, n.dd <a href="#">-</a> 1, n.dd) <br> = <span class="literal">"/sp /tag"</span> <span class="keyword">then</span> dd <a href="#>>:seq.T:int:seq.T">>></a> 2 <a href="#">+</a> e <br> <span class="keyword">else</span> dd <a href="#">+</a> e,</span> dd <p> <a id="classinfo2:set.classinfo:word:word:seq.word:seq.classinfo" href="#classinfo">Function</a> classinfo2( <br>base:set.classinfo <br>, ele:word <br>, class:word <br>, more:seq.word <br>) seq.classinfo <br> <span class="keyword">if</span> class <a href="#">∈</a> <span class="literal">"daws"</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> key = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> flags = <a href="#">extractdef</a>(more, <span class="literal">"flags"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br> <span class="keyword">for</span> acc = 0, w ∈ flags <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> str = <span class="literal">"mark noendtag define namedmark"</span> <br> <span class="keyword">let</span> i = <a href="#findindex:seq.T:T:int">findindex</a>(str, w), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.str <span class="keyword">then</span> acc <span class="keyword">else</span> acc <a href="#+:int:int:int">+</a> 2 <a href="#sup:int:int:int">sup</a> i</span> <span class="keyword">let</span> tag = <a href="#">merge</a>( <span class="literal">"&lt;"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> more1 = <span class="block"> <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(more, 1, 2) = <span class="literal">"flags: "</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> i = <span class="block"> <a href="#min:int:int:int">min</a>( <span class="block"> <a href="#findindex:seq.T:T:int">findindex</a>(more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 2, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <br>, <a href="#findindex:seq.T:T:int">findindex</a>(more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 2, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1)</span>),</span> <span class="keyword">if</span> i <a href="#+:int:int:int">+</a> 2 <a href="#>:int:int:boolean">></a> n.more <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> more <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i</span> <span class="keyword">else</span> more,</span> <span class="keyword">let</span> a = classinfo(key, key, more1, tag, bits.acc), <br> <span class="keyword">if</span> <a href="#noendtag:classinfo:boolean">noendtag</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#isdefine:classinfo:boolean">isdefine</a>.a <span class="keyword">then</span>[a] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> endtag = <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block">[ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"/"</span>] <br> <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.ele <br> <a href="#">+</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">">"</span></span>)</span> <span class="keyword">let</span> namedtag = <a href="#">merge</a>( <span class="literal">"//"</span> <a href="#">+</a> ele), <br> <span class="keyword">if</span> <a href="#ismark:classinfo:boolean">ismark</a>.a <span class="keyword">then</span>[a, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>(acc <a href="#+:int:int:int">+</a> 1))] <br> <span class="keyword">else</span> if <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.a <span class="keyword">then</span> <span class="block">[ <span class="block">a <br>, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>.1) <br>, classinfo(namedtag, key, <span class="literal">""</span>, namedtag, <a href="#tobits:int:bits">tobits</a>.16)</span>]</span> <span class="keyword">else</span> [a, classinfo(endtag, tag, <span class="literal">""</span>, endtag, <a href="#tobits:int:bits">tobits</a>.1)]</span></span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> key = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> class) <br> <span class="keyword">let</span> basekey = <a href="#">merge</a>( <span class="literal">"/"</span> <a href="#">+</a> ele) <br> <span class="keyword">let</span> info2 = <a href="#lookupkey:set.classinfo:word:seq.classinfo">lookupkey</a>(base, basekey) <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.info2 <span class="keyword">report</span> <span class="block"> <a href="#esc:seq.word:seq.word">esc</a>. <span class="literal">"no base class key basekey:"</span> <br> <a href="#">+</a> basekey <br> <a href="#">+</a> <span class="literal">"key:"</span> <br> <a href="#">+</a> key <br> <a href="#">+</a> <span class="literal">"ele:"</span> <br> <a href="#">+</a> ele</span> <span class="keyword">let</span> baseclass = info2 <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">for</span> newdefs = <span class="literal">"class"</span>, last = <span class="literal">"?"</span>, e ∈ more <br> <span class="keyword">do</span> next( <span class="keyword">if</span> e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> newdefs <a href="#">+</a> last <span class="keyword">else</span> newdefs, [e]) <br> <span class="keyword">for</span> skip = false, basedefs = <span class="literal">""</span>, last1 = <span class="literal">""</span>, e ∈ def.baseclass <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> e ∉ <span class="literal">": "</span> <span class="keyword">then</span> next(skip, <span class="keyword">if</span> skip <span class="keyword">then</span> basedefs <span class="keyword">else</span> basedefs <a href="#">+</a> last1, [e]) <br> <span class="keyword">else</span> if <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.last1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> last1 <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">∈</a> newdefs <span class="keyword">then</span> next(true, basedefs, <span class="literal">""</span>) <br> <span class="keyword">else</span> next(false, basedefs <a href="#">+</a> last1, [e])</span> <span class="comment">{assert class ∈"pic xx picC slide name"∨ basedefs+last1 = def.baseclass report":(class)more"+more+"/p<br>"+"base"+def.baseclass+"/p<br>"+"newbase"+basedefs+last1}</span> <br> <span class="keyword">let</span> y = <span class="block">classinfo( <span class="block">key <br>, basekey <br>, <span class="literal">"class: "</span> <a href="#">+</a> class <a href="#">+</a> more <a href="#">+</a> basedefs <a href="#">+</a> last1 <br>, tag.baseclass <br>, flags.baseclass</span>),</span> <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.info2 <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> namedtag = <a href="#">merge</a>( <span class="literal">"//"</span> <a href="#">+</a> class), <br>[y, classinfo(namedtag, basekey, <span class="literal">""</span>, namedtag, <a href="#tobits:int:bits">tobits</a>.16)]</span> <span class="keyword">else</span> [y]</span> <p> <a id="isendtag:classinfo:boolean" href="#classinfo">Function</a> isendtag(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.1) <a href="#=:bits:bits:boolean">=</a> bits.1 <p> <a id="ismark:classinfo:boolean" href="#classinfo">Function</a> ismark(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.2) <a href="#=:bits:bits:boolean">=</a> bits.2 <p> <a id="noendtag:classinfo:boolean" href="#classinfo">Function</a> noendtag(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.4) <a href="#=:bits:bits:boolean">=</a> bits.4 <p> <a id="isdefine:classinfo:boolean" href="#classinfo">Function</a> isdefine(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.8) <a href="#=:bits:bits:boolean">=</a> bits.8 <p> <a id="isnamedmark:classinfo:boolean" href="#classinfo">Function</a> isnamedmark(a:classinfo) boolean <br>(flags.a <a href="#∧:bits:bits:bits">∧</a> bits.16) <a href="#=:bits:bits:boolean">=</a> bits.16 <p> <a id="print:seq.classinfo:seq.word" href="#classinfo">Function</a> print(t:seq.classinfo) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, e ∈ t <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#isendtag:classinfo:boolean">isendtag</a>.e <span class="keyword">then</span> acc <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> flags = <span class="block">( <span class="keyword">if</span> <a href="#ismark:classinfo:boolean">ismark</a>.e <span class="keyword">then</span> <span class="literal">"mark"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#noendtag:classinfo:boolean">noendtag</a>.e <span class="keyword">then</span> <span class="literal">"noendtag"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isdefine:classinfo:boolean">isdefine</a>.e <span class="keyword">then</span> <span class="literal">"define"</span> <span class="keyword">else</span> <span class="literal">""</span>) <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isnamedmark:classinfo:boolean">isnamedmark</a>.e <span class="keyword">then</span> <span class="literal">"namedmark"</span> <span class="keyword">else</span> <span class="literal">""</span>)</span> <span class="keyword">let</span> flags1 = <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.flags <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> <span class="literal">"flags: :(flags)"</span>,</span> acc <br> <a href="#">+</a> [ <a href="#encodeword:seq.char:word">encodeword</a>( <a href="#decodeword:word:seq.char">decodeword</a>.baseon.e <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> 1)] <br> <a href="#">+</a> <span class="literal">".daws{/* daws:(flags1):(def.e)*/}"</span> <br> <a href="#">+</a> <span class="literal">"/br"</span>,</span></span> acc <p> <a id="extractdef:seq.word:word:seq.word" href="#classinfo">Function</a> extractdef(defs:seq.word, name:word) seq.word <br> <span class="keyword">for</span> notdone = true, found = false, acc = <span class="literal">""</span>, e ∈ defs <a href="#">+</a> <span class="literal">"dummy:"</span> <br> <span class="keyword">while</span> notdone <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">if</span> e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> next(false, found, acc <a href="#>>:seq.T:int:seq.T">>></a> 1) <span class="keyword">else</span> next(notdone, found, acc <a href="#">+</a> e) <br> <span class="keyword">else</span> if e <a href="#=:word:word:boolean">=</a> name <span class="keyword">then</span> next(notdone, found, [e]) <br> <span class="keyword">else</span> if e <a href="#">∈</a> <span class="literal">": "</span> <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> name <a href="#">∈</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(acc, 1, 1) <span class="keyword">then</span> {found}next(notdone, true, <span class="literal">""</span>) <br> <span class="keyword">else</span> next(notdone, found, <span class="literal">": "</span>)</span> <span class="keyword">else</span> next(notdone, found, [e]),</span> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>.found <span class="keyword">then</span> <span class="literal">""</span> <span class="keyword">else</span> acc <p> <a id="processCSS:seq.seq.word:seq.classinfo:seq.classinfo" href="#classinfo">Function</a> processCSS(z:seq.seq.word, dd:seq.classinfo) seq.classinfo <br> <span class="keyword">for</span> acc = dd, p ∈ z <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc1 = acc <br>, idx = <a href="#findindex:seq.T:T:int">findindex</a>(p, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1)</span> <span class="keyword">while</span> idx ≤ n.p <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> new = <span class="block"> <span class="keyword">if</span> idx <a href="#>:int:int:boolean">></a> n.p <br> <a href="#∨:boolean:boolean:boolean">∨</a> idx <a href="#&lt;:int:int:boolean">&lt;</a> 4 <br> <a href="#∨:boolean:boolean:boolean">∨</a> p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 2) ∉ <span class="literal">"."</span> <br> <a href="#∨:boolean:boolean:boolean">∨</a> p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 3) <a href="#">∈</a> <span class="literal">"}*/"</span> <span class="keyword">then</span> acc1 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> <span class="block">p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 1) ∉ <span class="literal">"daws"</span> <br> <a href="#∨:boolean:boolean:boolean">∨</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p, idx <a href="#+:int:int:int">+</a> 1, idx <a href="#+:int:int:int">+</a> 2) <br> = <span class="literal">"/* daws"</span></span> <span class="keyword">report</span> <span class="block"> <span class="literal">"In css file when defining how a new element:"</span> <br> + <span class="literal">"(subseq(p, idx-3, idx), daws requires instructions in a comment of form: /* daws... */"</span></span> <span class="keyword">let</span> more = <span class="block"> <span class="keyword">if</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(p, idx <a href="#+:int:int:int">+</a> 1, idx <a href="#+:int:int:int">+</a> 2) <br> = <span class="literal">"/* daws"</span> <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">p <br>, idx <a href="#+:int:int:int">+</a> 3 <br>, idx <a href="#+:int:int:int">+</a> <a href="#findindex:seq.T:T:int">findindex</a>(p <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> idx, <span class="literal">"*/"</span> <a href="#sub:seq.T:int:T">sub</a> 1) <a href="#">-</a> 1</span>)</span> <span class="keyword">else</span> <span class="literal">""</span>,</span> acc1 <br> <a href="#">+</a> <a href="#classinfo2:set.classinfo:word:word:seq.word:seq.classinfo">classinfo2</a>( <span class="block"> <a href="#asset:seq.T:set.T">asset</a>.acc1 <br>, {ele}p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 3) <br>, {class}p <a href="#sub:seq.T:int:T">sub</a> (idx <a href="#">-</a> 1) <br>, more</span>),</span></span> next(new, idx <a href="#+:int:int:int">+</a> <a href="#findindex:seq.T:T:int">findindex</a>(p <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> idx, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1)),</span> acc1,</span> acc <p> <a id="defaults:seq.classinfo" href="#classinfo">Function</a> defaults seq.classinfo <br> <span class="keyword">let</span> data = <span class="block"> <span class="literal">"q.daws{/* daws flags: mark output: &lt;q class id > content &lt;/q> totxt: = content /mark = class */}/br<br>b.daws{/* daws flags: mark output: &lt;b class id > content &lt;/b> totxt: = content /mark = class */}/br<br>i.daws{/* daws flags: mark output: &lt;i class id > content &lt;/i> totxt: = content /mark = class */}/br<br>em.daws{/* daws flags: mark output: &lt;em class id > content &lt;/em> totxt: = content /mark = class */}/br<br>strong.daws{/* daws flags: mark output: &lt;strong class id > content &lt;/strong> totxt: = content /mark = t class */}/br<br>span.daws{/* daws flags: mark output: &lt;span class id > content &lt;/span> totxt: = content /mark = id class */}/br<br>caption.daws{/* daws flags: mark output: &lt;caption class id > content &lt;/caption> totxt: = content /mark = class */}/br<br>a.daws{/* daws flags: mark output: &lt;a class id href = href = > content &lt;/a> totxt: = content /mark = href class */}/br<br>sub.daws{/* daws flags: mark output: &lt;sub class id > content &lt;/sub> totxt: = content /mark = class */}/br<br>sup.daws{/* daws flags: mark output: &lt;sup class id > content &lt;/sup> totxt: = content /mark = class */}/br<br>!doctype.daws{/* daws flags: noendtag */}/br<br>meta.daws{/* daws flags: noendtag */}/br<br>!.daws{/* daws flags: noendtag */}/br<br>html.daws{/* daws */}/br<br>body.daws{/* daws */}/br<br>?xml.daws{/* daws flags: noendtag */}/br<br>head.daws{/* daws &lt;body>: /tag &lt;body> output: &lt;head > content &lt;/head> &lt;body> totxt: content */}/br<br>link.daws{/* daws flags: mark noendtag rel: stylesheet output: &lt;link rel href = content = /> totxt: = href /mark = class */}/br<br>base.daws{/* daws flags: mark noendtag output: &lt;base rel href = content = /> totxt: = href /mark = class */}/br<br>title.daws{/* daws output: &lt;title class > content &lt;/title> totxt: content class /br<br>*/}/br<br>hr.daws{/* daws flags: noendtag output: &lt;hr class /> totxt: /p<br>content class */}/br<br>br.daws{/* daws flags: noendtag output: content &lt;br class id /> totxt: content id class /br<br>*/}/br<br>img.daws{/* daws flags: mark noendtag alt: a picture output: &lt;img class id alt src = prefix content /pre postfix /post = /> totxt: = prefix src postfix /post /pre /mark = id class */}/br<br>style.daws{/* daws */}/br<br>p.daws{/* daws output: &lt;p class id > content &lt;/p> totxt: /p<br>content id class /p<br>*/}/br<br>h1.daws{/* daws output: &lt;h1 class id > content &lt;/h1> totxt: /p<br>content id class */}/br<br>h2.daws{/* daws output: &lt;h2 class id > content &lt;/h2> totxt: /p<br>content id class */}/br<br>h3.daws{/* daws output: &lt;h3 class id > content &lt;/h3> totxt: /p<br>content id class */}/br<br>h4.daws{/* daws output: &lt;h4 class id > content &lt;/h4> totxt: /p<br>content id class */}/br<br>h5.daws{/* daws output: &lt;h5 class id > content &lt;/h5> totxt: /p<br>content id class */}/br<br>h6.daws{/* daws output: &lt;h6 class id > content &lt;/h6> totxt: /p<br>content id class */}/br<br>table.daws{/* daws output: &lt;table class id > content &lt;/table> totxt: /p<br>content id class */}/br<br>li.daws{/* daws output: &lt;li class id > content &lt;/li> totxt: /p<br>content id class /p<br>*/}/br<br>ol.daws{/* daws flags: namedmark output: &lt;ol class id > content &lt;/ol> totxt: /p<br>content id class /p<br>*/}/br<br>ul.daws{/* daws flags: namedmark output: &lt;ul class id > content &lt;/ul> totxt: /p<br>content id class */}/br<br>div.daws{/* daws flags: namedmark output: &lt;div class id > content &lt;/div> totxt: /p<br>= content /mark = id class */}/br<br>tr.daws{/* daws output: &lt;tr class id > content &lt;/tr> totxt: content id class /br<br>*/}/br<br>td.daws{/* daws output: &lt;td class id > content &lt;/td> totxt: content id class */}/br<br>th.daws{/* daws output: &lt;th class id > content &lt;/th> totxt: content id class */}/br<br>href.daws{/* daws flags: define /href: href output: /href colon content */}/br<br>id.daws{/* daws flags: define /id: id output: /id colon content */}/br<br>rel.daws{/* daws flags: define /rel: rel output: /rel colon content */}/br<br>"</span>,</span> <a href="#processCSS:seq.seq.word:seq.classinfo:seq.classinfo">processCSS</a>([data], empty:seq.classinfo) <p> <span class="keyword" id="format1a">Module</span> format1a <p>use PEGrules <p>use UTF8 <p>use bits <p>use seq.seq.byte <p>use seq1.byte <p>use stack.frame <p>use seq1.int <p>use set.int <p>use standard <p>use seq.tableEntry <p>use seq.word <p>use seq1.seq.word <p> <a id="showZ:seq.word:seq.word" href="#format1a">function</a> showZ(out:seq.word) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, w ∈ out <br> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>( <span class="block"> <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <a href="#">+</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"Z"</span></span>),</span> acc <p> <a id="toAttribute:seq.byte:seq.word:seq.byte" href="#format1a">function</a> toAttribute(a:seq.byte, b:seq.word) seq.byte <a href="#X:seq.word:seq.byte">X</a>.b <p> <a id="escape&amp;&lt;:seq.byte:seq.byte" href="#format1a">function</a> escape&amp;&lt;(a:seq.byte) seq.byte <br> <span class="keyword">let</span> lt = <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&lt;"</span> <br> <span class="keyword">let</span> amp = <span class="block"> <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"&amp;"</span></span> <span class="keyword">for</span> i = 1, e ∈ a <br> <span class="keyword">while</span> e ≠ lt <a href="#∧:boolean:boolean:boolean">∧</a> e ≠ amp <br> <span class="keyword">do</span> i <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:byte:byte:boolean">=</a> amp <span class="keyword">then</span> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&amp;amp;"</span> <br> <span class="keyword">else</span> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&amp;lt;"</span>) <br> <a href="#">+</a> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>(a <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i)</span> <p> <a id="X:seq.word:seq.byte" href="#format1a">function</a> X(a:seq.word) seq.byte <br> <span class="keyword">for</span> acc0 = empty:seq.byte, w ∈ a <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> acc = acc0, ch ∈ <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <span class="keyword">do</span> <span class="block">acc <br> <a href="#">+</a> ( <span class="keyword">if</span> toint.ch <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> [ <a href="#tobyte:int:byte">tobyte</a>.toint.ch] <br> <span class="keyword">else</span> toseqbyte. <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>.ch),</span> acc <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32,</span> acc0 <a href="#>>:seq.T:int:seq.T">>></a> 1 <p> <a id="textFormat1a:seq.word:UTF8" href="#format1a">Function</a> textFormat1a(myinput:seq.word) UTF8 <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> r = <a href="#parse:seq.word:seq.byte:boolean:thisresult">parse</a>(myinput, empty:seq.byte, true) <br> <span class="comment">{assert false report trace.r}</span> <br>UTF8( <a href="#result:thisresult:seq.byte">result</a>.r <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32) <p> <a id="HTMLformat1a:seq.word:UTF8" href="#format1a">Function</a> HTMLformat1a(myinput:seq.word) UTF8 <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> r = <a href="#parse:seq.word:seq.byte:boolean:thisresult">parse</a>(myinput, empty:seq.byte, false) <br> <span class="comment">{assert false report}</span> <br>UTF8( <a href="#result:thisresult:seq.byte">result</a>.r <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32) <p> <a id="addSpace:seq.byte:seq.byte" href="#format1a">function</a> addSpace(a:seq.byte) seq.byte <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a <a href="#=:byte:byte:boolean">=</a> <a href="#tobyte:int:byte">tobyte</a>.32 <span class="keyword">then</span> a <br> <span class="keyword">else</span> a <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.32 <p> <a id="paragraph:seq.byte:seq.byte" href="#format1a">function</a> paragraph(a:seq.byte) seq.byte <br> <span class="comment">{used for text and not html}</span> <br>a <br> <a href="#">+</a> ( <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a ≠ <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span>[ <a href="#tobyte:int:byte">tobyte</a>.10] <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.10 <br> <span class="keyword">else</span> [ <a href="#tobyte:int:byte">tobyte</a>.10]) <p> <a id="linebreak:seq.byte:seq.byte" href="#format1a">function</a> linebreak(a:seq.byte) seq.byte <br> <span class="comment">{used for text and not html}</span> <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <br> <a href="#∨:boolean:boolean:boolean">∨</a> a <a href="#sub:seq.T:int:T">sub</a> n.a ≠ <a href="#tobyte:int:byte">tobyte</a>.10 <span class="keyword">then</span> a <a href="#">+</a> [ <a href="#tobyte:int:byte">tobyte</a>.10] <br> <span class="keyword">else</span> a <p>CN process commands with no space pending <p>CS process commands with space pending <p>N no commands with no space pending <p>S no commands with space pending <p>NSBA no space before or after <p>NSB no space before <p> <a id="endMark:word" href="#format1a">function</a> endMark word <a href="#encodeword:seq.char:word">encodeword</a>.[char.254] <p> <a id="break:word" href="#format1a">function</a> break word <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="genPEG:word:seq.byte:thisresult:boolean:boolean:seq.boolean" href="#format1a">function</a> genPEG( <br>seqElementType:word <br>, attributeType:seq.byte <br>, resultType:thisresult <br>, textOut:boolean <br>, commonType:boolean <br>) seq.boolean <br> <span class="comment">{commonName: textOut notablex: wordmap: dq dq sub 1, ec escapeformat, tag merge."/ ta g", break"/br<br>"sub 1,"$"sub 1}</span> <br>[ <span class="block"> <span class="literal">"* CN+"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/-"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/."</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/:"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/. "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/: "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/("</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/)"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/{"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/}"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/["</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/]"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"/ /sp"</span> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ /nsp"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ break"</span> <br> <a href="#">=</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#linebreak:seq.byte:seq.byte">linebreak</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <span class="keyword">else</span> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&lt;br>"</span>) <br>, <span class="literal">"/ /p"</span> <br> <a href="#">=</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#paragraph:seq.byte:seq.byte">paragraph</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <span class="keyword">else</span> <span class="block"> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>([ <a href="#encodeword:seq.char:word">encodeword</a>.[char.10, char.10]] <a href="#">+</a> <span class="literal">"&lt;p>"</span>)</span>) <br>, <span class="literal">"/ ec N"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/ CS"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"+CS,"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br>, <span class="literal">"/ /sp"</span> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br>, <span class="literal">"/ tag ! ec any"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/ !+!-!.!:!. !: ! dq !(!)![!]!{!}! /p ! break ! ec ! tag ! /nsp any"</span> <br> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#$:int:seq.byte">$</a>.1 <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>. <a href="#$:int:seq.byte">$</a>.1) <br>, <span class="literal">"N N' ec CN"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.1 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.2 <br>, <span class="literal">"* N' S+"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/ S-"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/ S."</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/ S:"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/ S. "</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/ S: "</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ S dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/ S("</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/ S)"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/ S{"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/ S}"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/ S["</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/ S]"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"/ S"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#$:int:seq.byte">$</a>.1 <br>, <span class="literal">"/+"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br>, <span class="literal">"/-"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br>, <span class="literal">"/."</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br>, <span class="literal">"/:"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br>, <span class="literal">"/. "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br>, <span class="literal">"/: "</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br>, <span class="literal">"/ dq"</span> <br> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a> <br>, <span class="literal">"/("</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br>, <span class="literal">"/)"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br>, <span class="literal">"/{"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br>, <span class="literal">"/}"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br>, <span class="literal">"/["</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br>, <span class="literal">"/]"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br>, <span class="literal">"+S,"</span> <a href="#">=</a> <a href="#$:int:seq.byte">$</a>.0 <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br>, <span class="literal">"/ !+!-!.!:!. !: ! dq !(!)![!]!{!}! ec any"</span> <br> <a href="#">=</a> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>. <a href="#$:int:seq.byte">$</a>.0 <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#$:int:seq.byte">$</a>.1 <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>. <a href="#$:int:seq.byte">$</a>.1)</span>] <p>&lt;&lt;&lt;&lt; Below is auto generated code >>>> <p> <br>Non-terminals:CN CS N N' S <br>Terminals:()+,-.. <p> :: []any break dq ec tag{} <br>* CN ←+/-/./:/. /: / dq /(/)/{/}/[/]/ // break / <p>/ ec N / CS <br>+CS ←, / / tag ! ec any / !+!-!.!:!. !: ! dq !(!)![!]!{!}! <p>! break ! ec ! tag !any <br>N ← N' ec CN <br>* N' ← S+/ S-/ S./ S:/ S. / S: / S dq / S(/ S)/ S{/ S}/ S[/ S]/ S /+/-/./:/. /: / dq /(/)/{/}/[/] <br>+S ←, / !+!-!.!:!. !: ! dq !(!)![!]!{!}! ec any <p> <a id="action:int:seq.seq.byte:boolean:seq.byte" href="#format1a">function</a> action(partno:int, R:seq.seq.byte, textOut:boolean) seq.byte <br> <span class="keyword">if</span> partno <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 3 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 4 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 5 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 6 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 7 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 8 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 9 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 10 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 11 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 12 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 13 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 14 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 15 <span class="keyword">then</span> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 16 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 17 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#linebreak:seq.byte:seq.byte">linebreak</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"&lt;br>"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 18 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> textOut <span class="keyword">then</span> <a href="#paragraph:seq.byte:seq.byte">paragraph</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>([ <a href="#encodeword:seq.char:word">encodeword</a>.[char.10, char.10]] <a href="#">+</a> <span class="literal">"&lt;p>"</span>)</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 19 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 20 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 21 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 22 <span class="keyword">then</span> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 23 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 24 <span class="keyword">then</span> <span class="block"> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R)</span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 25 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 26 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 27 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 28 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 29 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 30 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 31 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 32 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 33 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 34 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 35 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 36 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 37 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 38 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 39 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <a href="#">+</a> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 40 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"+"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 41 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"-"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 42 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"."</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 43 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">":"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 44 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">". "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 45 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">": "</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 46 <span class="keyword">then</span> <span class="block">R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <a href="#">dq</a></span> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 47 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"("</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 48 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">")"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 49 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"{"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 50 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"}"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 51 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"["</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 52 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">"]"</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 53 <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <a href="#">+</a> <a href="#X:seq.word:seq.byte">X</a>. <span class="literal">","</span> <br> <span class="keyword">else</span> if partno <a href="#=:int:int:boolean">=</a> 54 <span class="keyword">then</span> <span class="block"> <a href="#addSpace:seq.byte:seq.byte">addSpace</a>.R <a href="#sub:seq.T:int:T">sub</a> (n.R <a href="#">-</a> 1) <br> <a href="#">+</a> ( <span class="keyword">if</span> textOut <span class="keyword">then</span> R <a href="#sub:seq.T:int:T">sub</a> n.R <br> <span class="keyword">else</span> <a href="#escape&amp;&lt;:seq.byte:seq.byte">escape&amp;&lt;</a>.R <a href="#sub:seq.T:int:T">sub</a> n.R)</span> <span class="keyword">else</span> R <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="mytable:seq.tableEntry" href="#format1a">function</a> mytable seq.tableEntry <br>[ <span class="block">{1} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.2 <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Match:state">Match</a> <br>, <a href="#Failure:state">Failure</a> <br>, <span class="literal">""</span></span>) <br>, {2} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(2, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.3 <br>, <span class="literal">""</span></span>) <br>, {3} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(3, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.4 <br>, <span class="literal">""</span></span>) <br>, {4} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(4, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.5 <br>, <span class="literal">""</span></span>) <br>, {5} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(5, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.6 <br>, <span class="literal">""</span></span>) <br>, {6} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(6, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.7 <br>, <span class="literal">""</span></span>) <br>, {7} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(7, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.8 <br>, <span class="literal">""</span></span>) <br>, {8} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(8, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.9 <br>, <span class="literal">""</span></span>) <br>, {9} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(9, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.10 <br>, <span class="literal">""</span></span>) <br>, {10} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(10, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.11 <br>, <span class="literal">""</span></span>) <br>, {11} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(11, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.12 <br>, <span class="literal">""</span></span>) <br>, {12} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(12, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.13 <br>, <span class="literal">""</span></span>) <br>, {13} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(13, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.14 <br>, <span class="literal">""</span></span>) <br>, {14} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(14, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.15 <br>, <span class="literal">""</span></span>) <br>, {15} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(15, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.16 <br>, <span class="literal">""</span></span>) <br>, {16} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(16, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.17 <br>, <span class="literal">""</span></span>) <br>, {17} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(17, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.18 <br>, <span class="literal">""</span></span>) <br>, {18} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(18, <a href="#T':int:state">T'</a>.2) <br>, <a href="#T':int:state">T'</a>.19 <br>, <span class="literal">""</span></span>) <br>, {19} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#NT:int:state">NT</a>.20 <br>, <a href="#NT:int:state">NT</a>.21 <br>, <span class="literal">""</span></span>) <br>, {20} <br>tableEntry( <span class="block"> <a href="#NT:int:state">NT</a>.46 <br>, <span class="literal">"N"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(19, <a href="#T':int:state">T'</a>.2) <br>, <a href="#NT:int:state">NT</a>.21 <br>, <span class="literal">""</span></span>) <br>, {21} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.22 <br>, <span class="literal">"CS"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(20, <a href="#T':int:state">T'</a>.2) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {22} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(21, <a href="#T':int:state">T'</a>.105) <br>, <a href="#T':int:state">T'</a>.23 <br>, <span class="literal">""</span></span>) <br>, {23} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(22, <a href="#T':int:state">T'</a>.105) <br>, <a href="#">T</a>.24 <br>, <span class="literal">""</span></span>) <br>, {24} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#!T:int:state">!T</a>.25 <br>, <a href="#!T:int:state">!T</a>.27 <br>, <span class="literal">""</span></span>) <br>, {25} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#!T:int:state">!T</a>.27 <br>, <a href="#MatchAny:int:state">MatchAny</a>.26 <br>, <span class="literal">""</span></span>) <br>, {26} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(23, <a href="#T':int:state">T'</a>.105) <br>, <a href="#!T:int:state">!T</a>.27 <br>, <span class="literal">""</span></span>) <br>, {27} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.28 <br>, <span class="literal">""</span></span>) <br>, {28} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.29 <br>, <span class="literal">""</span></span>) <br>, {29} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.30 <br>, <span class="literal">""</span></span>) <br>, {30} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.31 <br>, <span class="literal">""</span></span>) <br>, {31} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.32 <br>, <span class="literal">""</span></span>) <br>, {32} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.33 <br>, <span class="literal">""</span></span>) <br>, {33} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.34 <br>, <span class="literal">""</span></span>) <br>, {34} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.35 <br>, <span class="literal">""</span></span>) <br>, {35} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.36 <br>, <span class="literal">""</span></span>) <br>, {36} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.37 <br>, <span class="literal">""</span></span>) <br>, {37} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.38 <br>, <span class="literal">""</span></span>) <br>, {38} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.39 <br>, <span class="literal">""</span></span>) <br>, {39} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.40 <br>, <span class="literal">""</span></span>) <br>, {40} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.41 <br>, <span class="literal">""</span></span>) <br>, {41} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.42 <br>, <span class="literal">""</span></span>) <br>, {42} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.43 <br>, <span class="literal">""</span></span>) <br>, {43} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.44 <br>, <span class="literal">""</span></span>) <br>, {44} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.45 <br>, <span class="literal">""</span></span>) <br>, {45} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(24, <a href="#T':int:state">T'</a>.105) <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {46} <br>tableEntry( <span class="block"> <a href="#NT:int:state">NT</a>.49 <br>, <span class="literal">"N'"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#">T</a>.47 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {47} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#NT:int:state">NT</a>.48 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {48} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#T':int:state">T'</a>.2 <br>, <span class="literal">"CN"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce:int:state">Reduce</a>.25 <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {49} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.50 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {50} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(26, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.52 <br>, <span class="literal">""</span></span>) <br>, {51} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.52 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {52} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(27, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.54 <br>, <span class="literal">""</span></span>) <br>, {53} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.54 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {54} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(28, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.56 <br>, <span class="literal">""</span></span>) <br>, {55} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.56 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {56} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(29, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.58 <br>, <span class="literal">""</span></span>) <br>, {57} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.58 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {58} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(30, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.60 <br>, <span class="literal">""</span></span>) <br>, {59} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.60 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {60} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(31, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.62 <br>, <span class="literal">""</span></span>) <br>, {61} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.62 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {62} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(32, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.64 <br>, <span class="literal">""</span></span>) <br>, {63} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.64 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {64} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(33, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.66 <br>, <span class="literal">""</span></span>) <br>, {65} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.66 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {66} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(34, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.68 <br>, <span class="literal">""</span></span>) <br>, {67} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.68 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {68} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(35, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.70 <br>, <span class="literal">""</span></span>) <br>, {69} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.70 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {70} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(36, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.72 <br>, <span class="literal">""</span></span>) <br>, {71} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#T':int:state">T'</a>.72 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {72} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(37, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#">T</a>.74 <br>, <span class="literal">""</span></span>) <br>, {73} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#">T</a>.74 <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {74} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(38, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#NT:int:state">NT</a>.75 <br>, <span class="literal">""</span></span>) <br>, {75} <br>tableEntry( <span class="block"> <a href="#">NT</a>. <a href="#">T</a>.89 <br>, <span class="literal">"S"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(39, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.76 <br>, <span class="literal">""</span></span>) <br>, {76} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(40, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.77 <br>, <span class="literal">""</span></span>) <br>, {77} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(41, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.78 <br>, <span class="literal">""</span></span>) <br>, {78} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(42, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.79 <br>, <span class="literal">""</span></span>) <br>, {79} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(43, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.80 <br>, <span class="literal">""</span></span>) <br>, {80} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(44, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.81 <br>, <span class="literal">""</span></span>) <br>, {81} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(45, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.82 <br>, <span class="literal">""</span></span>) <br>, {82} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(46, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.83 <br>, <span class="literal">""</span></span>) <br>, {83} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(47, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.84 <br>, <span class="literal">""</span></span>) <br>, {84} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(48, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.85 <br>, <span class="literal">""</span></span>) <br>, {85} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(49, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.86 <br>, <span class="literal">""</span></span>) <br>, {86} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(50, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#T':int:state">T'</a>.87 <br>, <span class="literal">""</span></span>) <br>, {87} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(51, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#">T</a>.88 <br>, <span class="literal">""</span></span>) <br>, {88} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(52, <a href="#NT:int:state">NT</a>.49) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {89} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(53, <a href="#">T</a>.129) <br>, <a href="#!T:int:state">!T</a>.90 <br>, <span class="literal">""</span></span>) <br>, {90} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.91 <br>, <span class="literal">""</span></span>) <br>, {91} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.92 <br>, <span class="literal">""</span></span>) <br>, {92} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.93 <br>, <span class="literal">""</span></span>) <br>, {93} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.94 <br>, <span class="literal">""</span></span>) <br>, {94} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.95 <br>, <span class="literal">""</span></span>) <br>, {95} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.96 <br>, <span class="literal">""</span></span>) <br>, {96} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.97 <br>, <span class="literal">""</span></span>) <br>, {97} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.98 <br>, <span class="literal">""</span></span>) <br>, {98} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.99 <br>, <span class="literal">""</span></span>) <br>, {99} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.100 <br>, <span class="literal">""</span></span>) <br>, {100} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.101 <br>, <span class="literal">""</span></span>) <br>, {101} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.102 <br>, <span class="literal">""</span></span>) <br>, {102} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#!T:int:state">!T</a>.103 <br>, <span class="literal">""</span></span>) <br>, {103} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Fail:state">Fail</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.104 <br>, <span class="literal">""</span></span>) <br>, {104} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(54, <a href="#">T</a>.129) <br>, <a href="#Fail:state">Fail</a> <br>, <span class="literal">""</span></span>) <br>, {105} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(21, <a href="#T':int:state">T'</a>.105) <br>, <a href="#T':int:state">T'</a>.106 <br>, <span class="literal">""</span></span>) <br>, {106} <br>tableEntry( <span class="block"> <a href="#T':state">T'</a> <br>, <span class="literal">"/sp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(22, <a href="#T':int:state">T'</a>.105) <br>, <a href="#">T</a>.107 <br>, <span class="literal">""</span></span>) <br>, {107} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#!T:int:state">!T</a>.108 <br>, <a href="#!T:int:state">!T</a>.110 <br>, <span class="literal">""</span></span>) <br>, {108} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#!T:int:state">!T</a>.110 <br>, <a href="#MatchAny:int:state">MatchAny</a>.109 <br>, <span class="literal">""</span></span>) <br>, {109} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(23, <a href="#T':int:state">T'</a>.105) <br>, <a href="#!T:int:state">!T</a>.110 <br>, <span class="literal">""</span></span>) <br>, {110} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.111 <br>, <span class="literal">""</span></span>) <br>, {111} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.112 <br>, <span class="literal">""</span></span>) <br>, {112} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.113 <br>, <span class="literal">""</span></span>) <br>, {113} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.114 <br>, <span class="literal">""</span></span>) <br>, {114} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.115 <br>, <span class="literal">""</span></span>) <br>, {115} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.116 <br>, <span class="literal">""</span></span>) <br>, {116} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.117 <br>, <span class="literal">""</span></span>) <br>, {117} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.118 <br>, <span class="literal">""</span></span>) <br>, {118} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.119 <br>, <span class="literal">""</span></span>) <br>, {119} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.120 <br>, <span class="literal">""</span></span>) <br>, {120} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.121 <br>, <span class="literal">""</span></span>) <br>, {121} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.122 <br>, <span class="literal">""</span></span>) <br>, {122} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.123 <br>, <span class="literal">""</span></span>) <br>, {123} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/p"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.124 <br>, <span class="literal">""</span></span>) <br>, {124} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/br"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.125 <br>, <span class="literal">""</span></span>) <br>, {125} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.126 <br>, <span class="literal">""</span></span>) <br>, {126} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">merge</a>. <span class="literal">"/ ta g"</span> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.127 <br>, <span class="literal">""</span></span>) <br>, {127} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"/nsp"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.128 <br>, <span class="literal">""</span></span>) <br>, {128} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(24, <a href="#T':int:state">T'</a>.105) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>) <br>, {129} <br>tableEntry( <span class="block"> <a href="#">T</a> <br>, <span class="literal">","</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(53, <a href="#">T</a>.129) <br>, <a href="#!T:int:state">!T</a>.130 <br>, <span class="literal">""</span></span>) <br>, {130} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"+"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.131 <br>, <span class="literal">""</span></span>) <br>, {131} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"-"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.132 <br>, <span class="literal">""</span></span>) <br>, {132} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.133 <br>, <span class="literal">""</span></span>) <br>, {133} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">":"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.134 <br>, <span class="literal">""</span></span>) <br>, {134} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">". "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.135 <br>, <span class="literal">""</span></span>) <br>, {135} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">": "</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.136 <br>, <span class="literal">""</span></span>) <br>, {136} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#">dq</a> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.137 <br>, <span class="literal">""</span></span>) <br>, {137} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"("</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.138 <br>, <span class="literal">""</span></span>) <br>, {138} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">")"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.139 <br>, <span class="literal">""</span></span>) <br>, {139} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"["</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.140 <br>, <span class="literal">""</span></span>) <br>, {140} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"]"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.141 <br>, <span class="literal">""</span></span>) <br>, {141} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"{"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.142 <br>, <span class="literal">""</span></span>) <br>, {142} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <span class="literal">"}"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#!T:int:state">!T</a>.143 <br>, <span class="literal">""</span></span>) <br>, {143} <br>tableEntry( <span class="block"> <a href="#!T:state">!T</a> <br>, <a href="#escapeformat:word">escapeformat</a> <br>, <a href="#Success*:state">Success*</a> <br>, <a href="#MatchAny:int:state">MatchAny</a>.144 <br>, <span class="literal">""</span></span>) <br>, {144} <br>tableEntry( <span class="block"> <a href="#MatchAny:state">MatchAny</a> <br>, <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#Reduce*:int:state:state">Reduce*</a>(54, <a href="#">T</a>.129) <br>, <a href="#Success*:state">Success*</a> <br>, <span class="literal">""</span></span>)</span>] <p> <a id="=:seq.word:seq.byte:boolean" href="#format1a">function</a> =(seq.word, seq.byte) boolean true <p> <a id="$:int:seq.byte" href="#format1a">function</a> $(int) seq.byte empty:seq.seq.byte <a href="#sub:seq.T:int:T">sub</a> 1 <p>use standard <p>use seq.tableEntry <p>use seq1.frame <p>use stack.frame <p>use seq1.seq.byte <p>use PEGrules <p> <a id="place:thisresult:int" href="#format1a">function</a> place(r:thisresult) int i. <a href="#">top</a>.stk.r <p>type frame is <br>Sstate:state <br>, Fstate:state <br>, i:int <br>, result:seq.seq.byte <br>, faili:int <br>, failresult:seq.seq.byte <p>type thisresult is stk:stack.frame <p> <a id="status:thisresult:word" href="#format1a">Function</a> status(a:thisresult) word <br> <span class="keyword">if</span> Sstate. <a href="#">top</a>.stk.a ≠ <a href="#Match:state">Match</a> <span class="keyword">then</span> 'Failed <br> <span class="keyword">else</span> if <a href="#place:thisresult:int">place</a>.a <a href="#=:int:int:boolean">=</a> {length of input}faili. <a href="#">top</a>.stk.a <span class="keyword">then</span> 'Match <br> <span class="keyword">else</span> 'MatchPrefix <p> <a id="result:thisresult:seq.byte" href="#format1a">Function</a> result(a:thisresult) seq.byte <br> <span class="keyword">let</span> t = result. <a href="#">top</a>.stk.a, <br>t <a href="#sub:seq.T:int:T">sub</a> n.t <p> <a id="parse:seq.word:seq.byte:boolean:thisresult" href="#format1a">function</a> parse(myinput0:seq.word, initAttr:seq.byte, textOut:boolean) thisresult <br> <span class="keyword">let</span> myinput = <a href="#T:state">packed</a>(myinput0 <a href="#">+</a> <a href="#endMark:word">endMark</a>) <br> <span class="keyword">let</span> packedTable = <a href="#T:state">packed</a>. <a href="#mytable:seq.tableEntry">mytable</a> <br> <span class="keyword">for</span> <span class="block">stk = <a href="#empty::stack.T:stack.T">empty:stack.frame</a> <br>, state = <a href="#startstate:state">startstate</a> <br>, i = 1 <br>, inputi = myinput <a href="#sub:seq.T:int:T">sub</a> 1 <br>, result = [initAttr] <br>, faili = 1 <br>, failresult = [initAttr]</span> <span class="keyword">while</span> toint.state <a href="#>:int:int:boolean">></a> toint. <a href="#Match:state">Match</a> <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> actionState = <a href="#action:state:state">action</a>.state, <br> <span class="keyword">if</span> actionState <a href="#=:state:state:boolean">=</a> <a href="#Fail:state">Fail</a> <span class="keyword">then</span> <span class="block">{goto Fstate.top.stk, i = faili.top, pop.stk, discard result} <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br> <span class="keyword">if</span> toint. <a href="#action:state:state">action</a>.Fstate.top ≥ toint. <a href="#">S'</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> newi = i.top, <br>next( <span class="block"> <a href="#">pop</a>.stk <br>, <a href="#nextState:state:state">nextState</a>.Fstate.top <br>, newi <br>, idxNB(myinput, newi) <br>, result.top <br>, faili.top <br>, failresult.top</span>)</span> <span class="keyword">else</span> <span class="block">next( <span class="block"> <a href="#">pop</a>.stk <br>, Fstate.top <br>, faili.top <br>, idxNB(myinput, faili.top) <br>, failresult.top <br>, faili.top <br>, failresult.top</span>)</span></span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Success*:state">Success*</a> <span class="keyword">then</span> <span class="block">{goto Sstate.top.stk, pop.stk, keep result} <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> result, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#">Discard*</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next( <span class="block">stk <br>, <a href="#nextState:state:state">nextState</a>.state <br>, i <br>, inputi <br>, result.top <br>, i <br>, result.top</span>)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#All:state">All</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> att = <span class="block">[ <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(myinput, i.top, i <a href="#">-</a> 1))],</span> next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> att, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Lambda:state">Lambda</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)], <br>next( <span class="block">stk <br>, <a href="#nextState2:state:state">nextState2</a>.state <br>, i <br>, inputi <br>, result <a href="#">+</a> att <br>, faili <br>, failresult</span>)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Reduce:state">Reduce</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)], <br>next( <a href="#">pop</a>.stk, Sstate.top, i, inputi, result.top <a href="#">+</a> att, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#Reduce*:state">Reduce*</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> att = [ <a href="#action:int:seq.seq.byte:boolean:seq.byte">action</a>( <a href="#reduceNo:state:int">reduceNo</a>.state, result, textOut)] <br> <span class="keyword">let</span> top = <a href="#">top</a>.stk, <br>next(stk, <a href="#nextState:state:state">nextState</a>.state, i, inputi, att, i, att)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!Reduce:state">!Reduce</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> ini = idxNB(myinput, faili.top), <br>next( <a href="#">pop</a>.stk, Fstate.top, faili.top, ini, failresult.top, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!Fail:state">!Fail</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> top = <a href="#">top</a>.stk <br> <span class="keyword">let</span> ini = idxNB(myinput, i.top), <br>next( <a href="#">pop</a>.stk, Sstate.top, i.top, ini, result.top, faili.top, failresult.top)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#">T</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi ≠ match.te <span class="keyword">then</span>{fail}next(stk, Fstate.te, faili, idxNB(myinput, faili), failresult, faili, failresult) <br> <span class="keyword">else</span> next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), result, faili, failresult)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#!T:state">!T</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> match.te <span class="keyword">then</span>{fail}next(stk, Sstate.te, faili, idxNB(myinput, faili), failresult, faili, failresult) <br> <span class="keyword">else</span> next(stk, Fstate.te, i, inputi, result, faili, failresult)</span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#MatchAny:state">MatchAny</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> <a href="#endMark:word">endMark</a> <span class="keyword">then</span>{fail}next(stk, Fstate.te, i, inputi, result, faili, failresult) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> reslt = <span class="block">result <a href="#">+</a> <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, [inputi])</span> <span class="keyword">let</span> ini = idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), <br>next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, ini, reslt, faili, failresult)</span></span> <span class="keyword">else</span> if actionState <a href="#=:state:state:boolean">=</a> <a href="#T':state">T'</a> <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state), <br> <span class="keyword">if</span> inputi <a href="#=:word:word:boolean">=</a> match.te <span class="keyword">then</span> next(stk, Sstate.te, i <a href="#+:int:int:int">+</a> 1, idxNB(myinput, i <a href="#+:int:int:int">+</a> 1), result, faili, failresult) <br> <span class="keyword">else</span> next(stk, Fstate.te, i, inputi, result, faili, failresult)</span> <span class="keyword">else</span> <span class="block">{match non Terminal} <br> <span class="keyword">let</span> te = idxNB(packedTable, <a href="#index:state:int">index</a>.state) <br> <span class="keyword">assert</span> <a href="#action:state:state">action</a>.action.te <a href="#">∈</a> [ <a href="#">NT</a>, <a href="#">NT*</a>] <span class="keyword">report</span> <span class="literal">"PROBLEM PEG:(state)"</span> <br> <span class="keyword">let</span> newstk = push(stk, frame(Sstate.te, Fstate.te, i, result, faili, failresult)), <br> <span class="keyword">let</span> tmp = <span class="block">[ <a href="#toAttribute:seq.byte:seq.word:seq.byte">toAttribute</a>(result <a href="#sub:seq.T:int:T">sub</a> n.result, empty:seq.word)],</span> next(newstk, <a href="#nextState:state:state">nextState</a>.action.te, i, inputi, tmp, i, tmp),</span></span> thisresult.push(stk, frame(state, state, i, result, n.myinput, result)) <p> <span class="keyword" id="graph">Module</span> graph.T <p>use standard <p>use set.&lt;&lt;.T <p>use set.T <p>use seq.barc.T <p>use set.barc.T <p> <span class="keyword">unbound</span> tail(T) &lt;&lt;.T <p> <span class="keyword">unbound</span> head(T) &lt;&lt;.T <p> <span class="keyword">unbound</span> toarc(&lt;&lt;.T) T <p> <span class="keyword">unbound</span> >1(&lt;&lt;.T, &lt;&lt;.T) ordering <p> <span class="keyword">Export</span> head(T) &lt;&lt;.T <p> <a id=">1:T:T:ordering" href="#graph">Function</a> >1(a:T, b:T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <br> <a href="#∧:ordering:ordering:ordering">∧</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.b <p> <a id=">2:T:T:ordering" href="#graph">Function</a> >2(a:T, b:T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <p>type &lt;&lt; is dummy:T <p>type barc is arc:T <p> <a id="head:barc.T:&lt;&lt;.T" href="#graph">Function</a> head(b:barc.T) &lt;&lt;.T <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.arc.b <p> <a id="tail:barc.T:&lt;&lt;.T" href="#graph">Function</a> tail(b:barc.T) &lt;&lt;.T <a href="#head:barc.T:&lt;&lt;.T">head</a>.arc.b <p> <a id=">1:barc.T:barc.T:ordering" href="#graph">Function</a> >1(a:barc.T, b:barc.T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <br> <a href="#∧:ordering:ordering:ordering">∧</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.b <p> <a id=">2:barc.T:barc.T:ordering" href="#graph">Function</a> >2(a:barc.T, b:barc.T) ordering <br> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#>1:T:T:ordering">>1</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.b <p> <a id="tobarc:seq.T:seq.barc.T" href="#graph">Function</a> tobarc(s:seq.T) seq.barc.T <br> <span class="keyword">for</span> acc = empty:seq.barc.T, e ∈ s <span class="keyword">do</span> acc <a href="#">+</a> barc.e, <br>acc <p> <a id="toarcs:seq.barc.T:seq.T" href="#graph">Function</a> toarcs(s:seq.barc.T) seq.T <br> <span class="keyword">for</span> acc = empty:seq.T, e ∈ s <span class="keyword">do</span> acc <a href="#">+</a> arc.e, <br>acc <p>type graph is arcs:set.T, backarcs:set.barc.T, nodes:set.&lt;&lt;.T <p> <span class="keyword">Export</span> nodes(graph.T) set.&lt;&lt;.T <p> <span class="keyword">Export</span> arcs(graph.T) set.T <p> <span class="keyword">Export</span> type:graph.T <p>/Export type:barc.T <p>/Export type:&lt;&lt;.T <p> <a id="newgraph:seq.T:graph.T" href="#graph">Function</a> newgraph(arcs:seq.T) graph.T <br> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>, e ∈ arcs <br> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.e <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e, <br>graph( <span class="block"> <a href="#asset:seq.T:set.T">asset</a>.arcs <br>, <a href="#asset:seq.T:set.T">asset</a>. <a href="#tobarc:seq.T:seq.barc.T">tobarc</a>.arcs <br>, acc</span>) <p> <a id="arcstosuccessors:graph.T:&lt;&lt;.T:set.T" href="#graph">Function</a> arcstosuccessors(g:graph.T, n:&lt;&lt;.T) set.T <br> <a href="#findelement2:set.T:T:set.T">findelement2</a>(arcs.g, <a href="#toarc:T:arc.T">toarc</a>.n) <p> <a id="successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> successors(g:graph.T, n:&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">for</span> <span class="block">acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a> <br>, @e ∈ toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(arcs.g, <a href="#toarc:T:arc.T">toarc</a>.n)</span> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.@e, <br>acc <p> <a id="arcstopredecessors:graph.T:&lt;&lt;.T:seq.T" href="#graph">Function</a> arcstopredecessors(g:graph.T, n:&lt;&lt;.T) seq.T <br> <a href="#toarcs:seq.barc.T:seq.T">toarcs</a>.toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(backarcs.g, barc. <a href="#toarc:T:arc.T">toarc</a>.n) <p> <a id="predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> predecessors(g:graph.T, n:&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">for</span> <span class="block">acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a> <br>, e ∈ toseq. <a href="#findelement2:set.T:T:set.T">findelement2</a>(backarcs.g, barc. <a href="#toarc:T:arc.T">toarc</a>.n)</span> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e, <br>acc <p> <a id="replacearcs:graph.T:set.T:set.T:graph.T" href="#graph">Function</a> replacearcs(g:graph.T, oldarcs:set.T, newarcs:set.T) graph.T <br> <a href="#deletearcs:graph.T:set.T:graph.T">deletearcs</a>(g, oldarcs <a href="#\:set.T:set.T:set.T">\</a> newarcs) <br> <a href="#">+</a> toseq(newarcs <a href="#\:set.T:set.T:set.T">\</a> oldarcs) <p> <a id="deletearc:graph.T:T:graph.T" href="#graph">Function</a> deletearc(g:graph.T, a:T) graph.T <br>graph(arcs.g <a href="#-:set.T:T:set.T">-</a> a, backarcs.g <a href="#-:set.T:T:set.T">-</a> barc.a, nodes.g) <p> <a id="deletearcs:graph.T:set.T:graph.T" href="#graph">Function</a> deletearcs(g:graph.T, a:set.T) graph.T <br> <span class="keyword">for</span> acc = g, e ∈ toseq.a <span class="keyword">do</span> <a href="#deletearc:graph.T:T:graph.T">deletearc</a>(acc, e), <br>acc <p> <a id="+:graph.T:seq.&lt;&lt;.T:graph.T" href="#graph">Function</a> +(g:graph.T, nodes:seq.&lt;&lt;.T) graph.T <br>graph(arcs.g, backarcs.g, <a href="#asset:seq.T:set.T">asset</a>.nodes <a href="#">∪</a> nodes.g) <p> <a id="+:graph.T:T:graph.T" href="#graph">Function</a> +(g:graph.T, a:T) graph.T <br>graph( <span class="block">arcs.g <a href="#+:set.T:T:set.T">+</a> a <br>, backarcs.g <a href="#+:set.T:T:set.T">+</a> barc.a <br>, nodes.g <a href="#+:set.T:T:set.T">+</a> <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.a <a href="#+:set.T:T:set.T">+</a> <a href="#head:barc.T:&lt;&lt;.T">head</a>.a</span>) <p> <a id="+:graph.T:seq.T:graph.T" href="#graph">Function</a> +(g:graph.T, a:seq.T) graph.T <br> <span class="keyword">for</span> acc = g, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> @e, <br>acc <p> <a id="deletenode:graph.T:&lt;&lt;.T:graph.T" href="#graph">Function</a> deletenode(g:graph.T, n:&lt;&lt;.T) graph.T <br> <a href="#deletearcs:graph.T:set.T:graph.T">deletearcs</a>( <span class="block">graph(arcs.g, backarcs.g, nodes.g <a href="#-:set.T:T:set.T">-</a> n) <br>, <a href="#arcstosuccessors:graph.T:&lt;&lt;.T:set.T">arcstosuccessors</a>(g, n) <br> <a href="#">∪</a> <a href="#asset:seq.T:set.T">asset</a>. <a href="#arcstopredecessors:graph.T:&lt;&lt;.T:seq.T">arcstopredecessors</a>(g, n)</span>) <p> <a id="sinks:graph.T:set.&lt;&lt;.T:seq.&lt;&lt;.T" href="#graph">Function</a> sinks(g:graph.T, b:set.&lt;&lt;.T) seq.&lt;&lt;.T <br> <span class="comment">{returns list of sinks in graph with arcs to nodes in set b removed}</span> <br> <span class="keyword">for</span> acc = empty:seq.&lt;&lt;.T, n ∈ toseq(nodes.g <a href="#\:set.T:set.T:set.T">\</a> b) <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>( <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, n) <a href="#\:set.T:set.T:set.T">\</a> b) <br> <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> acc <a href="#">+</a> n <br> <span class="keyword">else</span> acc,</span> acc <p> <a id="sources:graph.T:set.&lt;&lt;.T:seq.&lt;&lt;.T" href="#graph">Function</a> sources(g:graph.T, b:set.&lt;&lt;.T) seq.&lt;&lt;.T <br> <span class="comment">{returns list of sources in graph with arcs to nodes in set b removed}</span> <br> <span class="keyword">for</span> acc = empty:seq.&lt;&lt;.T, n ∈ toseq(nodes.g <a href="#\:set.T:set.T:set.T">\</a> b) <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>( <a href="#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">predecessors</a>(g, n) <a href="#\:set.T:set.T:set.T">\</a> b) <br> <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> acc <a href="#">+</a> n <br> <span class="keyword">else</span> acc,</span> acc <p> <a id="sources:graph.T:seq.&lt;&lt;.T" href="#graph">Function</a> sources(g:graph.T) seq.&lt;&lt;.T <br> <a href="#">sources</a>(g, <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>) <p> <a id="sinks:graph.T:seq.&lt;&lt;.T" href="#graph">Function</a> sinks(g:graph.T) seq.&lt;&lt;.T <br> <a href="#">sinks</a>(g, <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>) <p> <a id="subgraph:graph.T:set.&lt;&lt;.T:graph.T" href="#graph">Function</a> subgraph(g:graph.T, nodes:set.&lt;&lt;.T) graph.T <br> <span class="keyword">for</span> <span class="block">acc = graph( <span class="block"> <a href="#empty::set.T:set.T">empty:set.T</a> <br>, <a href="#empty::set.T:set.T">empty:set.barc.T</a> <br>, nodes</span>) <br>, e ∈ toseq.arcs.g</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> <a href="#head:barc.T:&lt;&lt;.T">head</a>.e ∉ nodes <span class="keyword">then</span> acc <br> <span class="keyword">else</span> if <a href="#tail:barc.T:&lt;&lt;.T">tail</a>.e ∉ nodes <span class="keyword">then</span> acc <br> <span class="keyword">else</span> acc <a href="#">+</a> e,</span> acc <p> <a id="reachable:graph.T:seq.&lt;&lt;.T:set.&lt;&lt;.T" href="#graph">Function</a> reachable(g:graph.T, a:seq.&lt;&lt;.T) set.&lt;&lt;.T <br> <span class="keyword">let</span> d = <a href="#asset:seq.T:set.T">asset</a>.a, <br> <a href="#">reachable</a>(g, d, d, 1) <p> <a id="reachable:graph.T:set.&lt;&lt;.T:set.&lt;&lt;.T:int:set.&lt;&lt;.T" href="#graph">function</a> reachable(g:graph.T, old:set.&lt;&lt;.T, new:set.&lt;&lt;.T, count:int) set.&lt;&lt;.T <br> <span class="keyword">assert</span> count <a href="#&lt;:int:int:boolean">&lt;</a> 1000 <span class="keyword">report</span> <span class="block"> <span class="literal">"fal"</span> <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>. <a href="#n:set.T:int">n</a>.old <br> <a href="#">+</a> <a href="#toword:int:word">toword</a>. <a href="#n:set.T:int">n</a>.new,</span> <span class="keyword">if</span> <a href="#isempty:set.T:boolean">isempty</a>.new <span class="keyword">then</span> old <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.&lt;&lt;.T</a>, e ∈ toseq.new <br> <span class="keyword">do</span> acc <a href="#">∪</a> <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, e) <br> <span class="keyword">let</span> b = old <a href="#">∪</a> new, <br> <a href="#">reachable</a>(g, b, acc <a href="#\:set.T:set.T:set.T">\</a> b, count <a href="#+:int:int:int">+</a> 1)</span> <p> <a id="complement:graph.T:graph.T" href="#graph">Function</a> complement(g:graph.T) graph.T <br> <span class="keyword">for</span> acc = <a href="#empty::set.T:set.T">empty:set.T</a>, a ∈ toseq.arcs.g <br> <span class="keyword">do</span> acc <a href="#+:set.T:T:set.T">+</a> <a href="#">reverse</a>.a, <br>graph( <span class="block">acc <br>, <a href="#asset:seq.T:set.T">asset</a>. <a href="#tobarc:seq.T:seq.barc.T">tobarc</a>.toseq.acc <br>, nodes.g</span>) <p> <span class="keyword">unbound</span> reverse(T) T <p>------------------------------- <p> <a id="outdegree:graph.T:&lt;&lt;.T:int" href="#graph">Function</a> outdegree(g:graph.T, n:&lt;&lt;.T) int <a href="#n:set.T:int">n</a>. <a href="#successors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">successors</a>(g, n) <p> <a id="indegree:graph.T:&lt;&lt;.T:int" href="#graph">Function</a> indegree(g:graph.T, n:&lt;&lt;.T) int <a href="#n:set.T:int">n</a>. <a href="#predecessors:graph.T:&lt;&lt;.T:set.&lt;&lt;.T">predecessors</a>(g, n) <p> <a id="=:graph.T:graph.T:boolean" href="#graph">Function</a> =(a:graph.T, b:graph.T) boolean <br> <a href="#n:set.T:int">n</a>.arcs.a <a href="#=:int:int:boolean">=</a> <a href="#n:set.T:int">n</a>.arcs.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> nodes.a <a href="#=:set.T:set.T:boolean">=</a> nodes.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> arcs.a <a href="#=:set.T:set.T:boolean">=</a> arcs.b <p> <a id="transitiveClosure:graph.T:graph.T" href="#graph">Function</a> transitiveClosure(gin:graph.T) graph.T <br> <span class="comment">{add arcs to graph so if node is reachable, it can be reached with single arc}</span> <br> <span class="keyword">for</span> g = gin, n ∈ toseq.nodes.gin <br> <span class="keyword">do</span> <span class="block">{add arcs to graph so path does not need to go through n} <br> <span class="keyword">for</span> <span class="block">arcs = empty:seq.T <br>, p ∈ <a href="#arcstopredecessors:graph.T:&lt;&lt;.T:seq.T">arcstopredecessors</a>(g, n)</span> <span class="keyword">do</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc2 = empty:seq.T <br>, s ∈ toseq. <a href="#arcstosuccessors:graph.T:&lt;&lt;.T:set.T">arcstosuccessors</a>(g, n)</span> <span class="keyword">do</span> acc2 <a href="#">+</a> <a href="#">merge</a>(p, s), <br>arcs <a href="#">+</a> acc2,</span> g <a href="#">+</a> arcs,</span> g <p> <span class="keyword">unbound</span> merge(T, T) T <p> <span class="keyword" id="arc">Module</span> arc.T <p>use standard <p>use seq.seq.word <p>use set.T <p> <span class="keyword">Export</span> type:arc.T <p> <span class="keyword">Export</span> head(arc.T) T <p> <span class="keyword">Export</span> tail(arc.T) T <p> <span class="keyword">Export</span> arc(T, T) arc.T <p>type arc is tail:T, head:T <p> <a id="toarc:T:arc.T" href="#arc">Function</a> toarc(n:T) arc.T arc(n, n) <p> <a id="reverse:arc.T:arc.T" href="#arc">Function</a> reverse(a:arc.T) arc.T arc(head.a, tail.a) <p> <a id="merge:arc.T:arc.T:arc.T" href="#arc">Function</a> merge(p:arc.T, s:arc.T) arc.T arc(tail.p, head.s) <p> <a id="arcLabel:set.arc.T:T:T:seq.seq.word" href="#arc">Function</a> arcLabel(set.arc.T, T, T) seq.seq.word empty:seq.seq.word <p> <span class="keyword" id="process">Module</span> process.T <p>use seq.T <p>use UTF8 <p>use bits <p>use seq1.byte <p>use standard <p>use toWords <p> <span class="keyword">Export</span> type:process.T <p> <span class="keyword">Export</span> body2(process.T) T <p> <span class="keyword">Export</span> header(a:process.T) UTF8 <p>type process is abortedx:boolean, msg:seq.word, header:UTF8, body1:seq.T, body2:T <p> <span class="keyword">Builtin</span> aborted(process.T) boolean <p> <a id="message:process.T:seq.word" href="#process">Function</a> message(p:process.T) seq.word <br> <span class="keyword">if</span> aborted.p <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.msg.p <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> h = toseqbyte.header.p, <br> <a href="#towords:UTF8:seq.word">towords</a>.UTF8. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(h, 1, <a href="#findindex:seq.T:T:int">findindex</a>(h, <a href="#tobyte:int:byte">tobyte</a>.10))</span> <span class="keyword">else</span> msg.p</span> <span class="keyword">else</span> <span class="literal">"normal exit"</span> <p> <a id="result:process.T:T" href="#process">Function</a> result(p:process.T) T <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>.aborted.p <span class="keyword">report</span> <span class="literal">"no result of aborted process"</span>, <br>(body1.p) <a href="#sub:seq.T:int:T">sub</a> 1 <p> <span class="keyword" id="real">Module</span> real <p>use UTF8 <p>use bits <p>use seq1.byte <p>use seq1.char <p>use kernal <p>use standard <p> <a id="-:real:real" href="#real">Function</a> -(r:real) real 0.00 <a href="#">-</a> r <p> <a id="abs:real:real" href="#real">Function</a> abs(x:real) real <span class="keyword">if</span> x <a href="#&lt;:real:real:boolean">&lt;</a> 0.0 <span class="keyword">then</span> 0.0 <a href="#">-</a> x <span class="keyword">else</span> x <span class="keyword">Builtin</span> <p>toreal <span class="keyword">Builtin</span> <p>intpart <p> <a id="decpart:real:real" href="#real">Function</a> decpart(a:real) real a <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.a <span class="keyword">Builtin</span> <p>sin <span class="keyword">Builtin</span> <p>cos <span class="keyword">Builtin</span> <p>sqrt <span class="keyword">Builtin</span> <p>tan <span class="keyword">Builtin</span> <p>arccos <span class="keyword">Builtin</span> <p>arcsin <p> <a id="pi:real" href="#real">Function</a> pi real 3.1415926535898 <p> <a id="NaN:real" href="#real">Function</a> NaN real <br> <a href="#casttoreal:int:real">casttoreal</a>. <a href="#toint:word:int">toint</a>. <span class="literal">"0x7FF8000000000000"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">Builtin</span> <p>>1 <p> <a id="=:real:real:boolean" href="#real">Function</a> =(a:real, b:real) boolean a <a href="#>1:T:T:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <p> <a id=">:real:real:boolean" href="#real">Function</a> >(a:real, b:real) boolean a <a href="#>1:T:T:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <p> <a id="&lt;:real:real:boolean" href="#real">Function</a> &lt;(a:real, b:real) boolean b <a href="#>:real:real:boolean">></a> a <p> <a id="max:real:real:real" href="#real">Function</a> max(a:real, b:real) real <br> <span class="keyword">if</span> a <a href="#>1:T:T:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <span class="keyword">else</span> b <p> <a id="min:real:real:real" href="#real">Function</a> min(a:real, b:real) real <br> <span class="keyword">if</span> a <a href="#>1:T:T:ordering">>1</a> b <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span> a <span class="keyword">else</span> b <span class="keyword">Builtin</span> <p>+ <span class="keyword">Builtin</span> <p>- <span class="keyword">Builtin</span> <p>* <span class="keyword">Builtin</span> <p>/ <span class="keyword">Builtin</span> <p>representation <span class="keyword">Builtin</span> <p>casttoreal <p> <a id="sup:real:int:real" href="#real">Function</a> sup(a:real, n:int) real <br> <span class="keyword">if</span> n <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> 1.0 <br> <span class="keyword">else</span> if n <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if n <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> 1.0 <a href="#/:real:real:real">/</a> a <a href="#sup:real:int:real">sup</a> -n <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> d = n <a href="#/:int:int:int">/</a> 2, <br>a <a href="#sup:real:int:real">sup</a> d <a href="#">*</a> a <a href="#sup:real:int:real">sup</a> (n <a href="#">-</a> d)</span> <p> <a id="*:int:real:real" href="#real">Function</a> *(a:int, b:real) real <a href="#toreal:int:real">toreal</a>.a <a href="#">*</a> b <p> <a id="makereal:seq.word:real" href="#real">Function</a> makereal(w:seq.word) real <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <span class="block"> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ w <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.@e, <br>acc <br>, -1 <br>, 1 <br>, 0 <br>, 1</span>) <p> <a id="isNaN:real:boolean" href="#real">function</a> isNaN(r:real) boolean <br> <a href="#representation:real:int">representation</a>.r <br> <a href="#=:int:int:boolean">=</a> <a href="#representation:real:int">representation</a>. <a href="#NaN:real">NaN</a> <p> <a id="%:int:real:seq.word" href="#real">Function</a> %(decimalPlaces:int, rin1:real) seq.word <br> <span class="comment">{converts rin1 to text form with specified number no decimal places.}</span> <br> <span class="keyword">if</span> <a href="#representation:real:int">representation</a>.rin1 <br> <a href="#=:int:int:boolean">=</a> <a href="#representation:real:int">representation</a>. <a href="#NaN:real">NaN</a> <span class="keyword">then</span> <span class="literal">"NaN"</span> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> neg = rin1 <a href="#>1:T:T:ordering">>1</a> <a href="#toreal:int:real">toreal</a>.0 <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">let</span> rin = <span class="keyword">if</span> neg <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.0 <a href="#">-</a> rin1 <span class="keyword">else</span> rin1 <br> <span class="keyword">let</span> a = 10 <a href="#sup:int:int:int">sup</a> decimalPlaces <br> <span class="keyword">let</span> r = rin <a href="#+:real:real:real">+</a> 1.0 <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>(a <a href="#*:int:int:int">*</a> 2), <br> <span class="keyword">let</span> r2 = <span class="block"> <span class="keyword">if</span> decimalPlaces <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block">[ <span class="block"> <a href="#toword:int:word">toword</a>. <a href="#">intpart</a>.r <br>, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, <a href="#encodeword:seq.char:word">encodeword</a>. <a href="#lpad:int:T:seq.T:seq.T">lpad</a>( <span class="block">decimalPlaces <br>, char.48 <br>, <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>. <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>( <span class="block">(r <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.r) <br> <a href="#">*</a> <a href="#toreal:int:real">toreal</a>.a</span>)</span>)</span>]</span> <span class="keyword">else</span> [ <a href="#toword:int:word">toword</a>. <a href="#">intpart</a>.r],</span> <span class="keyword">if</span> neg <span class="keyword">then</span> <span class="literal">"-:(r2)"</span> <span class="keyword">else</span> r2</span> <p> <a id="toUTF8:real:int:UTF8" href="#real">Function</a> toUTF8(rin1:real, decimals:int) UTF8 <br> <span class="keyword">let</span> neg = rin1 <a href="#>1:T:T:ordering">>1</a> <a href="#toreal:int:real">toreal</a>.0 <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">let</span> rin = <span class="keyword">if</span> neg <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.0 <a href="#">-</a> rin1 <span class="keyword">else</span> rin1 <br> <span class="keyword">let</span> a = 10 <a href="#sup:int:int:int">sup</a> decimals <br> <span class="keyword">let</span> r = rin <a href="#+:real:real:real">+</a> 1.0 <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>(a <a href="#*:int:int:int">*</a> 2) <br> <span class="keyword">let</span> r2 = <span class="block"> <span class="keyword">if</span> decimals <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>.r <br> <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>. <a href="#periodchar:char">periodchar</a> <br> <a href="#+:UTF8:UTF8:UTF8">+</a> UTF8. <a href="#lpad:int:T:seq.T:seq.T">lpad</a>( <span class="block">decimals <br>, <a href="#tobyte:int:byte">tobyte</a>.48 <br>, toseqbyte. <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>( <span class="block">(r <a href="#">-</a> <a href="#toreal:int:real">toreal</a>. <a href="#">intpart</a>.r) <br> <a href="#">*</a> <a href="#toreal:int:real">toreal</a>.a</span>)</span>)</span> <span class="keyword">else</span> <a href="#toUTF8:int:UTF8">toUTF8</a>. <a href="#">intpart</a>.r,</span> <span class="keyword">if</span> neg <a href="#∧:boolean:boolean:boolean">∧</a> rin1 ≠ 0.0 <span class="keyword">then</span> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>. <a href="#hyphenchar:char">hyphenchar</a> <a href="#+:UTF8:UTF8:UTF8">+</a> r2 <br> <span class="keyword">else</span> r2 <p> <a id="reallit:UTF8:real" href="#real">Function</a> reallit(s:UTF8) real <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>.s, -1, 1, 0, 1) <p> <a id="reallit:seq.char:int:int:int:int:real" href="#real">function</a> reallit(s:seq.char, decimals:int, i:int, val:int, neg:int) real <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> r = <span class="block"> <span class="keyword">if</span> decimals <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> <a href="#toreal:int:real">toreal</a>.val <br> <span class="keyword">else</span> <a href="#toreal:int:real">toreal</a>.val <a href="#/:real:real:real">/</a> <a href="#toreal:int:real">toreal</a>.decimals,</span> <span class="keyword">if</span> neg <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> -1.0 <a href="#">*</a> r <span class="keyword">else</span> r</span> <span class="keyword">else</span> if <a href="#between:int:int:int:boolean">between</a>(toint.s <a href="#sub:seq.T:int:T">sub</a> i, 48, 57) <span class="keyword">then</span> <span class="block"> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>( <span class="block">s <br>, <span class="keyword">if</span> decimals <a href="#=:int:int:boolean">=</a> -1 <span class="keyword">then</span> -1 <span class="keyword">else</span> decimals <a href="#*:int:int:int">*</a> 10 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, 10 <a href="#*:int:int:int">*</a> val <a href="#+:int:int:int">+</a> toint.s <a href="#sub:seq.T:int:T">sub</a> i <a href="#">-</a> 48 <br>, neg</span>)</span> <span class="keyword">else</span> if s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> char.32 <br> <a href="#∨:boolean:boolean:boolean">∨</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#commachar:char">commachar</a> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, neg) <br> <span class="keyword">else</span> if i <a href="#&lt;:int:int:boolean">&lt;</a> 3 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#hyphenchar:char">hyphenchar</a> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, -1) <br> <span class="keyword">else</span> if i <a href="#&lt;:int:int:boolean">&lt;</a> 3 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"+"</span> <span class="keyword">then</span> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, decimals, i <a href="#+:int:int:int">+</a> 1, val, 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> s <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:char:char:boolean">=</a> <a href="#periodchar:char">periodchar</a> <span class="keyword">report</span> <span class="literal">"unexpected character in real literal"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s, <br> <a href="#reallit:seq.char:int:int:int:int:real">reallit</a>(s, 1, i <a href="#+:int:int:int">+</a> 1, val, neg)</span> <p> <span class="keyword" id="seq">Module</span> seq.T <p>use kernal <p> <span class="keyword">Export</span> type:pseq.T <p> <span class="keyword">Export</span> a(pseq.T) seq.T <p> <span class="keyword">Export</span> b(pseq.T) seq.T <p> <span class="keyword">Export</span> start(a:pseq.T) int <p> <span class="keyword">Export</span> type:seq.T <p> <span class="keyword">Export</span> to:pseq.T(s:seq.T) pseq.T <p> <span class="keyword">Export</span> getseqtype(a:seq.T) int <p> <span class="keyword">unbound</span> =(T, T) boolean <p>type seq is sequence, x:T <p> <span class="keyword">Builtin</span> packed(s:seq.T) seq.T <p> <span class="keyword">Builtin</span> empty:seq.T seq.T{empty seq} <p> <span class="keyword">Builtin</span> idxNB(a:seq.T, i:int) T <p> <a id="pseq2seq:pseq.T:seq.T" href="#seq">Function</a> pseq2seq(a:pseq.T) seq.T toseq.a <p> <a id="=:seq.T:seq.T:boolean" href="#seq">Function</a> =(a:seq.T, b:seq.T) boolean <br> <span class="comment">{OPTION COMPILETIME}</span> <br> <span class="keyword">for</span> isequal = n.a <a href="#=:int:int:boolean">=</a> n.b, i = 1, e ∈ a <br> <span class="keyword">while</span> isequal <br> <span class="keyword">do</span> next(e <a href="#">=</a> b <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#+:int:int:int">+</a> 1), <br>isequal <p> <a id="∈:T:seq.T:boolean" href="#seq">Function</a> ∈(a:T, s:seq.T) boolean <br> <span class="keyword">for</span> found = false, e ∈ s <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <span class="keyword">do</span> a <a href="#">=</a> e, <br>found <p> <a id="lookup:seq.T:T:seq.T" href="#seq">Function</a> lookup(s:seq.T, a:T) seq.T <br> <span class="keyword">for</span> found = empty:seq.T, e ∈ s <br> <span class="keyword">while</span> <a href="#isempty:seq.T:boolean">isempty</a>.found <br> <span class="keyword">do</span> <span class="keyword">if</span> a <a href="#">=</a> e <span class="keyword">then</span> found <a href="#">+</a> e <span class="keyword">else</span> found, <br>found <p>type pseq is sequence, a:seq.T, b:seq.T, start:int <p> <a id="seqseg:seq.T:int:pseq.T" href="#seq">Function</a> seqseg(sin:seq.T, ii:int) pseq.T <br> <span class="keyword">let</span> s = <a href="#T:state">to:pseq.T</a>(sin), <br> <span class="keyword">if</span> n.toseq.s <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> pseq(n.sin <a href="#+:int:int:int">+</a> 1, sin, empty:seq.T, ii <a href="#">-</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = ii <a href="#+:int:int:int">+</a> start.s <br> <span class="keyword">let</span> len = n.a.s, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> len <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> x = <a href="#T:state">to:pseq.T</a>(b.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block">pseq( <span class="block">n.b.s <a href="#">-</a> i <a href="#+:int:int:int">+</a> len <a href="#+:int:int:int">+</a> 1 <br>, b.s <br>, empty:seq.T <br>, i <a href="#">-</a> len <a href="#">-</a> 1</span>)</span> <span class="keyword">else</span> <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(b.s, i <a href="#">-</a> len)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> x = <a href="#T:state">to:pseq.T</a>(a.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> pseq(n.a.s <a href="#">-</a> i <a href="#+:int:int:int">+</a> 1, a.s, empty:seq.T, i <a href="#">-</a> 1) <br> <span class="keyword">else</span> <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(a.s, i)</span></span> <p> <a id="sequenceIndex:pseq.T:int:T" href="#seq">function</a> sequenceIndex(s:pseq.T, ii:int) T <br> <span class="keyword">let</span> i = ii <a href="#+:int:int:int">+</a> start.s <br> <span class="keyword">let</span> len = n.a.s, <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> len <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> x = <a href="#T:state">to:pseq.T</a>(b.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> idxNB(b.s, i <a href="#">-</a> len) <span class="keyword">else</span> <a href="#sequenceIndex:pseq.T:int:T">sequenceIndex</a>(x, i <a href="#">-</a> len)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> x = <a href="#T:state">to:pseq.T</a>(a.s), <br> <span class="keyword">if</span> n.toseq.x <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> idxNB(a.s, i) <span class="keyword">else</span> <a href="#sequenceIndex:pseq.T:int:T">sequenceIndex</a>(x, i)</span> <p> <a id="ispseq:seq.T:boolean" href="#seq">Function</a> ispseq(s:seq.T) boolean n.toseq. <a href="#T:state">to:pseq.T</a>(s) ≠ 0 <p> <a id="+:seq.T:seq.T:seq.T" href="#seq">Function</a> +(a:seq.T, b:seq.T) seq.T <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> la = n.a, <br> <span class="keyword">if</span> n.a <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> lb = n.b, <br> <span class="keyword">if</span> lb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <span class="keyword">else</span> <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(a, b)</span> <p> <a id="+:seq.T:T:seq.T" href="#seq">Function</a> +(l:seq.T, a:T) seq.T l <a href="#">+</a> [a] <p> <a id="cat3:int:seq.T:seq.T:seq.T:seq.T" href="#seq">function</a> cat3(totallength:int, a:seq.T, b:seq.T, c:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> toseq.pseq(totallength, a, <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(b, c), 0) <br> <span class="keyword">else</span> if n.b <a href="#&lt;:int:int:boolean">&lt;</a> n.c <span class="keyword">then</span> toseq.pseq(totallength, <a href="#catnonzero:seq.T:seq.T:seq.T">catnonzero</a>(a, b), c, 0) <br> <span class="keyword">else</span> <span class="block">toseq.pseq(totallength, toseq.pseq(n.a <a href="#+:int:int:int">+</a> n.b, a, b, 0), c, 0)</span> <p> <a id="catnonzero:seq.T:seq.T:seq.T" href="#seq">function</a> catnonzero(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> totallength = n.a <a href="#+:int:int:int">+</a> n.b, <br> <span class="keyword">if</span> totallength <a href="#=:int:int:boolean">=</a> 2 <span class="keyword">then</span> [idxNB(a, 1), idxNB(b, 1)] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ta = <a href="#T:state">to:pseq.T</a>(a), <br> <span class="keyword">if</span> n.toseq.ta <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> tb = <a href="#T:state">to:pseq.T</a>(b), <br> <span class="keyword">if</span> n.toseq.tb <a href="#=:int:int:boolean">=</a> 0 <br> <a href="#∨:boolean:boolean:boolean">∨</a> n.a.tb <a href="#+:int:int:int">+</a> n.b.tb ≠ n.toseq.tb <span class="keyword">then</span> toseq.pseq(totallength, a, b, 0) <br> <span class="keyword">else</span> <a href="#cat3:int:seq.T:seq.T:seq.T:seq.T">cat3</a>(totallength, a, a.tb, b.tb)</span> <span class="keyword">else</span> if n.a.ta <a href="#+:int:int:int">+</a> n.b.ta ≠ n.toseq.ta <span class="keyword">then</span> toseq.pseq(totallength, a, b, 0) <br> <span class="keyword">else</span> <a href="#cat3:int:seq.T:seq.T:seq.T:seq.T">cat3</a>(totallength, a.ta, b.ta, b)</span> <p> <a id="subseq:seq.T:int:int:seq.T" href="#seq">Function</a> subseq(s:seq.T, start:int, finish:int) seq.T <br> <span class="keyword">if</span> start <a href="#>:int:int:boolean">></a> finish <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if start <a href="#&lt;:int:int:boolean">&lt;</a> 1 <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, finish) <br> <span class="keyword">else</span> if finish <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, start, n.s) <br> <span class="keyword">else</span> if start <a href="#=:int:int:boolean">=</a> 1 <a href="#∧:boolean:boolean:boolean">∧</a> n.s <a href="#=:int:int:boolean">=</a> finish <span class="keyword">then</span> s <br> <span class="keyword">else</span> if start <a href="#=:int:int:boolean">=</a> finish <a href="#+:int:int:int">+</a> 1 <span class="keyword">then</span> [s <a href="#sub:seq.T:int:T">sub</a> start, s <a href="#sub:seq.T:int:T">sub</a> finish] <br> <span class="keyword">else</span> if start <a href="#+:int:int:int">+</a> 1 ≥ finish <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> start <a href="#=:int:int:boolean">=</a> finish <span class="keyword">then</span> [s <a href="#sub:seq.T:int:T">sub</a> start] <br> <span class="keyword">else</span> [s <a href="#sub:seq.T:int:T">sub</a> start, s <a href="#sub:seq.T:int:T">sub</a> finish]</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = <a href="#T:state">to:pseq.T</a>(s), <br> <span class="keyword">if</span> n.toseq.p <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block">toseq.pseq(finish <a href="#">-</a> start <a href="#+:int:int:int">+</a> 1, s, s, start <a href="#">-</a> 1)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> adjstart = start <a href="#+:int:int:int">+</a> start.p <a href="#">-</a> n.a.p <br> <span class="keyword">let</span> adjfinish = start.p <a href="#+:int:int:int">+</a> finish <a href="#">-</a> n.a.p, <br> <span class="keyword">if</span> adjstart <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span>{all in part b} <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b.p, adjstart, adjfinish) <br> <span class="keyword">else</span> if adjfinish <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a.p, start.p <a href="#+:int:int:int">+</a> start, n.a.p) <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b.p, 1, adjfinish)</span> <span class="keyword">else</span> {all in part a} <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a.p, start.p <a href="#+:int:int:int">+</a> start, start.p <a href="#+:int:int:int">+</a> finish)</span></span> <p> <a id="isempty:seq.T:boolean" href="#seq">Function</a> isempty(a:seq.T) boolean n.a <a href="#=:int:int:boolean">=</a> 0 <p> <a id="&lt;&lt;:seq.T:int:seq.T" href="#seq">Function</a> &lt;&lt;(s:seq.T, i:int) seq.T <br> <span class="comment">{* removes i elements from beginning of s}</span> <br> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s) <p> <a id=">>:seq.T:int:seq.T" href="#seq">Function</a> >>(s:seq.T, i:int) seq.T <br> <span class="comment">{* removes i elements from end of s}</span> <br> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, n.s <a href="#">-</a> i) <p> <span class="keyword">Builtin</span> n(s:seq.T) int{length of string} <p> <a id="sub:seq.T:int:T" href="#seq">Function</a> sub(s:seq.T, i:int) T <br> <span class="comment">{Number elements in sequence from 1 to n.s and return the element numbered i}</span> <br> <span class="keyword">assert</span> i <a href="#>:int:int:boolean">></a> 0 <a href="#∧:boolean:boolean:boolean">∧</a> i ≤ n.s <br> <a href="#∨:boolean:boolean:boolean">∨</a> getseqtype.s <a href="#>:int:int:boolean">></a> 1 <span class="keyword">report</span> <a href="#T:state">outofbounds:T</a>, <br>idxNB(s, i) <p> <span class="keyword">builtin</span> outofbounds:T seq.word <p> <a id="last:seq.T:T" href="#seq">Function</a> last(s:seq.T) T <br> <span class="comment">{last element of sequence}</span> <br>s <a href="#sub:seq.T:int:T">sub</a> n.s <p> <span class="keyword" id="set">Module</span> set.T <p>use seq1.T <p>use standard <p>use sort.T <p> <span class="keyword">Export</span> type:set.T <p> <span class="keyword">Export</span> toseq(set.T) seq.T <p> <span class="keyword">Export</span> sub(seq.T, int) T <p> <span class="keyword">Export</span> +(seq.T, T) seq.T{From seq.T} <p> <span class="keyword">Export</span> +(seq.T, seq.T) seq.T{From seq.T} <p> <span class="keyword">Export</span> empty:seq.T seq.T{From seq.T} <p>type set is toseq:seq.T <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="asset:seq.T:set.T" href="#set">Function</a> asset(s:seq.T) set.T <br> <span class="keyword">for</span> acc = empty:seq.T, @e ∈ s <span class="keyword">do</span> <a href="#setinsert:seq.T:T:seq.T">setinsert</a>(acc, @e), <br>set.acc <p> <a id="empty::set.T:set.T" href="#set">Function</a> empty:set.T set.T set.empty:seq.T <p> <a id="+:set.T:T:set.T" href="#set">Function</a> +(s:set.T, val:T) set.T set. <a href="#setinsert:seq.T:T:seq.T">setinsert</a>(toseq.s, val) <p> <a id="replace:set.T:T:set.T" href="#set">Function</a> replace(s:set.T, val:T) set.T set. <a href="#setreplaceorinsert:seq.T:T:seq.T">setreplaceorinsert</a>(toseq.s, val) <p> <a id="∪:T:set.T:set.T" href="#set">Function</a> ∪(val:T, s:set.T) set.T set. <a href="#setreplaceorinsert:seq.T:T:seq.T">setreplaceorinsert</a>(toseq.s, val) <p> <a id="sub:set.T:int:T" href="#set">Function</a> sub(s:set.T, i:int) T (toseq.s) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="lookup:set.T:T:set.T" href="#set">Function</a> lookup(s:set.T, val:T) set.T <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(toseq.s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> set.[(toseq.s) <a href="#sub:seq.T:int:T">sub</a> i] <br> <span class="keyword">else</span> <a href="#empty::set.T:set.T">empty:set.T</a> <p> <a id="∩:set.T:set.T:set.T" href="#set">Function</a> ∩(a:set.T, b:set.T) set.T set. <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(toseq.a, toseq.b, 1, 1) <p> <a id="intersect:seq.T:seq.T:int:int:seq.T" href="#set">function</a> intersect(a:seq.T, b:seq.T, i:int, j:int) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span>[a <a href="#sub:seq.T:int:T">sub</a> i] <a href="#">+</a> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <a href="#intersect:seq.T:seq.T:int:int:seq.T">intersect</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j)</span> <p> <a id="union:set.T:set.T:set.T" href="#set">function</a> union(a:set.T, b:set.T) set.T <br> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <a href="#+:set.T:T:set.T">+</a> b <a href="#sub:set.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> set. <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="∪:set.T:set.T:set.T" href="#set">Function</a> ∪(a:set.T, b:set.T) set.T <br> <span class="keyword">if</span> <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if <a href="#n:set.T:int">n</a>.b <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> a <a href="#+:set.T:T:set.T">+</a> b <a href="#sub:set.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> set. <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="union:seq.T:seq.T:int:int:seq.T:seq.T" href="#set">function</a> union(a:seq.T, b:seq.T, i:int, j:int, result:seq.T) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, n.b) <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> b <a href="#sub:seq.T:int:T">sub</a> j) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> a <a href="#sub:seq.T:int:T">sub</a> i) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = <a href="#">binarysearch</a>(a, i <a href="#+:int:int:int">+</a> 1, n.a, b <a href="#sub:seq.T:int:T">sub</a> j), <br> <span class="keyword">if</span> p <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, p <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, p)) <br> <span class="keyword">else</span> <a href="#union:seq.T:seq.T:int:int:seq.T:seq.T">union</a>(a, b, -p, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, -p <a href="#">-</a> 1) <a href="#">+</a> [b <a href="#sub:seq.T:int:T">sub</a> j])</span> <p> <a id="\:set.T:set.T:set.T" href="#set">Function</a> \(a:set.T, b:set.T) set.T <br> <span class="comment">{elements in a but not in b}</span> <br>set. <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(toseq.a, toseq.b, 1, 1) <p> <a id="-:set.T:T:set.T" href="#set">Function</a> -(a:set.T, b:T) set.T set. <a href="#setdelete:seq.T:T:seq.T">setdelete</a>(toseq.a, b) <p> <a id="diff:seq.T:seq.T:int:int:seq.T" href="#set">function</a> diff(a:seq.T, b:seq.T, i:int, j:int) seq.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span>[a <a href="#sub:seq.T:int:T">sub</a> i] <a href="#">+</a> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j) <br> <span class="keyword">else</span> <a href="#diff:seq.T:seq.T:int:int:seq.T">diff</a>(a, b, i, j <a href="#+:int:int:int">+</a> 1) <p> <a id="replace:set.T:set.T:set.T" href="#set">Function</a> replace(a:set.T, b:set.T) set.T <br>set. <a href="#">replace</a>(toseq.a, toseq.b, 1, 1, empty:seq.T) <p> <a id="replace:seq.T:seq.T:int:int:seq.T:seq.T" href="#set">function</a> replace(a:seq.T, b:seq.T, i:int, j:int, result:seq.T) seq.T <br> <span class="comment">{if in a and b then b else a}</span> <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <br> <span class="keyword">else</span> if j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, n.a) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ai = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="keyword">let</span> c = ai <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#">replace</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j <a href="#+:int:int:int">+</a> 1, result <a href="#">+</a> [b <a href="#sub:seq.T:int:T">sub</a> j]) <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <span class="keyword">then</span> <a href="#">replace</a>(a, b, i <a href="#+:int:int:int">+</a> 1, j, result <a href="#">+</a> ai) <br> <span class="keyword">else</span> <a href="#">replace</a>(a, b, i, <a href="#skipahead:seq.T:int:int:T:int">skipahead</a>(b, j, 1, ai), result)</span> <p> <a id="skipahead:seq.T:int:int:T:int" href="#set">function</a> skipahead(b:seq.T, j:int, k:int, ai:T) int <br> <span class="keyword">if</span> j <a href="#+:int:int:int">+</a> k <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> j <a href="#+:int:int:int">+</a> k <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1 <br> <span class="keyword">else</span> if ai <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> (j <a href="#+:int:int:int">+</a> k) <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#skipahead:seq.T:int:int:T:int">skipahead</a>(b, j, k <a href="#+:int:int:int">+</a> k, ai) <br> <span class="keyword">else</span> j <a href="#+:int:int:int">+</a> k <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1 <p> <a id="isempty:set.T:boolean" href="#set">Function</a> isempty(a:set.T) boolean n.toseq.a <a href="#=:int:int:boolean">=</a> 0 <p> <a id="∈:T:set.T:boolean" href="#set">Function</a> ∈(val:T, a:set.T) boolean <a href="#">binarysearch</a>(toseq.a, val) <a href="#>:int:int:boolean">></a> 0 <p> <a id="findindex:set.T:T:int" href="#set">Function</a> findindex(a:set.T, val:T) int <a href="#">binarysearch</a>(toseq.a, val) <p> <a id="cardinality:set.T:int" href="#set">Function</a> cardinality(a:set.T) int n.toseq.a <p> <a id="n:set.T:int" href="#set">Function</a> n(a:set.T) int <br> <span class="comment">{set cardinality}</span> <br>n.toseq.a <p> <a id="=:set.T:set.T:boolean" href="#set">Function</a> =(a:set.T, b:set.T) boolean <br> <a href="#n:set.T:int">n</a>.a <a href="#=:int:int:boolean">=</a> <a href="#n:set.T:int">n</a>.b <br> <a href="#∧:boolean:boolean:boolean">∧</a> toseq.a <a href="#">=</a> toseq.b <p> <a id="subseq:set.T:int:int:set.T" href="#set">Function</a> subseq(a:set.T, from:int, to:int) set.T set. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.a, from, to) <p>------------------------------- <p>Secondary ordering that allows a secondary search on a partial key. <p>The following must be true(a >2 b)≠ EQ implies >1(a, b)=(a >2 b) <p> <span class="keyword">unbound</span> >2(T, T) ordering <p> <a id="findelement2:set.T:T:set.T" href="#set">Function</a> findelement2(a:set.T, n:T) set.T <br> <span class="keyword">let</span> i = <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(toseq.a, 1, n.toseq.a, n), <br> <a href="#asset:seq.T:set.T">asset</a>( <span class="block"> <span class="keyword">if</span> i <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> empty:seq.T <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc = empty:seq.T <br>, @e ∈ <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.a, <a href="#expandrangedown:seq.T:T:int:int">expandrangedown</a>(toseq.a, n, i), <a href="#expandrangeup:seq.T:T:int:int">expandrangeup</a>(toseq.a, n, i))</span> <span class="keyword">do</span> acc <a href="#">+</a> @e, <br>acc</span></span>) <p> <a id="expandrangedown:seq.T:T:int:int" href="#set">function</a> expandrangedown(a:seq.T, n:T, l:int) int <br> <span class="keyword">if</span> l <a href="#>:int:int:boolean">></a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> (l <a href="#">-</a> 1) <br> <a href="#">>2</a> n <br> <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#expandrangedown:seq.T:T:int:int">expandrangedown</a>(a, n, l <a href="#">-</a> 1) <br> <span class="keyword">else</span> l</span> <span class="keyword">else</span> l <p> <a id="expandrangeup:seq.T:T:int:int" href="#set">function</a> expandrangeup(a:seq.T, n:T, u:int) int <br> <span class="keyword">if</span> u <a href="#&lt;:int:int:boolean">&lt;</a> n.a <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> (u <a href="#+:int:int:int">+</a> 1) <br> <a href="#">>2</a> n <br> <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#expandrangeup:seq.T:T:int:int">expandrangeup</a>(a, n, u <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> u</span> <span class="keyword">else</span> u <p> <span class="keyword" id="sparseseq">Module</span> sparseseq.T <p>* lets a sequence have a default value even beyond the length of the seq. <p>use seq.T <p>use seq1.sparseele.T <p>use standard <p>type sparseele is start:int, edata:seq.T <p>type sparse is sequence, sdata:seq.sparseele.T, default:T <p> <a id=">1:sparseele.T:sparseele.T:ordering" href="#sparseseq">Function</a> >1(a:sparseele.T, b:sparseele.T) ordering start.a <a href="#>1:T:T:ordering">>1</a> start.b <p> <a id="sequenceIndex:sparse.T:int:T" href="#sparseseq">function</a> sequenceIndex(s:sparse.T, i:int) T <br> <span class="keyword">let</span> place = <a href="#">binarysearch</a>(sdata.s, sparseele(i, empty:seq.T)), <br> <span class="keyword">if</span> place <a href="#=:int:int:boolean">=</a> -1 <span class="keyword">then</span> default.s <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> k = <span class="keyword">if</span> place <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> -place <a href="#">-</a> 1 <span class="keyword">else</span> place <br> <span class="keyword">let</span> before = (sdata.s) <a href="#sub:seq.T:int:T">sub</a> k, <br> <span class="keyword">let</span> beforeindex = i <a href="#">-</a> start.before <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> beforeindex <a href="#>:int:int:boolean">></a> n.edata.before <span class="keyword">then</span> default.s <span class="keyword">else</span> (edata.before) <a href="#sub:seq.T:int:T">sub</a> beforeindex</span> <p> <a id="sparseseq:T:seq.T" href="#sparseseq">Function</a> sparseseq(a:T) seq.T toseq.sparse(1, empty:seq.sparseele.T, a) <p> <a id="replaceS:seq.T:int:seq.T:seq.T" href="#sparseseq">Function</a> replaceS(a:seq.T, i:int, b:seq.T) seq.T <br> <span class="keyword">let</span> d = <a href="#T:state">to:sparse.T</a>(a), <br> <span class="keyword">if</span> n.toseq.d <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> b <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i <a href="#+:int:int:int">+</a> n.b, n.a)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> ele = sparseele(i, b) <br> <span class="keyword">let</span> place = <a href="#">binarysearch</a>(sdata.d, ele) <br> <span class="keyword">let</span> t = <span class="block"> <span class="keyword">if</span> place <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, 1, place <a href="#">-</a> 1) <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> ele <br> <a href="#">+</a> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>( <span class="block">i <a href="#+:int:int:int">+</a> n.b <a href="#">-</a> 1 <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, place <a href="#+:int:int:int">+</a> 1, n.sdata.d) <br>, 1</span>)</span> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, 1, -place <a href="#">-</a> 1) <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> ele <br> <a href="#">+</a> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>( <span class="block">i <a href="#+:int:int:int">+</a> n.b <a href="#">-</a> 1 <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(sdata.d, -place, n.sdata.d) <br>, 1</span>),</span></span> <span class="keyword">let</span> last = t <a href="#sub:seq.T:int:T">sub</a> n.t, <br>toseq.sparse(start.last <a href="#+:int:int:int">+</a> n.edata.last <a href="#">-</a> 1, t, default.d)</span> <p> <a id="removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T" href="#sparseseq">function</a> removeoverlap(finish:int, s:seq.sparseele.T, i:int) seq.sparseele.T <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.s <span class="keyword">then</span> empty:seq.sparseele.T <br> <span class="keyword">else</span> if finish <a href="#&lt;:int:int:boolean">&lt;</a> start.s <a href="#sub:seq.T:int:T">sub</a> i <span class="keyword">then</span> s <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> (i <a href="#">-</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> this = s <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="keyword">let</span> thisfinish = start.this <a href="#+:int:int:int">+</a> n.edata.this <a href="#">-</a> 1, <br> <span class="keyword">if</span> finish ≥ thisfinish <span class="keyword">then</span> <a href="#removeoverlap:int:seq.sparseele.T:int:seq.sparseele.T">removeoverlap</a>(finish, s, i <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block">[sparseele(finish <a href="#+:int:int:int">+</a> 1, edata.this <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> (finish <a href="#">-</a> start.this))] <br> <a href="#">+</a> s <a href="#&lt;&lt;:seq.T:int:seq.T">&lt;&lt;</a> i</span></span> <p> <a id="*:seq.sparseele.T:sparseele.T:seq.sparseele.T" href="#sparseseq">function</a> *(a:seq.sparseele.T, e:sparseele.T) seq.sparseele.T <br> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.a <span class="keyword">then</span> [e] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> last = a <a href="#sub:seq.T:int:T">sub</a> n.a <br> <span class="keyword">let</span> lastend = start.last <a href="#+:int:int:int">+</a> n.edata.last <a href="#">-</a> 1, <br> <span class="keyword">if</span> lastend <a href="#&lt;:int:int:boolean">&lt;</a> start.e <span class="keyword">then</span> a <a href="#">+</a> e <br> <span class="keyword">else</span> <span class="block">a <br> <a href="#>>:seq.T:int:seq.T">>></a> 1 <br> <a href="#*:seq.sparseele.T:sparseele.T:seq.sparseele.T">*</a> sparseele( <span class="block">start.last <br>, <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(edata.last, 1, start.e <a href="#">-</a> start.last) <br> <a href="#">+</a> edata.e</span>)</span></span> <p> <span class="keyword" id="stack">Module</span> stack.T <p>use seq.T <p>use standard <p> <span class="keyword">Export</span> type:stack.T <p> <span class="keyword">Export</span> toseq(stack.T) seq.T <p>type stack is toseq:seq.T <p> <a id="top:stack.T:int:seq.T" href="#stack">Function</a> top(f:stack.T, n:int) seq.T <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, n.toseq.f <a href="#">-</a> n <a href="#+:int:int:int">+</a> 1, n.toseq.f) <p> <a id="top:stack.T:T" href="#stack">Function</a> top(f:stack.T) T (toseq.f) <a href="#sub:seq.T:int:T">sub</a> n.toseq.f <p> <a id="push:stack.T:T:stack.T" href="#stack">Function</a> push(f:stack.T, t:T) stack.T stack(toseq.f <a href="#">+</a> t) <p> <a id="pop:stack.T:int:stack.T" href="#stack">Function</a> pop(f:stack.T, n:int) stack.T <br> <span class="keyword">assert</span> n.toseq.f ≥ n <span class="keyword">report</span> <span class="literal">"stack underflow:(stacktrace)"</span>, <br>stack. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, 1, n.toseq.f <a href="#">-</a> n) <p> <a id="pop:stack.T:stack.T" href="#stack">Function</a> pop(f:stack.T) stack.T <br> <span class="keyword">assert</span> n.toseq.f <a href="#>:int:int:boolean">></a> 0 <span class="keyword">report</span> <span class="literal">"stack underflow:(stacktrace)"</span>, <br>stack. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(toseq.f, 1, n.toseq.f <a href="#">-</a> 1) <p> <a id="empty::stack.T:stack.T" href="#stack">Function</a> empty:stack.T stack.T stack.empty:seq.T <p> <a id="isempty:stack.T:boolean" href="#stack">Function</a> isempty(f:stack.T) boolean n.toseq.f <a href="#=:int:int:boolean">=</a> 0 <p> <a id="undertop:stack.T:int:T" href="#stack">Function</a> undertop(f:stack.T, n:int) T (toseq.f) <a href="#sub:seq.T:int:T">sub</a> (n.toseq.f <a href="#">-</a> n) <p> <span class="keyword" id="standard">Module</span> standard <p>use bits <p>use seq1.char <p>use seq.char <p>use sort.char <p>use seq1.int <p>use kernal <p>use word <p>use seq1.word <p>use seq.seq.word <p> <span class="keyword">Export</span> char1(s:seq.word) char <p> <span class="keyword">Export</span> type:boolean <p> <span class="keyword">Export</span> type:char <p> <span class="keyword">Export</span> toint(char) int <p> <span class="keyword">Export</span> char(int) char <p> <span class="keyword">Export</span> type:ordering <p> <span class="keyword">Export</span> toword(n:int) word{Covert integer to a single word.}{From UTF8} <p> <span class="keyword">Export</span> toint(w:word) int{Convert an integer represented as a word to an int}{From UTF8} <p> <span class="keyword">Export</span> not(a:boolean) boolean{From internal} <p> <span class="keyword">Export</span> =(a:boolean, b:boolean) boolean{From internal} <p> <span class="keyword">Export</span> false boolean{From internal} <p> <span class="keyword">Export</span> true boolean{From internal} <p> <span class="keyword">Export</span> arithseq(int, int, int) seq.int{From seq1.int} <p> <span class="keyword">Export</span> constantseq(len:int, element:int) seq.int{From seq1.int} <p> <span class="keyword">Export</span> findindex(seq.word, word) int{From seq1.word} <p> <span class="keyword">Export</span> type:seq.char{From seq.char} <p> <span class="keyword">Export</span> isempty(seq.char) boolean{From seq.char} <p> <span class="keyword">Export</span> n(seq.char) int{From seq.char} <p> <span class="keyword">Export</span> sub(seq.char, int) char{From seq.char} <p> <span class="keyword">Export</span> +(seq.char, char) seq.char{From seq.char} <p> <span class="keyword">Export</span> +(seq.char, seq.char) seq.char{From seq.char} <p> <span class="keyword">Export</span> =(seq.char, seq.char) boolean{From seq.char} <p> <span class="keyword">Export</span> empty:seq.char seq.char{From seq.char} <p> <span class="keyword">Export</span> subseq(seq.char, int, int) seq.char{From seq.char} <p> <span class="keyword">Export</span> type:seq.int{From seq.int} <p> <span class="keyword">Export</span> isempty(seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> n(seq.int) int{From seq.int} <p> <span class="keyword">Export</span> sub(seq.int, int) int{From seq.int} <p> <span class="keyword">Export</span> +(seq.int, int) seq.int{From seq.int} <p> <span class="keyword">Export</span> +(seq.int, seq.int) seq.int{From seq.int} <p> <span class="keyword">Export</span> =(seq.int, seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> empty:seq.int seq.int{From seq.int} <p> <span class="keyword">Export</span> subseq(seq.int, int, int) seq.int{From seq.int} <p> <span class="keyword">Export</span> ∈(int, seq.int) boolean{From seq.int} <p> <span class="keyword">Export</span> type:seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> n(seq.seq.word) int{From seq.seq.word} <p> <span class="keyword">Export</span> sub(seq.seq.word, int) seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> +(seq.seq.word, seq.seq.word) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> +(seq.seq.word, seq.word) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> empty:seq.seq.word seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> subseq(seq.seq.word, int, int) seq.seq.word{From seq.seq.word} <p> <span class="keyword">Export</span> ∈(seq.word, seq.seq.word) boolean{From seq.seq.word} <p> <span class="keyword">Export</span> type:seq.word{From seq.word} <p> <span class="keyword">Export</span> isempty(seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> n(seq.word) int{From seq.word} <p> <span class="keyword">Export</span> sub(seq.word, int) word{From seq.word} <p> <span class="keyword">Export</span> +(a:seq.word, b:seq.word) seq.word{OPTION COMPILETIME}{From seq.word} <p> <span class="keyword">Export</span> +(seq.word, word) seq.word{From seq.word} <p> <span class="keyword">Export</span> &lt;&lt;(s:seq.word, i:int) seq.word <br>{* removes i words from beginning of s From seq.word}{From seq.word} <p> <span class="keyword">Export</span> =(seq.word, seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> >>(s:seq.word, i:int) seq.word{* removes i words from end of s}{From seq.word} <p> <span class="keyword">Export</span> last(seq.word) word <p> <span class="keyword">Export</span> empty:seq.word seq.word{From seq.word} <p> <span class="keyword">Export</span> subseq(seq.word, int, int) seq.word{From seq.word} <p> <span class="keyword">Export</span> ∈(word, seq.word) boolean{From seq.word} <p> <span class="keyword">Export</span> encodeword(a:seq.char) word{From word} <p> <span class="keyword">Export</span> merge(a:seq.word) word{make multiple word into a single word.}{From word} <p> <span class="keyword">Export</span> type:word{From word} <p> <span class="keyword">Export</span> decodeword(w:word) seq.char{From word} <p> <span class="keyword">Export</span> hash(a:word) int{From word} <p> <span class="keyword">Export</span> =(a:word, b:word) boolean{From word} <p> <span class="keyword">Export</span> >1(a:word, b:word) ordering{From word} <p> <span class="keyword">Export</span> stacktrace seq.word <p> <a id="dq:seq.word" href="#standard">Function</a> dq seq.word <br> <span class="comment">{doublequote}</span> <br>[ <a href="#encodeword:seq.char:word">encodeword</a>.[char.34]] <p> <a id="dq:seq.word:seq.word" href="#standard">Function</a> dq(s:seq.word) seq.word <a href="#">dq</a> <a href="#">+</a> s <a href="#">+</a> <a href="#">dq</a> <p> <span class="keyword">Export</span> >1(char, char) ordering <p> <span class="keyword">Export</span> =(char, char) boolean <p> <span class="keyword">Export</span> EQ ordering <p> <span class="keyword">Export</span> GT ordering <p> <span class="keyword">Export</span> LT ordering <p> <span class="keyword">Export</span> =(ordering, ordering) boolean <p> <a id="∧:ordering:ordering:ordering" href="#standard">Function</a> ∧(a:ordering, b:ordering) ordering <br> <span class="keyword">if</span> a <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> b <span class="keyword">else</span> a <p> <a id=">1:boolean:boolean:ordering" href="#standard">Function</a> >1(a:boolean, b:boolean) ordering <br> <span class="keyword">if</span> a <span class="keyword">then</span> <span class="keyword">if</span> b <span class="keyword">then</span> {T T} <a href="#EQ:ordering">EQ</a> <span class="keyword">else</span> {T F} <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if b <span class="keyword">then</span> {F T} <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> {F F} <a href="#EQ:ordering">EQ</a> <p> <span class="keyword">Export</span> ∧(a:boolean, b:boolean) boolean <p> <span class="keyword">Export</span> ∨(a:boolean, b:boolean) boolean <p>------------------------------- <p> <span class="keyword">Export</span> -(i:int) int <p> <span class="keyword">Export</span> >1(a:int, b:int) ordering <p> <span class="keyword">Export</span> +(a:int, b:int) int <p> <span class="keyword">Export</span> -(a:int, b:int) int <p> <span class="keyword">Export</span> *(a:int, b:int) int <p> <span class="keyword">Export</span> /(a:int, b:int) int <p> <span class="keyword">Export</span> =(a:int, b:int) boolean <p>-------------------- <p> <span class="keyword">Export</span> abs(x:int) int <p> <span class="keyword">Export</span> mod(x:int, y:int) int <p> <span class="keyword">Export</span> >(a:int, b:int) boolean <p> <span class="keyword">Export</span> &lt;(a:int, b:int) boolean <p> <span class="keyword">Export</span> between(i:int, lower:int, upper:int) boolean <p> <span class="keyword">Export</span> sup(i:int, n:int) int <p> <span class="keyword">Export</span> max(a:int, b:int) int <p> <span class="keyword">Export</span> min(a:int, b:int) int <p>------------------------------- <p> <span class="keyword">Export</span> hash(a:seq.int) int <p> <span class="keyword">Export</span> hash(a:seq.word) int <p> <a id="randomseq:int:int:seq.int" href="#standard">Function</a> randomseq(seed:int, length:int) seq.int <br> <span class="comment">{Xorshift* see Wikapedia entry on Xorshift}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, state = bits.seed <br> <span class="keyword">while</span> n.acc <a href="#&lt;:int:int:boolean">&lt;</a> length <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> x1 = state <a href="#⊻:bits:bits:bits">⊻</a> state <a href="#>>:bits:int:bits">>></a> 12 <br> <span class="keyword">let</span> x2 = x1 <a href="#⊻:bits:bits:bits">⊻</a> x1 <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 25, <br> <span class="keyword">let</span> nextrandom = x2 <a href="#⊻:bits:bits:bits">⊻</a> x2 <a href="#>>:bits:int:bits">>></a> 27, <br>next( <span class="block">acc <a href="#">+</a> toint.state <a href="#*:int:int:int">*</a> toint.0x2545F4914F6CDD1D <br>, nextrandom</span>)</span> <span class="comment">{???? omitting acc gives strange error message}</span> <br>acc <p> <a id="break:seq.word:seq.word:boolean:seq.seq.word" href="#standard">Function</a> break(s:seq.word, seperators:seq.word, includeseperator:boolean) seq.seq.word <br> <span class="keyword">let</span> nosep = <span class="keyword">if</span> includeseperator <span class="keyword">then</span> 0 <span class="keyword">else</span> 1 <br> <span class="keyword">for</span> l = empty:seq.int, j = 1, e ∈ s <br> <span class="keyword">do</span> next(l <a href="#">+</a> ( <span class="keyword">if</span> e <a href="#">∈</a> seperators <span class="keyword">then</span> [j] <span class="keyword">else</span> empty:seq.int), j <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.seq.word <br>, i = 1 <br>, ele ∈ l <a href="#">+</a> (n.s <a href="#+:int:int:int">+</a> 1)</span> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">s <br>, <span class="keyword">if</span> i <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> 1 <br> <span class="keyword">else</span> l <a href="#sub:seq.T:int:T">sub</a> (i <a href="#">-</a> 1) <a href="#+:int:int:int">+</a> nosep <br>, ele <a href="#">-</a> 1</span>) <br>, i <a href="#+:int:int:int">+</a> 1</span>),</span> acc <p> <a id="extractValue:seq.word:seq.word:seq.word" href="#standard">Function</a> extractValue(s:seq.word, name:seq.word) seq.word <br> <span class="keyword">for</span> <span class="block">value = <span class="literal">""</span> <br>, invalue = false <br>, last = <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, found = false <br>, w ∈ s</span> <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> invalue <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">": :"</span> <span class="keyword">then</span> next(value <a href="#>>:seq.T:int:seq.T">>></a> 1, invalue, w, true) <br> <span class="keyword">else</span> next(value <a href="#">+</a> w, invalue, w, false)</span> <span class="keyword">else</span> if w <a href="#">∈</a> <span class="literal">": :"</span> <a href="#∧:boolean:boolean:boolean">∧</a> last <a href="#">∈</a> name <span class="keyword">then</span> next(value, true, w, false) <br> <span class="keyword">else</span> next(value, false, w, false),</span> value <p> <a id="extractFlag:seq.word:seq.word:boolean" href="#standard">Function</a> extractFlag(s:seq.word, name:seq.word) boolean <br> <span class="keyword">for</span> <span class="block">value = <span class="literal">""</span> <br>, invalue = false <br>, last = <span class="literal">"?"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br>, found = false <br>, w ∈ s</span> <span class="keyword">while</span> <a href="#not:boolean:boolean">not</a>.found <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">if</span> invalue <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> w <a href="#">∈</a> <span class="literal">": :"</span> <span class="keyword">then</span> next(value <a href="#>>:seq.T:int:seq.T">>></a> 1, invalue, w, true) <br> <span class="keyword">else</span> next(value <a href="#">+</a> w, invalue, w, false)</span> <span class="keyword">else</span> if w <a href="#">∈</a> <span class="literal">": :"</span> <a href="#∧:boolean:boolean:boolean">∧</a> last <a href="#">∈</a> name <span class="keyword">then</span> next(value, true, w, false) <br> <span class="keyword">else</span> next(value, false, w, false),</span> found <a href="#∧:boolean:boolean:boolean">∧</a> value ≠ <span class="literal">"false"</span> <p> <a id="hexdigit:bits:char" href="#standard">function</a> hexdigit(b:bits) char <br> <span class="keyword">let</span> k = <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"0123456789ABCDEF"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">assert</span> n.k <a href="#=:int:int:boolean">=</a> 16 <span class="keyword">report</span> <span class="literal">"XXX:(n.k)"</span>, <br>k <a href="#sub:seq.T:int:T">sub</a> (1 <a href="#+:int:int:int">+</a> toint(b <a href="#∧:bits:bits:bits">∧</a> 0x0F)) <p> <a id="hexword:bits:word" href="#standard">function</a> hexword(b:bits) word <br> <a href="#encodeword:seq.char:word">encodeword</a>.[ <span class="block"> <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 12) <br>, <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 8) <br>, <a href="#hexdigit:bits:char">hexdigit</a>(b <a href="#>>:bits:int:bits">>></a> 4) <br>, <a href="#hexdigit:bits:char">hexdigit</a>.b</span>] <p> <a id="%:bits:seq.word" href="#standard">Function</a> %(b:bits) seq.word <br>[ <span class="block"> <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 48) <br>, <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 32) <br>, <a href="#hexword:bits:word">hexword</a>(b <a href="#>>:bits:int:bits">>></a> 16) <br>, <a href="#hexword:bits:word">hexword</a>.b</span>] <p> <a id="%:byte:seq.word" href="#standard">Function</a> %(b:byte) seq.word <br>[ <span class="block"> <a href="#encodeword:seq.char:word">encodeword</a>.[ <span class="block"> <a href="#hexdigit:bits:char">hexdigit</a>( <a href="#tobits:byte:bits">tobits</a>.b <a href="#>>:bits:int:bits">>></a> 4) <br>, <a href="#hexdigit:bits:char">hexdigit</a>. <a href="#tobits:byte:bits">tobits</a>.b</span>]</span>] <p> <a id="%:int:seq.word" href="#standard">Function</a> %(n:int) seq.word [ <a href="#toword:int:word">toword</a>.n] <p> <a id="%:word:seq.word" href="#standard">Function</a> %(w:word) seq.word [w] <p> <a id="%:boolean:seq.word" href="#standard">Function</a> %(b:boolean) seq.word <span class="keyword">if</span> b <span class="keyword">then</span> <span class="literal">"true"</span> <span class="keyword">else</span> <span class="literal">"false"</span> <p> <a id="%:ordering:seq.word" href="#standard">Function</a> %(o:ordering) seq.word [ <span class="literal">"LT EQ GT"</span> <a href="#sub:seq.T:int:T">sub</a> (toint.o <a href="#+:int:int:int">+</a> 1)] <p> <a id=">alpha:word:word:ordering" href="#standard">Function</a> >alpha(a:word, b:word) ordering <br> <span class="keyword">if</span> a <a href="#=:word:word:boolean">=</a> b <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <a href="#decodeword:word:seq.char">decodeword</a>.a <br> <a href="#>alpha:seq.T:seq.T:ordering">>alpha</a> <a href="#decodeword:word:seq.char">decodeword</a>.b</span> <p> <span class="keyword">Export</span> type:word <p> <a id=">alpha:char:char:ordering" href="#standard">Function</a> >alpha(a:char, b:char) ordering a <a href="#>1:T:T:ordering">>1</a> b <p>use seq.int <p> <a id="seqseg2:seq.int:int:pseq.int" href="#standard">Function</a> seqseg2(s:seq.int, i:int) pseq.int <a href="#seqseg:seq.T:int:pseq.T">seqseg</a>(s, i) <p> <a id="red:seq.word:seq.word" href="#standard">Function</a> red(s:seq.word) seq.word <span class="literal">"//:(s)/literal"</span> <p> <span class="keyword" id="UTF8">Module</span> UTF8 <p>use bits <p>use seq.byte <p>use seq1.char <p>use seq.int <p>use standard <p>use word <p> <span class="keyword">Export</span> type:UTF8 <p> <span class="keyword">Export</span> toseqbyte(UTF8) seq.byte <p> <span class="keyword">Export</span> UTF8(seq.byte) UTF8 <p>type UTF8 is toseqbyte:seq.byte <p> <a id="length:UTF8:int" href="#UTF8">Function</a> length(a:UTF8) int n.toseqbyte.a <p> <a id="sub:UTF8:int:byte" href="#UTF8">Function</a> sub(a:UTF8, i:int) byte (toseqbyte.a) <a href="#sub:seq.T:int:T">sub</a> i <p> <a id="emptyUTF8:UTF8" href="#UTF8">Function</a> emptyUTF8 UTF8 UTF8.empty:seq.byte <p> <a id="+:UTF8:UTF8:UTF8" href="#UTF8">Function</a> +(a:UTF8, b:UTF8) UTF8 UTF8(toseqbyte.a <a href="#">+</a> toseqbyte.b) <p> <a id="+:UTF8:char:UTF8" href="#UTF8">Function</a> +(a:UTF8, ch:char) UTF8 a <a href="#+:UTF8:UTF8:UTF8">+</a> <a href="#encodeUTF8:char:UTF8">encodeUTF8</a>.ch <p> <a id="+:UTF8:seq.char:UTF8" href="#UTF8">Function</a> +(a:UTF8, s:seq.char) UTF8 <br> <span class="keyword">for</span> acc = a, @e ∈ s <span class="keyword">do</span> acc <a href="#+:UTF8:char:UTF8">+</a> @e, <br>acc <p> <a id="=:UTF8:UTF8:boolean" href="#UTF8">Function</a> =(a:UTF8, b:UTF8) boolean toseqbyte.a <a href="#=:seq.T:seq.T:boolean">=</a> toseqbyte.b <p> <a id="commachar:char" href="#UTF8">Function</a> commachar char char.44 <p> <a id="hyphenchar:char" href="#UTF8">Function</a> hyphenchar char char.45 <p> <a id="periodchar:char" href="#UTF8">Function</a> periodchar char char.46 <p> <a id="hexOrDecimal?:word:word" href="#UTF8">Function</a> hexOrDecimal?(w:word) word <br> <span class="comment">{checks to see if the first 2 chars indicate the word may be integer in hex or decimal format and returns hex, decimal, or other}</span> <br> <span class="keyword">let</span> chars = <a href="#decodeword:word:seq.char">decodeword</a>.w <br> <span class="keyword">let</span> len = n.chars, <br> <span class="keyword">if</span> len <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="literal">"other"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = <span class="block"> <span class="keyword">if</span> len <a href="#>:int:int:boolean">></a> 1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> chars <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span> <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> 1</span> <span class="keyword">let</span> firstchar = toint.chars <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#between:int:int:int:boolean">between</a>(firstchar, 48, 57) <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> len <a href="#>:int:int:boolean">></a> 1 <br> <a href="#∧:boolean:boolean:boolean">∧</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"'"</span> <a href="#=:char:char:boolean">=</a> chars <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="literal">"word"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="literal">"other"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span> <span class="keyword">else</span> if firstchar <a href="#=:int:int:boolean">=</a> 48 <br> <a href="#∧:boolean:boolean:boolean">∧</a> len <a href="#>:int:int:boolean">></a> 2 <br> <a href="#∧:boolean:boolean:boolean">∧</a> chars <a href="#sub:seq.T:int:T">sub</a> 2 <br> <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"xX"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="literal">"hex"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <br> <span class="keyword">else</span> <span class="literal">"decimal"</span> <a href="#sub:seq.T:int:T">sub</a> 1</span> <p> <a id="toUTF8:int:UTF8" href="#UTF8">Function</a> toUTF8(n:int) UTF8 <br> <span class="keyword">for</span> acc = empty:seq.byte, e ∈ <a href="#tochars:int:seq.char">tochars</a>.n <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#tobyte:int:byte">tobyte</a>.toint.e, <br>UTF8.acc <p> <a id="encodeUTF8:char:UTF8" href="#UTF8">Function</a> encodeUTF8(ch:char) UTF8 <br> <span class="comment">{convert to UTF8 byte encoding of unicode character}</span> <br> <span class="keyword">let</span> i = toint.ch, <br>UTF8( <span class="block"> <span class="keyword">if</span> i <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> [ <a href="#tobyte:int:byte">tobyte</a>.i] <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> <span class="block">acc = [ <a href="#tobyte:int:byte">tobyte</a>(128 <a href="#+:int:int:int">+</a> i <a href="#mod:int:int:int">mod</a> 64)] <br>, t = 32 <br>, c = i <a href="#/:int:int:int">/</a> 64</span> <span class="keyword">while</span> c ≥ t <br> <span class="keyword">do</span> <span class="block">next( <span class="block">[ <a href="#tobyte:int:byte">tobyte</a>(128 <a href="#+:int:int:int">+</a> c <a href="#mod:int:int:int">mod</a> 64)] <br> <a href="#">+</a> acc <br>, t <a href="#/:int:int:int">/</a> 2 <br>, c <a href="#/:int:int:int">/</a> 64</span>),</span>[ <a href="#tobyte:int:byte">tobyte</a>(256 <a href="#">-</a> 2 <a href="#*:int:int:int">*</a> t <a href="#+:int:int:int">+</a> c)] <br> <a href="#">+</a> acc</span></span>) <p> <a id="decodeUTF8:UTF8:seq.char" href="#UTF8">Function</a> decodeUTF8(b:UTF8) seq.char <br> <span class="comment">{converts UTF-8 encoded sequence into a sequence of chars}</span> <br> <span class="keyword">for</span> state = 0, val = 0, result = empty:seq.int, x0 ∈ toseqbyte.b <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> x = <a href="#toint:byte:int">toint</a>.x0, <br> <span class="keyword">if</span> state <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> <span class="block"> <span class="keyword">if</span> x <a href="#&lt;:int:int:boolean">&lt;</a> 128 <span class="keyword">then</span> next(0, 0, result <a href="#">+</a> x) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 224 <span class="keyword">then</span> next(1, (x <a href="#">-</a> 192) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 240 <span class="keyword">then</span> next(2, (x <a href="#">-</a> 224) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 248 <span class="keyword">then</span> next(3, (x <a href="#">-</a> 240) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> if x <a href="#&lt;:int:int:boolean">&lt;</a> 252 <span class="keyword">then</span> next(4, (x <a href="#">-</a> 248) <a href="#*:int:int:int">*</a> 64, result) <br> <span class="keyword">else</span> next(5, (x <a href="#">-</a> 252) <a href="#*:int:int:int">*</a> 64, result)</span> <span class="keyword">else</span> if state <a href="#=:int:int:boolean">=</a> 1 <span class="keyword">then</span> next(0, 0, result <a href="#">+</a> (x <a href="#+:int:int:int">+</a> val <a href="#">-</a> 128)) <br> <span class="keyword">else</span> <span class="block">next( <span class="block">state <a href="#">-</a> 1 <br>, (val <a href="#+:int:int:int">+</a> (x <a href="#">-</a> 128)) <a href="#*:int:int:int">*</a> 64 <br>, result</span>),</span></span> <a href="#tocharseq:seq.int:seq.char">tocharseq</a>.result <p> <a id="intlit:UTF8:int" href="#UTF8">Function</a> intlit(s:UTF8) int <br> <a href="#cvttoint:seq.char:int">cvttoint</a>. <a href="#decodeUTF8:UTF8:seq.char">decodeUTF8</a>.s <p> <a id="tointseq:seq.char:seq.int" href="#UTF8">Function</a> tointseq(a:seq.char) seq.int <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> toint.@e, <br>acc <p> <a id="tocharseq:seq.int:seq.char" href="#UTF8">Function</a> tocharseq(a:seq.int) seq.char <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> char.@e, <br>acc <p> <a id="escapeformat:word" href="#UTF8">Function</a> escapeformat word <a href="#">merge</a>. <span class="literal">"/ escapeformat"</span> <p> <span class="keyword" id="word">Module</span> word <p>use bits <p>use seq.char <p>use encoding.seq.char <p>use seq.int <p>use kernal <p>use seq.word <p>use xxhash <p> <a id="tointseq:seq.char:seq.int" href="#word">function</a> tointseq(a:seq.char) seq.int <br> <span class="comment">{This is just a type change and the compiler recognizes this and does not generate code}</span> <br> <span class="keyword">for</span> acc = empty:seq.int, @e ∈ a <span class="keyword">do</span> acc <a href="#">+</a> toint.@e, <br>acc <p> <a id="word:encoding.seq.char:word" href="#word">Function</a> word(a:encoding.seq.char) word <a href="#T:state">word</a>.valueofencoding.a <p> <a id="asencoding:word:encoding.seq.char" href="#word">Function</a> asencoding(w:word) encoding.seq.char <a href="#T:state">to:encoding.seq.char</a>(rawvalue.w) <p> <a id=">1:char:char:ordering" href="#word">Function</a> >1(a:char, b:char) ordering toint.a <a href="#>1:T:T:ordering">>1</a> toint.b <p> <a id="hash:seq.char:int" href="#word">Function</a> hash(a:seq.char) int <br> <span class="keyword">for</span> <span class="block">acc = <a href="#hashstart32:int:bits">hashstart32</a>.0 <br>, @e ∈ <a href="#tointseq:seq.char:seq.int">tointseq</a>.a</span> <span class="keyword">do</span> <a href="#hash32:bits:int:bits">hash32</a>(acc, @e), <br> <a href="#finalmix32:bits:int">finalmix32</a>.acc <p> <a id="wordencodingtoword:int:word" href="#word">Function</a> wordencodingtoword(i:int) word <a href="#">word</a>. <a href="#T:state">to:encoding.seq.char</a>(i) <p> <a id="encodeword:seq.char:word" href="#word">Function</a> encodeword(a:seq.char) word <br> <span class="comment">{OPTION NOINLINE COMPILETIME}</span> <br> <a href="#">word</a>. <a href="#encode:T:encoding.T">encode</a>.a <p> <a id="decodeword:word:seq.char" href="#word">Function</a> decodeword(w:word) seq.char <br> <span class="comment">{OPTION NOINLINE COMPILETIME}</span> <br> <a href="#decode:encoding.T:T">decode</a>. <a href="#asencoding:word:encoding.seq.char">asencoding</a>.w <p> <a id="hash:word:int" href="#word">Function</a> hash(a:word) int <br> <a href="#hash:encoding.T:int">hash</a>. <a href="#asencoding:word:encoding.seq.char">asencoding</a>.a <p> <a id="hash:seq.word:int" href="#word">Function</a> hash(a:seq.word) int <br> <span class="keyword">for</span> acc = <a href="#hashstart:bits">hashstart</a>, @e ∈ a <br> <span class="keyword">do</span> <a href="#hash:bits:int:bits">hash</a>(acc, <a href="#hash:word:int">hash</a>.@e), <br> <a href="#finalmix:bits:int">finalmix</a>.acc <p> <a id="hash:seq.int:int" href="#word">Function</a> hash(a:seq.int) int <br> <span class="keyword">for</span> acc = <a href="#hashstart:bits">hashstart</a>, @e ∈ a <br> <span class="keyword">do</span> <a href="#hash:bits:int:bits">hash</a>(acc, @e), <br> <a href="#finalmix:bits:int">finalmix</a>.acc <p> <a id=">1:word:word:ordering" href="#word">Function</a> >1(a:word, b:word) ordering <br> <a href="#asencoding:word:encoding.seq.char">asencoding</a>.a <br> <a href="#>1:T:T:ordering">>1</a> <a href="#asencoding:word:encoding.seq.char">asencoding</a>.b <p> <a id="merge:seq.word:word" href="#word">Function</a> merge(a:seq.word) word <br> <span class="comment">{OPTION COMPILETIME /br<br>make multiple words into a single word. }</span> <br> <span class="keyword">for</span> acc = empty:seq.char, @e ∈ a <br> <span class="keyword">do</span> acc <a href="#">+</a> <a href="#decodeword:word:seq.char">decodeword</a>.@e, <br> <a href="#encodeword:seq.char:word">encodeword</a>.acc <p> <a id="toword:int:word" href="#word">Function</a> toword(n:int) word <br> <span class="comment">{OPTION NOINLINE COMPILETIME /br<br>Covert integer to sequence of characters represented as a single word. }</span> <br> <a href="#encodeword:seq.char:word">encodeword</a>. <a href="#tochars:int:seq.char">tochars</a>.n <p> <a id="tochars:int:seq.char" href="#word">Function</a> tochars(n:int) seq.char <br> <span class="keyword">if</span> n <a href="#&lt;:int:int:boolean">&lt;</a> 0 <span class="keyword">then</span> [{hyphenchar}char.45] <a href="#">+</a> <a href="#tochars:int:int:seq.char">tochars</a>(n, 10) <span class="keyword">else</span> <a href="#tochars:int:int:seq.char">tochars</a>(-n, 10) <p> <a id="tochars:int:int:seq.char" href="#word">function</a> tochars(n:int, base:int) seq.char <br> <span class="comment">{n should always be negative. This is to handle the smallest integer in the twos complement representation of integers}</span> <br> <span class="keyword">if</span> base <a href="#+:int:int:int">+</a> n <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> [char(48 <a href="#">-</a> n)] <br> <span class="keyword">else</span> <span class="block"> <a href="#tochars:int:int:seq.char">tochars</a>(n <a href="#/:int:int:int">/</a> base, base) <br> <a href="#">+</a> char(48 <a href="#+:int:int:int">+</a> n <a href="#/:int:int:int">/</a> base <a href="#*:int:int:int">*</a> base <a href="#">-</a> n)</span> <p> <a id="toint:word:int" href="#word">Function</a> toint(w:word) int <br> <span class="comment">{Convert an integer represented as a word to an int}</span> <br> <a href="#cvttoint:seq.char:int">cvttoint</a>. <a href="#decodeword:word:seq.char">decodeword</a>.w <p> <a id="cvttoint:seq.char:int" href="#word">Function</a> cvttoint(s:seq.char) int <br> <span class="comment">{Hex values starting with 0x or 0X are allowed. }</span> <br> <span class="keyword">if</span> n.s <a href="#>:int:int:boolean">></a> 2 <br> <a href="#∧:boolean:boolean:boolean">∧</a> s <a href="#sub:seq.T:int:T">sub</a> 2 <br> <a href="#">∈</a> <a href="#decodeword:word:seq.char">decodeword</a>. <span class="literal">"Xx"</span> <a href="#sub:seq.T:int:T">sub</a> 1 <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> b = 0x0, c ∈ s <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> i = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i, 0, 9) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits.i <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i2 = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"a"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i2, 0, 5) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits(i2 <a href="#+:int:int:int">+</a> 10) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i3 = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"A"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i3, 0, 5) <span class="keyword">then</span> b <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 4 <a href="#∨:bits:bits:bits">∨</a> bits(i3 <a href="#+:int:int:int">+</a> 10) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> c <br> <a href="#">∈</a> [ <span class="block"> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"x"</span> <br>, <a href="#char1:seq.word:char">char1</a>. <span class="literal">"X"</span> <br>, {no breack space}char.160</span>] <span class="keyword">report</span> <span class="literal">"invalid hex digit"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s, <br>b,</span></span></span></span> toint.b</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> val = 0, c ∈ s <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> i = toint.c <a href="#">-</a> toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">"0"</span>, <br> <span class="keyword">if</span> <a href="#between:int:int:int:boolean">between</a>(i, 0, 9) <span class="keyword">then</span> val <a href="#*:int:int:int">*</a> 10 <a href="#">-</a> i <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> c <a href="#">∈</a> [ <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span>, {no breack space}char.160] <span class="keyword">report</span> <span class="literal">"invalid digit"</span> <a href="#">+</a> <a href="#encodeword:seq.char:word">encodeword</a>.s <a href="#">+</a> stacktrace, <br>val</span></span> <span class="comment">{Since there are more negative numbers in twos-complement we calculate using negative values. }</span> <br> <span class="keyword">if</span> val <a href="#=:int:int:boolean">=</a> 0 <br> <a href="#∨:boolean:boolean:boolean">∨</a> s <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#=:char:char:boolean">=</a> <a href="#char1:seq.word:char">char1</a>. <span class="literal">"-"</span> <span class="keyword">then</span> val <br> <span class="keyword">else</span> -val</span> <p> <a id="char1:seq.word:char" href="#word">Function</a> char1(s:seq.word) char <br> <span class="comment">{* First character of first word of s}</span> <br>( <a href="#decodeword:word:seq.char">decodeword</a>.s <a href="#sub:seq.T:int:T">sub</a> 1) <br> <a href="#sub:seq.T:int:T">sub</a> 1 <p> <span class="keyword" id="xxhash">Module</span> xxhash <p>use bits <p>use kernal <p> <a id="rotateleft:bits:int:bits" href="#xxhash">Function</a> rotateleft(x:bits, n:int) bits <br>x <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> n <a href="#∨:bits:bits:bits">∨</a> x <a href="#>>:bits:int:bits">>></a> (64 <a href="#">-</a> n) <p> <a id="hash:bits:int:bits" href="#xxhash">Function</a> hash(acc:bits, x:int) bits <br> <span class="comment">{after xxhash /br<br>example use to hash x and y finalmix(hash(hash(hashstart(seed), x), y))}</span> <br> <span class="keyword">let</span> PRIME1 = 11400714785074694791 <br> <span class="keyword">let</span> PRIME2 = 14029467366897019727 <br> <span class="keyword">let</span> PRIME4 = 9650029242287828579, <br>bits( <span class="block">toint. <a href="#rotateleft:bits:int:bits">rotateleft</a>( <span class="block">acc <br> <a href="#⊻:bits:bits:bits">⊻</a> bits( <span class="block">toint. <a href="#rotateleft:bits:int:bits">rotateleft</a>( <span class="block">bits(toint.acc <a href="#+:int:int:int">+</a> x <a href="#*:int:int:int">*</a> PRIME2) <br>, 31</span>) <br> <a href="#*:int:int:int">*</a> PRIME1</span>) <br>, 27</span>) <br> <a href="#*:int:int:int">*</a> PRIME1 <br> <a href="#+:int:int:int">+</a> PRIME4</span>) <p> <a id="hashstart:int:bits" href="#xxhash">Function</a> hashstart(seed:int) bits <br> <span class="keyword">let</span> PRIME5 = 2870177450012600261, <br>bits(seed <a href="#+:int:int:int">+</a> PRIME5 <a href="#+:int:int:int">+</a> 64) <p> <a id="hashstart:bits" href="#xxhash">Function</a> hashstart bits <a href="#hashstart:int:bits">hashstart</a>.0 <p> <a id="finalmix:bits:int" href="#xxhash">Function</a> finalmix(acc:bits) int <br> <span class="keyword">let</span> PRIME2 = 14029467366897019727 <br> <span class="keyword">let</span> PRIME3 = 1609587929392839161 <br> <span class="keyword">let</span> acc1 = <span class="block">bits( <span class="block">toint(acc <a href="#⊻:bits:bits:bits">⊻</a> acc <a href="#>>:bits:int:bits">>></a> 33) <br> <a href="#*:int:int:int">*</a> PRIME2</span>)</span> <span class="keyword">let</span> acc2 = <span class="block">bits( <span class="block">toint(acc1 <a href="#⊻:bits:bits:bits">⊻</a> acc1 <a href="#>>:bits:int:bits">>></a> 29) <br> <a href="#*:int:int:int">*</a> PRIME3</span>),</span> <a href="#abs:int:int">abs</a>.toint(acc2 <a href="#⊻:bits:bits:bits">⊻</a> acc2 <a href="#>>:bits:int:bits">>></a> 32) <p> <a id="rotl32:bits:int:bits" href="#xxhash">Function</a> rotl32(x:bits, n:int) bits <br>0xFFFF FFFF <a href="#∧:bits:bits:bits">∧</a> (x <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> n <a href="#∨:bits:bits:bits">∨</a> x <a href="#>>:bits:int:bits">>></a> (32 <a href="#">-</a> n)) <p> <a id="hash32:bits:int:bits" href="#xxhash">Function</a> hash32(hash:bits, key:int) bits <br> <a href="#rotl32:bits:int:bits">rotl32</a>( <span class="block">bits(toint.hash <a href="#+:int:int:int">+</a> toint(bits.2246822519 <a href="#*:bits:int:bits">*</a> key)) <br>, 13</span>) <br> <a href="#*:bits:int:bits">*</a> 2654435761 <p> <a id="*:bits:int:bits" href="#xxhash">Function</a> *(a:bits, b:int) bits <br> <span class="keyword">let</span> m = toint(bits.b <a href="#∨:bits:bits:bits">∨</a> bits.0) <br> <span class="keyword">let</span> nlo = toint(a <a href="#∧:bits:bits:bits">∧</a> 0xFFFF) <br> <span class="keyword">let</span> nhi = toint(a <a href="#∧:bits:bits:bits">∧</a> 0xFFFF <a href="#&lt;&lt;:bits:int:bits">&lt;&lt;</a> 16), <br>bits( <span class="block">toint(bits(nhi <a href="#*:int:int:int">*</a> m) <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF) <br> <a href="#+:int:int:int">+</a> nlo <a href="#*:int:int:int">*</a> m</span>) <br> <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF <p> <a id="finalmix32:bits:int" href="#xxhash">Function</a> finalmix32(hash:bits) int <br> <span class="keyword">let</span> h32c = <span class="block">(hash <a href="#⊻:bits:bits:bits">⊻</a> hash <a href="#>>:bits:int:bits">>></a> 15) <br> <a href="#*:bits:int:bits">*</a> 668265263</span> <span class="keyword">let</span> h32d = <span class="block">(h32c <a href="#⊻:bits:bits:bits">⊻</a> h32c <a href="#>>:bits:int:bits">>></a> 13) <br> <a href="#*:bits:int:bits">*</a> 374761393,</span> <a href="#abs:int:int">abs</a>.toint( <span class="block">(h32d <a href="#⊻:bits:bits:bits">⊻</a> h32d <a href="#>>:bits:int:bits">>></a> 16) <br> <a href="#∧:bits:bits:bits">∧</a> 0xFFFF FFFF</span>) <p> <a id="hashstart32:int:bits" href="#xxhash">Function</a> hashstart32(seed:int) bits <br> <span class="keyword">let</span> PRIME5 = 374761393, <br>bits(seed <a href="#+:int:int:int">+</a> PRIME5) <p> <a id="hash:int:int" href="#xxhash">Function</a> hash(i:int) int <br> <a href="#finalmix:bits:int">finalmix</a>. <a href="#hash:bits:int:bits">hash</a>( <a href="#hashstart:bits">hashstart</a>, i) <p> <span class="keyword" id="seq1">Module</span> seq1.T <p>use seq.T <p>use seq.seq.T <p>use seq.int <p>use kernal <p>use word <p>use seq.word <p> <span class="keyword">Export</span> type:arithmeticseq.T <p> <span class="keyword">Export</span> type:seq.T{From seq.T} <p> <span class="keyword">Export</span> isempty(a:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> ispseq(s:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> n(a:seq.T) int{From seq.T} <p> <span class="keyword">Export</span> sub(s:seq.T, i:int) T <p> <span class="keyword">Export</span> +(a:seq.T, b:seq.T) seq.T{From seq.T} <p> <span class="keyword">Export</span> +(l:seq.T, a:T) seq.T{From seq.T} <p> <span class="keyword">Export</span> &lt;&lt;(s:seq.T, i:int) seq.T{* removes i elements from beginning of s}{From seq.T} <p> <span class="keyword">Export</span> =(a:seq.T, b:seq.T) boolean{From seq.T} <p> <span class="keyword">Export</span> >>(s:seq.T, i:int) seq.T{* removes i elements from end of s}{From seq.T} <p> <span class="keyword">Export</span> last(seq.T) T <p> <span class="keyword">Export</span> empty:seq.T seq.T{From seq.T} <p> <span class="keyword">Export</span> lookup(s:seq.T, T) seq.T{From seq.T} <p> <span class="keyword">Export</span> subseq(s:seq.T, start:int, finish:int) seq.T{From seq.T} <p> <span class="keyword">Export</span> ∈(a:T, s:seq.T) boolean{From seq.T} <p> <a id="reverse:seq.T:seq.T" href="#seq1">Function</a> reverse(s:seq.T) seq.T <br> <span class="keyword">for</span> acc = empty:seq.T, i = n.s <br> <span class="keyword">while</span> i <a href="#>:int:int:boolean">></a> 0 <br> <span class="keyword">do</span> next(acc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#">-</a> 1), <br>acc <p>type cseq is sequence, element:T <p> <a id="sequenceIndex:cseq.T:int:T" href="#seq1">function</a> sequenceIndex(s:cseq.T, i:int) T element.s <p> <a id="constantseq:int:T:seq.T" href="#seq1">Function</a> constantseq(len:int, element:T) seq.T toseq.cseq(len, element) <p>type patternseq is sequence, patternlen:int, elements:seq.T <p> <a id="sequenceIndex:patternseq.T:int:T" href="#seq1">function</a> sequenceIndex(s:patternseq.T, i:int) T <br>(elements.s) <br> <a href="#sub:seq.T:int:T">sub</a> ((i <a href="#">-</a> 1) <a href="#mod:int:int:int">mod</a> patternlen.s <a href="#+:int:int:int">+</a> 1) <p> <a id="patternseq:int:seq.T:seq.T" href="#seq1">Function</a> patternseq(len:int, element:seq.T) seq.T <br>toseq.patternseq(len, n.element, element) <p> <a id="replace:seq.T:int:T:seq.T" href="#seq1">Function</a> replace(s:seq.T, index:int, value:T) seq.T <br> <span class="keyword">if</span> <a href="#not:boolean:boolean">not</a>. <a href="#ispseq:seq.T:boolean">ispseq</a>.s <span class="keyword">then</span> <span class="block"> <span class="keyword">for</span> acc = empty:seq.T, i = 1 <br> <span class="keyword">while</span> i <a href="#&lt;:int:int:boolean">&lt;</a> index <br> <span class="keyword">do</span> next(acc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> i, i <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">for</span> oldacc = acc <a href="#">+</a> value, j = index <a href="#+:int:int:int">+</a> 1 <br> <span class="keyword">while</span> j ≤ n.s <br> <span class="keyword">do</span> next(oldacc <a href="#">+</a> s <a href="#sub:seq.T:int:T">sub</a> j, j <a href="#+:int:int:int">+</a> 1), <br>oldacc</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = <a href="#T:state">to:pseq.T</a>(s), <br> <span class="keyword">if</span> index <a href="#>:int:int:boolean">></a> n.a.p <span class="keyword">then</span> a.p <a href="#">+</a> <a href="#">replace</a>(b.p, index <a href="#">-</a> n.a.p, value) <br> <span class="keyword">else</span> <a href="#">replace</a>(a.p, index, value) <a href="#">+</a> b.p</span> <p> <span class="keyword">Export</span> type:arithmeticseq.T <p> <span class="keyword">Export</span> arithmeticseq(int, step:T, start:T) arithmeticseq.T <p> <span class="keyword">Export</span> step(arithmeticseq.T) T <p> <span class="keyword">Export</span> start(arithmeticseq.T) T <p> <span class="keyword">Export</span> toseq(arithmeticseq.T) seq.T <p>type arithmeticseq is sequence, step:T, start:T <p> <span class="keyword">unbound</span> +(T, T) T <p> <span class="keyword">unbound</span> *(int, T) T <p> <span class="keyword">unbound</span> =(T, T) boolean <p> <a id="sequenceIndex:arithmeticseq.T:int:T" href="#seq1">Function</a> sequenceIndex(s:arithmeticseq.T, i:int) T <br>start.s <a href="#">+</a> (i <a href="#">-</a> 1) <a href="#">*</a> step.s <p> <a id="arithseq:int:T:T:seq.T" href="#seq1">Function</a> arithseq(length:int, step:T, start:T) seq.T <br>toseq.arithmeticseq(length, step, start) <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id=">1:seq.T:seq.T:ordering" href="#seq1">Function</a> >1(a:seq.T, b:seq.T) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> lengtha <a href="#>:int:int:boolean">></a> lengthb <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if lengtha <a href="#&lt;:int:int:boolean">&lt;</a> lengthb <span class="keyword">then</span> <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> <a href="#subcmp:seq.T:seq.T:int:ordering">subcmp</a>(a, b, 1) <p> <a id="subcmp:seq.T:seq.T:int:ordering" href="#seq1">function</a> subcmp(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmp:seq.T:seq.T:int:ordering">subcmp</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <p> <span class="keyword">unbound</span> >2(T, T) ordering <p>precedence > for >1 >2 >3 >4 >alpha <p> <a id=">2:seq.T:seq.T:ordering" href="#seq1">Function</a> >2(a:seq.T, b:seq.T) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> lengtha <a href="#>:int:int:boolean">></a> lengthb <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> if lengtha <a href="#&lt;:int:int:boolean">&lt;</a> lengthb <span class="keyword">then</span> <a href="#LT:ordering">LT</a> <br> <span class="keyword">else</span> <a href="#subcmp2:seq.T:seq.T:int:ordering">subcmp2</a>(a, b, 1) <p> <a id="subcmp2:seq.T:seq.T:int:ordering" href="#seq1">function</a> subcmp2(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>2</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmp2:seq.T:seq.T:int:ordering">subcmp2</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="binarysearch:seq.T:T:int" href="#seq1">Function</a> binarysearch(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, 1, n.s, val) <p> <a id="binarysearch:seq.T:int:int:T:int" href="#seq1">Function</a> binarysearch(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">assert</span> b <a href="#>:int:int:boolean">></a> 0 <a href="#∧:boolean:boolean:boolean">∧</a> a ≤ n.s <span class="keyword">report</span> <span class="literal">"out of bounds in binary search"</span>, <br> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, b, a, val) <p> <a id="binarysearchNB:seq.T:int:int:T:int" href="#seq1">Function</a> binarysearchNB(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = idxNB(s, p) <a href="#">>1</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#binarysearchNB:seq.T:int:int:T:int">binarysearchNB</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <a id="setinsert:seq.T:T:seq.T" href="#seq1">Function</a> setinsert(s:seq.T, val:T) seq.T <br> <span class="comment">{* assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> s <br> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, -i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, -i, n.s)</span> <p> <a id="setdelete:seq.T:T:seq.T" href="#seq1">Function</a> setdelete(s:seq.T, val:T) seq.T <br> <span class="comment">{* assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s)</span> <span class="keyword">else</span> s <p> <a id="setreplaceorinsert:seq.T:T:seq.T" href="#seq1">Function</a> setreplaceorinsert(s:seq.T, val:T) seq.T <br> <span class="comment">{assumes s is sorted}</span> <br> <span class="keyword">let</span> i = <a href="#">binarysearch</a>(s, val), <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> 0 <span class="keyword">then</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, i <a href="#+:int:int:int">+</a> 1, n.s)</span> <span class="keyword">else</span> <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, 1, -i <a href="#">-</a> 1) <br> <a href="#">+</a> [val] <br> <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(s, -i, n.s)</span> <p> <a id="lpad:int:T:seq.T:seq.T" href="#seq1">Function</a> lpad(n:int, val:T, l:seq.T) seq.T <br> <a href="#constantseq:int:T:seq.T">constantseq</a>(n <a href="#">-</a> n.l, val) <a href="#">+</a> l <p> <a id="break:T:seq.T:seq.seq.T" href="#seq1">Function</a> break(w:T, a:seq.T) seq.seq.T <a href="#">break</a>(w, empty:seq.T, a) <p> <a id="break:T:seq.T:seq.T:seq.seq.T" href="#seq1">Function</a> break(seperator:T, quotes:seq.T, a:seq.T) seq.seq.T <br> <span class="keyword">for</span> acc = empty:seq.int, i = 1, e ∈ a <br> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <a href="#">+</a> ( <span class="keyword">if</span> e <a href="#">∈</a> ([seperator] <a href="#">+</a> quotes) <span class="keyword">then</span> [i] <span class="keyword">else</span> empty:seq.int) <br>, i <a href="#+:int:int:int">+</a> 1</span>),</span> <span class="keyword">if</span> <a href="#isempty:seq.T:boolean">isempty</a>.acc <span class="keyword">then</span> [a] <br> <span class="keyword">else</span> <a href="#">break</a>(empty:seq.T, seperator, seperator, a, acc, 1, 1, empty:seq.seq.T) <p> <a id="break:seq.T:T:T:seq.T:seq.int:int:int:seq.seq.T:seq.seq.T" href="#seq1">function</a> break( <br>str:seq.T <br>, currentquote:T <br>, seperator:T <br>, a:seq.T <br>, b:seq.int <br>, j:int <br>, start:int <br>, result:seq.seq.T <br>) seq.seq.T <br> <span class="keyword">if</span> j <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, n.a)) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> i = b <a href="#sub:seq.T:int:T">sub</a> j, <br> <span class="keyword">if</span> currentquote ≠ seperator <span class="keyword">then</span> <span class="block">{in quoted string} <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> seperator <span class="keyword">then</span> <a href="#">break</a>(str, currentquote, seperator, a, b, j <a href="#+:int:int:int">+</a> 1, start, result) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> currentquote <a href="#∧:boolean:boolean:boolean">∧</a> i <a href="#=:int:int:boolean">=</a> n.a <span class="keyword">then</span> result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1)) <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> currentquote <br> <a href="#∧:boolean:boolean:boolean">∧</a> a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#+:int:int:int">+</a> 1) <a href="#">=</a> currentquote <span class="keyword">then</span> <span class="block"> <a href="#">break</a>( <span class="block"> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i) <br>, currentquote <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 2 <br>, i <a href="#+:int:int:int">+</a> 2 <br>, result</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> a <a href="#sub:seq.T:int:T">sub</a> i ≠ seperator <br> <a href="#∧:boolean:boolean:boolean">∧</a> a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#+:int:int:int">+</a> 1) <a href="#">=</a> seperator <span class="keyword">report</span> <span class="literal">"Format problem"</span>, <br> <a href="#">break</a>( <span class="block">empty:seq.T <br>, seperator <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 2 <br>, i <a href="#+:int:int:int">+</a> 2 <br>, result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1))</span>)</span></span> <span class="keyword">else</span> <span class="block">{not in quoted string} <br> <span class="keyword">if</span> a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">=</a> seperator <span class="keyword">then</span> <span class="block"> <a href="#">break</a>( <span class="block">empty:seq.T <br>, seperator <br>, seperator <br>, a <br>, b <br>, j <a href="#+:int:int:int">+</a> 1 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, result <a href="#">+</a> (str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1))</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">assert</span> <a href="#isempty:seq.T:boolean">isempty</a>(str <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, start, i <a href="#">-</a> 1)) <span class="keyword">report</span> <span class="literal">"Format problem"</span>, <br> <a href="#">break</a>(str, a <a href="#sub:seq.T:int:T">sub</a> i, seperator, a, b, j <a href="#+:int:int:int">+</a> 1, i <a href="#+:int:int:int">+</a> 1, result)</span></span></span> <p> <a id="findindex:seq.T:T:int" href="#seq1">Function</a> findindex(s:seq.T, w:T) int <br> <span class="comment">{result > length.s when element is not found.Otherwise results is location in sequence}</span> <br> <span class="keyword">for</span> i = 1, e ∈ s <span class="keyword">while</span> e ≠ w <span class="keyword">do</span> i <a href="#+:int:int:int">+</a> 1, <br>i <p> <span class="keyword">unbound</span> =(T, T) boolean <p>------------------------------- <p> <span class="keyword">unbound</span> %(T) seq.word <p> <a id="%:seq.word:seq.T:seq.word" href="#seq1">Function</a> %(term:seq.word, z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, i ∈ z <span class="keyword">do</span> acc <a href="#">+</a> <a href="#">%</a>.i <a href="#">+</a> term, <br>acc <p> <a id="%:seq.T:seq.word" href="#seq1">Function</a> %(z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, i ∈ z <span class="keyword">do</span> acc <a href="#">+</a> <a href="#">%</a>.i, <br>acc <p> <a id="%n:seq.T:seq.word" href="#seq1">Function</a> %n(z:seq.T) seq.word <br> <span class="keyword">for</span> acc = <span class="literal">""</span>, idx = 1, i ∈ z <br> <span class="keyword">do</span> <span class="block">next( <span class="block">acc <a href="#">+</a> <span class="literal">"/br"</span> <a href="#">+</a> <a href="#toword:int:word">toword</a>.idx <a href="#">+</a> <span class="literal">":"</span> <a href="#">+</a> <a href="#">%</a>.i <br>, idx <a href="#+:int:int:int">+</a> 1</span>),</span> acc <p> <span class="keyword" id="sort">Module</span> sort.T <p>use standard <p>use seq.T <p>use set.T <p> <span class="keyword">unbound</span> >1(T, T) ordering <p> <a id="sort:seq.T:seq.T" href="#sort">Function</a> sort(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#">merge</a>( <span class="block"> <a href="#sort:seq.T:seq.T">sort</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort:seq.T:seq.T">sort</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge:seq.T:seq.T:seq.T" href="#sort">Function</a> merge(a:seq.T, b:seq.T) seq.T <br> <span class="comment">{* combines sorted seq}</span> <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>1</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>1</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#">>1</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#">>1</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <a id="sort>3:seq.T:seq.T" href="#sort">Function</a> sort>3(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>3:seq.T:seq.T:seq.T">merge>3</a>( <span class="block"> <a href="#sort>3:seq.T:seq.T">sort>3</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>3:seq.T:seq.T">sort>3</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>3:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>3(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#>3:classinfo:classinfo:ordering">>3</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#>3:classinfo:classinfo:ordering">>3</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#>3:classinfo:classinfo:ordering">>3</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#>3:classinfo:classinfo:ordering">>3</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >3(T, T) ordering <p> <a id="sort>4:seq.T:seq.T" href="#sort">Function</a> sort>4(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>4:seq.T:seq.T:seq.T">merge>4</a>( <span class="block"> <a href="#sort>4:seq.T:seq.T">sort>4</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>4:seq.T:seq.T">sort>4</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>4:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>4(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 >4 a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 >4 b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 >4 aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval >4 a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >4(T, T) ordering <p> <a id="sort>alpha:seq.T:seq.T" href="#sort">Function</a> sort>alpha(a:seq.T) seq.T <br> <span class="keyword">if</span> n.a <a href="#&lt;:int:int:boolean">&lt;</a> 2 <span class="keyword">then</span> a <br> <span class="keyword">else</span> <span class="block"> <a href="#merge>alpha:seq.T:seq.T:seq.T">merge>alpha</a>( <span class="block"> <a href="#sort>alpha:seq.T:seq.T">sort>alpha</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, 1, n.a <a href="#/:int:int:int">/</a> 2) <br>, <a href="#sort>alpha:seq.T:seq.T">sort>alpha</a>. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, n.a <a href="#/:int:int:int">/</a> 2 <a href="#+:int:int:int">+</a> 1, n.a)</span>)</span> <p> <a id="merge>alpha:seq.T:seq.T:seq.T" href="#sort">Function</a> merge>alpha(a:seq.T, b:seq.T) seq.T <br> <span class="keyword">let</span> na = n.a, <br> <span class="keyword">if</span> na <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> b <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> nb = n.b, <br> <span class="keyword">if</span> nb <a href="#=:int:int:boolean">=</a> 0 <span class="keyword">then</span> a <br> <span class="keyword">else</span> if b <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>alpha</a> a <a href="#sub:seq.T:int:T">sub</a> na <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> a <a href="#">+</a> b <br> <span class="keyword">else</span> if a <a href="#sub:seq.T:int:T">sub</a> 1 <a href="#">>alpha</a> b <a href="#sub:seq.T:int:T">sub</a> nb <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> b <a href="#">+</a> a <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">for</span> result = empty:seq.T, i = 1, j = 1 <br> <span class="keyword">while</span> i ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> j ≤ nb <br> <span class="keyword">do</span> <span class="block"> <span class="keyword">let</span> aval = a <a href="#sub:seq.T:int:T">sub</a> i <br> <span class="comment">{add all of b less than aval}</span> <br> <span class="keyword">for</span> j1 = j <br> <span class="keyword">while</span> j1 ≤ nb <br> <a href="#∧:boolean:boolean:boolean">∧</a> b <a href="#sub:seq.T:int:T">sub</a> j1 <a href="#">>alpha</a> aval <a href="#=:ordering:ordering:boolean">=</a> <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> j1 <a href="#+:int:int:int">+</a> 1, <br> <span class="keyword">if</span> j1 <a href="#>:int:int:boolean">></a> nb <span class="keyword">then</span> <span class="block">next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <br>, i <br>, j1</span>)</span> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> bval = b <a href="#sub:seq.T:int:T">sub</a> j1 <br> <span class="comment">{add all of a /ge bval}</span> <br> <span class="keyword">for</span> i1 = i <br> <span class="keyword">while</span> i1 ≤ na <a href="#∧:boolean:boolean:boolean">∧</a> bval <a href="#">>alpha</a> a <a href="#sub:seq.T:int:T">sub</a> i1 ≠ <a href="#LT:ordering">LT</a> <br> <span class="keyword">do</span> i1 <a href="#+:int:int:int">+</a> 1, <br>next( <span class="block">result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, j1 <a href="#">-</a> 1) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, i1 <a href="#">-</a> 1) <br>, i1 <br>, j1</span>),</span></span> result <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(a, i, na) <a href="#">+</a> <a href="#subseq:seq.T:int:int:seq.T">subseq</a>(b, j, nb)</span></span> <p> <span class="keyword">unbound</span> >alpha(T, T) ordering <p> <a id=">alpha:seq.T:seq.T:ordering" href="#sort">Function</a> >alpha(a:seq.T, b:seq.T) ordering <a href="#subcmpalpha:seq.T:seq.T:int:ordering">subcmpalpha</a>(a, b, 1) <p> <a id="subcmpalpha:seq.T:seq.T:int:ordering" href="#sort">function</a> subcmpalpha(a:seq.T, b:seq.T, i:int) ordering <br> <span class="keyword">let</span> lengtha = n.a <br> <span class="keyword">let</span> lengthb = n.b, <br> <span class="keyword">if</span> i ≤ lengtha <a href="#∧:boolean:boolean:boolean">∧</a> i ≤ lengthb <span class="keyword">then</span> <span class="block"> <span class="keyword">let</span> c = a <a href="#sub:seq.T:int:T">sub</a> i <a href="#">>alpha</a> b <a href="#sub:seq.T:int:T">sub</a> i, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> <a href="#subcmpalpha:seq.T:seq.T:int:ordering">subcmpalpha</a>(a, b, i <a href="#+:int:int:int">+</a> 1) <span class="keyword">else</span> c</span> <span class="keyword">else</span> if n.a <a href="#=:int:int:boolean">=</a> n.b <span class="keyword">then</span> <a href="#EQ:ordering">EQ</a> <br> <span class="keyword">else</span> if n.a <a href="#>:int:int:boolean">></a> n.b <span class="keyword">then</span> <a href="#GT:ordering">GT</a> <br> <span class="keyword">else</span> <a href="#LT:ordering">LT</a> <p> <span class="keyword">unbound</span> >2(T, T) ordering <p> <a id="binarysearch>2:seq.T:T:int" href="#sort">Function</a> binarysearch>2(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, 1, n.s, val) <p> <a id="binarysearch2:seq.T:int:int:T:int" href="#sort">Function</a> binarysearch2(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = s <a href="#sub:seq.T:int:T">sub</a> p <a href="#">>2</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#binarysearch2:seq.T:int:int:T:int">binarysearch2</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <a id="binarysearch>3:seq.T:T:int" href="#sort">Function</a> binarysearch>3(s:seq.T, val:T) int <br> <span class="comment">{* binarysearch returns position in seq if found and the negation of the posistion if not found}</span> <br> <a href="#">binarysearch>3</a>(s, 1, n.s, val) <p> <a id="binarysearch>3:seq.T:int:int:T:int" href="#sort">Function</a> binarysearch>3(s:seq.T, b:int, a:int, val:T) int <br> <span class="keyword">if</span> a <a href="#&lt;:int:int:boolean">&lt;</a> b <span class="keyword">then</span> -(a <a href="#+:int:int:int">+</a> 1) <br> <span class="keyword">else</span> <span class="block"> <span class="keyword">let</span> p = (a <a href="#+:int:int:int">+</a> b) <a href="#/:int:int:int">/</a> 2 <br> <span class="keyword">let</span> c = s <a href="#sub:seq.T:int:T">sub</a> p <a href="#>3:classinfo:classinfo:ordering">>3</a> val, <br> <span class="keyword">if</span> c <a href="#=:ordering:ordering:boolean">=</a> <a href="#EQ:ordering">EQ</a> <span class="keyword">then</span> p <br> <span class="keyword">else</span> if c <a href="#=:ordering:ordering:boolean">=</a> <a href="#GT:ordering">GT</a> <span class="keyword">then</span> <a href="#">binarysearch>3</a>(s, b, p <a href="#">-</a> 1, val) <br> <span class="keyword">else</span> <a href="#">binarysearch>3</a>(s, p <a href="#+:int:int:int">+</a> 1, a, val)</span> <p> <span class="keyword" id="textio">Module</span> textio <p>use UTF8 <p>use seq.UTF8 <p>use bits <p>use seq1.byte <p>use standard <p>use toWords <p> <span class="keyword">Export</span> type:UTF8{From UTF8} <p> <span class="keyword">Export</span> towords(a:UTF8) seq.word{From toWords} <p> <span class="keyword">Export</span> breakparagraph(input:seq.byte) seq.seq.word{From toWords} <p> <span class="keyword">Export</span> fromHTML(bytes:seq.byte) seq.seq.word <br>{input is broken into paragraphs when each paragraph is either an HTML element or is text. Paragraphs of text end with a double quote.} <p> <a id="breaklines:UTF8:seq.UTF8" href="#textio">Function</a> breaklines(a:UTF8) seq.UTF8 <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(toseqbyte.a, 2, 1, empty:seq.UTF8) <p> <a id="breaklines:seq.byte:seq.UTF8" href="#textio">Function</a> breaklines(a:seq.byte) seq.UTF8 <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(a, 2, 1, empty:seq.UTF8) <p> <a id="breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8" href="#textio">function</a> breaklines(a:seq.byte, i:int, last:int, result:seq.UTF8) seq.UTF8 <br> <span class="keyword">if</span> i <a href="#>:int:int:boolean">></a> n.a <span class="keyword">then</span> result <br> <span class="keyword">else</span> if <a href="#toint:byte:int">toint</a>.a <a href="#sub:seq.T:int:T">sub</a> i <a href="#=:int:int:boolean">=</a> 10 <span class="keyword">then</span> <span class="block"> <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>( <span class="block">a <br>, i <a href="#+:int:int:int">+</a> 1 <br>, i <a href="#+:int:int:int">+</a> 1 <br>, result <br> <a href="#">+</a> UTF8. <a href="#subseq:seq.T:int:int:seq.T">subseq</a>( <span class="block">a <br>, last <br>, i <br> <a href="#">-</a> ( <span class="keyword">if</span> <a href="#toint:byte:int">toint</a>.a <a href="#sub:seq.T:int:T">sub</a> (i <a href="#">-</a> 1) <br> <a href="#=:int:int:boolean">=</a> 13 <span class="keyword">then</span> 2 <br> <span class="keyword">else</span> 1)</span>)</span>)</span> <span class="keyword">else</span> <a href="#breaklines:seq.byte:int:int:seq.UTF8:seq.UTF8">breaklines</a>(a, i <a href="#+:int:int:int">+</a> 1, last, result) <p> <a id="breakcommas:UTF8:seq.UTF8" href="#textio">Function</a> breakcommas(a:UTF8) seq.UTF8 <br> <span class="keyword">for</span> <span class="block">acc = empty:seq.UTF8 <br>, @e ∈ <a href="#">break</a>( <span class="block"> <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <span class="literal">","</span> <br>, [ <a href="#tobyte:int:byte">tobyte</a>.toint. <a href="#char1:seq.word:char">char1</a>. <a href="#">dq</a>] <br>, toseqbyte.a</span>)</span> <span class="keyword">do</span> acc <a href="#">+</a> UTF8.@e, <br>acc <p> <span class="keyword" id="file">Module</span> file <p>use UTF8 <p>use bits <p>use seq.byte <p>use seq1.char <p>use seq.seq.char <p>use seq.filename <p>use format1a <p>use markup <p>use standard <p>use textio <p>use seq.seq.word <p> <span class="keyword">Export</span> type:file <p> <span class="keyword">Export</span> fn(file) filename <p> <span class="keyword">Export</span> rawdata(file) seq.seq.byte <p> <span class="keyword">Export</span> response(file) UTF8 <p> <span class="keyword">Export</span> file(fn:filename, rawdata:seq.seq.byte, response:UTF8) file <p> <span class="keyword">Export</span> type:filename <p> <span class="keyword">Export</span> dirpath(filename) word <p> <span class="keyword">Export</span> ext(filename) word <p> <span class="keyword">Export</span> name(filename) word <p> <a id="HTMLformat1:seq.word:UTF8" href="#file">Function</a> HTMLformat1(myinput:seq.word) UTF8 <br> <a href="#HTMLformat1a:seq.word:UTF8">HTMLformat1a</a>.myinput <p> <a id="textFormat1:seq.word:UTF8" href="#file">Function</a> textFormat1(myinput:seq.word) UTF8 <br> <a href="#textFormat1a:seq.word:UTF8">textFormat1a</a>.myinput <p> <a id="HTMLformat:seq.word:UTF8" href="#file">Function</a> HTMLformat(s:seq.word) UTF8 <a href="#HTMLformat1:seq.word:UTF8">HTMLformat1</a>.s <p> <a id="textformat:seq.word:UTF8" href="#file">Function</a> textformat(s:seq.word) UTF8 <a href="#textFormat1:seq.word:UTF8">textFormat1</a>.s <p>type filename is dirpath:word, name:word, ext:word <p> <a id="fullname:filename:word" href="#file">Function</a> fullname(fn:filename) word <br> <a href="#">merge</a>( <span class="block"> <span class="keyword">if</span> dirpath.fn <a href="#">∈</a> <span class="literal">"."</span> <span class="keyword">then</span> [name.fn, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1, ext.fn] <br> <span class="keyword">else</span> [dirpath.fn, <span class="literal">"/"</span> <a href="#sub:seq.T:int:T">sub</a> 1, name.fn, <span class="literal">"."</span> <a href="#sub:seq.T:int:T">sub</a> 1, ext.fn]</span>) <p>type file is fn:filename, rawdata:seq.seq.byte, response:UTF8 <p> <a id="data:file:seq.byte" href="#file">Function</a> data(f:file) seq.byte <br> <span class="keyword">for</span> acc = empty:seq.byte, e ∈ rawdata.f <span class="keyword">do</span> acc <a href="#">+</a> e, <br>acc <p> <a id="getname:seq.word:filename" href="#file">function</a> getname(name:seq.word) filename <br> <span class="keyword">let</span> fns = <a href="#tofilenames:seq.word:seq.filename">tofilenames</a>.name <br> <span class="keyword">assert</span> <a href="#not:boolean:boolean">not</a>. <a href="#isempty:seq.T:boolean">isempty</a>.fns <span class="keyword">report</span> <span class="literal">"no file name specified"</span>, <br>fns <a href="#sub:seq.T:int:T">sub</a> 1 <p> <a id="file:seq.word:seq.word:file" href="#file">Function</a> file(name:seq.word, out:seq.word) file <br> <a href="#file:filename:seq.word:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, out) <p> <a id="file:seq.word:seq.UTF8:file" href="#file">Function</a> file(name:seq.word, out:seq.UTF8) file <br> <span class="keyword">for</span> bytes = empty:seq.byte, e ∈ out <span class="keyword">do</span> bytes <a href="#">+</a> toseqbyte.e, <br> <a href="#file:filename:seq.byte:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, bytes) <p> <a id="file:seq.word:seq.byte:file" href="#file">Function</a> file(name:seq.word, bytes:seq.byte) file <br> <a href="#file:filename:seq.byte:file">file</a>( <a href="#getname:seq.word:filename">getname</a>.name, bytes) <p>use markup <a id="file:filename:seq.word:file" href="#file">Function</a> file(fn:filename, out:seq.word) file <br> <span class="comment">{OPTION NOINLINE}</span> <br> <span class="keyword">let</span> bytes = <span class="keyword">if</span> ext.fn <a href="#">∈</a> <span class="literal">"html"</span> <span class="keyword">then</span> toseqbyte. <a href="#processTXT:seq.seq.word:seq.classinfo:boolean:seq.word:UTF8">processTXT</a>([ <p>"//../tau.css /link /head /sp /tag &lt;table /tag > /nsp /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal

 <p>// // ptr /id Module /keyword ptr

 <p>Export /keyword type:ptr

 <p>Builtin /keyword // allocatespace

 <p>type ptr is xx:int

 <p>// // indirect /id Module /keyword indirect.T

 <p>Export /keyword type:indirect.T

 <p>type indirect is value:seq.T

 <p>Builtin /keyword indirect(T) indirect.T

 <p>Builtin /keyword fromindirect(indirect.T) T

 <p>// // PEGrules /id Module /keyword PEGrules

 <p>use UTF8

 <p>use bits

 <p>use seq.int

 <p>use seq1.oneRule

 <p>use set.oneRule

 <p>use seq1.pegpart

 <p>use seq.pegpart

 <p>use seq1.pegrule

 <p>use set.pegrule

 <p>use standard

 <p>use seq.state

 <p>use seq1.tableEntry

 <p>use seq1.word

 <p>use set.word

 <p>use sort.word

 <p>Export /keyword state(i:int) state

 <p>Export /keyword type:pegpart

 <p>Export /keyword part(pegpart) seq.word

 <p>Export /keyword replacement(pegpart) seq.word

 <p>Export /keyword pegpart(part:seq.word, replacement:seq.word) pegpart

 <p>Export /keyword type:pegrule

 <p>Export /keyword begin(pegrule) state

 <p>Export /keyword kind(pegrule) word

 <p>Export /keyword leftside(pegrule) word

 <p>Export /keyword parts(pegrule) seq.pegpart

 <p>Export /keyword pegrule(word, word, seq.pegpart, int, state) pegrule

 <p>Export /keyword type:state

 <p>Export /keyword toint(state) int

 <p>Export /keyword type:tableEntry

 <p>Export /keyword Fstate(tableEntry) state

 <p>Export /keyword Sstate(tableEntry) state

 <p>Export /keyword action(tableEntry) state

 <p>Export /keyword match(tableEntry) word

 <p>Export /keyword recover(tableEntry) seq.word

 <p>Export /keyword tableEntry(<br>action:state<br>, match:word<br>, Sstate:state<br>, Fstate:state<br>, recover:seq.word<br>) tableEntry<br>

 <p>Export /keyword ∈(state, seq.state) boolean{From seq.state}

 <p>Function // adjust:seq.pegrule:seq.pegrule /id // #PEGrules /href /a adjust(g:seq.pegrule) seq.pegrule<br>// for /keyword // rZ = // //#empty::set.T:set.T /href empty:set.word /a<br>, r!Z = // //#empty::set.T:set.T /href empty:set.word /a<br>, NonT = // //#empty::set.T:set.T /href empty:set.word /a<br>, NonT* = // //#empty::set.T:set.T /href empty:set.word /a<br>, begin = // //#state:state:int:state /href state /a(// //#Idx:state /href Idx /a, 2)<br>, newg1 = empty:seq.pegrule<br>, r ∈ g /block // do /keyword // // for /keyword pZ = //""/literal, p!Z = //""/literal, p ∈ parts.r<br>// do /keyword // // for /keyword eZ = pZ, e!Z = p!Z, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, e ∈ part.p<br>// do /keyword // // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword next(eZ, e!Z, e)<br>// else /keyword if last // //#/href ∈ /a //"!"/literal // then /keyword next(eZ, e!Z // //#/href+/a e, e)<br>// else /keyword next(eZ // //#/href+/a e, e!Z, e), /block next(eZ, e!Z)/block // assert /keyword leftside.r ∉ NonT // //#/href ∪ /a NonT* // report /keyword //"Duplicate Non-Terminal::(leftside.r):(// //#%:int:seq.pegrule:seq.word /href % /a(2, g))"/literal<br>// let /keyword noStates = n.pZ // //#+:int:int:int /href+/a n.p!Z,<br>// let /keyword newg = newg1 // //#/href+/a pegrule(kind.r, leftside.r, parts.r, noStates, begin),<br>// if /keyword kind.r // //#/href ∈ /a //"*+"/literal // then /keyword // next(// rZ // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.pZ<br>, r!Z // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.p!Z<br>, NonT<br>, NonT* // //#+:set.T:T:set.T /href+/a leftside.r<br>, begin // //#+:state:int:state /href+/a noStates<br>, newg /block)/block // else /keyword // next(// rZ // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.pZ<br>, r!Z // //#/href ∪ /a // //#asset:seq.T:set.T /href asset /a.p!Z<br>, NonT // //#+:set.T:T:set.T /href+/a leftside.r<br>, NonT*<br>, begin // //#+:state:int:state /href+/a noStates<br>, newg /block)/block /block // assert /keyword // //#isempty:set.T:boolean /href isempty /a(r!Z // //#∩:set.T:set.T:set.T /href ∩ /a NonT*) // report /keyword //"cannot use ! on * Non-terminal"/literal<br>// let /keyword NonT! = NonT // //#∩:set.T:set.T:set.T /href ∩ /a r!Z<br>// let /keyword NonTAdd = NonT! // //#∩:set.T:set.T:set.T /href ∩ /a rZ<br>// let /keyword NonTchange = NonT! // //#\:set.T:set.T:set.T /href \ /a NonTAdd<br>// for /keyword acc = empty:seq.pegrule, add = empty:seq.pegrule, r ∈ newg1<br>// do /keyword // // if /keyword leftside.r // //#/href ∈ /a NonTchange // then /keyword // next(// acc<br> // //#/href+/a pegrule(//"!"/literal // //#sub:seq.T:int:T /href sub /a 1, leftside.r, parts.r, nostates.r, begin.r)<br>, add /block)/block // else /keyword if leftside.r // //#/href ∈ /a NonTAdd // then /keyword next(acc, add // //#/href+/a r)<br>// else /keyword next(acc // //#/href+/a r, add)/block // assert /keyword // //#isempty:seq.T:boolean /href isempty /a.add // report /keyword // //"PEG grammar not implemented using same non-terminal with ! and without ! /sp /tag &lt;br /tag > /nsp<br>NonT!:(toseq.NonT!)/sp /tag &lt;br /tag > /nsp NonTAdd:(toseq.NonTAdd)"/literal, /block acc

 <p>-----------

 <p>function // smallest:set.oneRule:word:seq.word /id // #PEGrules /href /a smallest(costs:set.oneRule, w:word) seq.word<br>// let /keyword l = // //#lookup:set.T:T:set.T /href lookup /a(costs, oneRule(w, //""/literal, false)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.l // then /keyword [w] // else /keyword right.l // //#sub:set.T:int:T /href sub /a 1

 <p>function // smallest:seq.pegrule:set.oneRule /id // #PEGrules /href /a smallest(rules:seq.pegrule) set.oneRule<br>// for /keyword nonTerminals = // //#empty::set.T:set.T /href empty:set.word /a, r ∈ rules<br>// do /keyword nonTerminals // //#+:set.T:T:set.T /href+/a leftside.r<br>// for /keyword acc1 = // //#empty::set.T:set.T /href empty:set.oneRule /a, r ∈ rules<br>// do /keyword // // if /keyword kind.r // //#/href ∈ /a //"*"/literal // then /keyword acc1 // //#+:set.T:T:set.T /href+/a oneRule(leftside.r, //""/literal, true)<br>// else /keyword // // for /keyword acc2 = acc1, p ∈ parts.r<br>// do /keyword // // for /keyword right = //""/literal, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, w ∈ part.p<br>// do /keyword // // if /keyword w // //#/href ∈ /a //"!"/literal // //#∨:boolean:boolean:boolean /href ∨ /a last // //#/href ∈ /a //"!"/literal // then /keyword next(right, w)<br>// else /keyword next(right // //#/href+/a w, w), /block acc2<br> // //#+:set.T:T:set.T /href+/a oneRule(leftside.r, right, // //#isempty:set.T:boolean /href isempty /a(// //#asset:seq.T:set.T /href asset /a.part.p // //#∩:set.T:set.T:set.T /href ∩ /a nonTerminals)), /block acc2 /block /block // for /keyword s = acc1, continue = true<br>// while /keyword continue<br>// do /keyword // // let /keyword f = // //#substitute:set.oneRule:oneRule:oneRule /href substitute /a(s, s // //#sub:set.T:int:T /href sub /a 1)<br>// for /keyword // acc = [f]<br>, last = f<br>, changed = right.f ≠ right.s // //#sub:set.T:int:T /href sub /a 1<br>, e0 ∈ toseq.s // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1 /block // do /keyword // // let /keyword e = // //#substitute:set.oneRule:oneRule:oneRule /href substitute /a(s, e0)<br>// let /keyword newchanged = changed // //#∨:boolean:boolean:boolean /href ∨ /a right.e ≠ right.e0,<br>// if /keyword left.last // //#=:word:word:boolean /href = /a left.e // //#∧:boolean:boolean:boolean /href ∧ /a allTerminals.last // then /keyword // // if /keyword allTerminals.e // then /keyword next(acc, last, true)<br>// else /keyword next(acc // //#/href+/a e, last, newchanged)/block // else /keyword next(acc // //#/href+/a e, e, newchanged), /block next(// //#asset:seq.T:set.T /href asset /a.acc, changed), /block s

 <p>type oneRule is left:word, right:seq.word, allTerminals:boolean

 <p>function // >1:oneRule:oneRule:ordering /id // #PEGrules /href /a >1(a:oneRule, b:oneRule) ordering<br>left.a // //#/href >1 /a left.b // //#∧:ordering:ordering:ordering /href ∧ /a right.a // //#/href >1 /a right.b

 <p>function // >2:oneRule:oneRule:ordering /id // #PEGrules /href /a >2(a:oneRule, b:oneRule) ordering left.a // //#/href >1 /a left.b

 <p>function // substitute:set.oneRule:oneRule:oneRule /id // #PEGrules /href /a substitute(z:set.oneRule, e:oneRule) oneRule<br>// if /keyword allTerminals.e // then /keyword e<br>// else /keyword // // for /keyword rightNew = //""/literal, all = true, w ∈ right.e<br>// do /keyword // // let /keyword find = // //#findelement2:set.T:T:set.T /href findelement2 /a(z, oneRule(w, [w], false)),<br>// if /keyword // //#n:set.T:int /href n /a.find // //#=:int:int:boolean /href = /a 1 // then /keyword // next(// rightNew // //#/href+/a right.find // //#sub:set.T:int:T /href sub /a 1<br>, all // //#∧:boolean:boolean:boolean /href ∧ /a allTerminals.find // //#sub:set.T:int:T /href sub /a 1 /block)/block // else /keyword next(rightNew // //#/href+/a w, all // //#∧:boolean:boolean:boolean /href ∧ /a // //#n:set.T:int /href n /a.find // //#=:int:int:boolean /href = /a 0), /block oneRule(left.e, rightNew, all)/block

 <p>-------------

 <p>function // %:pegrule:seq.word /id // #PEGrules /href /a %(r:pegrule) seq.word<br>[kind.r, leftside.r]<br> // //#/href+/a // for /keyword acc = //""/literal, e ∈ parts.r // do /keyword acc // //#/href+/a //"/"/literal // //#/href+/a part.e,<br>acc // //#/href+/a //"/sp /tag &lt;br /tag > /nsp"/literal

 <p>type pegrule is kind:word, leftside:word, parts:seq.pegpart, nostates:int, begin:state

 <p>type pegpart is part:seq.word, replacement:seq.word

 <p>type tableEntry is<br>action:state<br>, match:word<br>, Sstate:state<br>, Fstate:state<br>, recover:seq.word

 <p>Function // textGrammar:seq.pegrule:seq.word /id // #PEGrules /href /a textGrammar(g:seq.pegrule) seq.word<br>// for /keyword Non = // //#empty::set.T:set.T /href empty:set.word /a, rightsides = //""/literal, r ∈ g<br>// do /keyword // // for /keyword parts = //""/literal, e ∈ parts.r // do /keyword parts // //#/href+/a part.e,<br>next(Non // //#+:set.T:T:set.T /href+/a leftside.r, rightsides // //#/href+/a parts)/block // let /keyword terms = // // //#asset:seq.T:set.T /href asset /a.rightsides<br> // //#\:set.T:set.T:set.T /href \ /a Non<br> // //#\:set.T:set.T:set.T /href \ /a // //#asset:seq.T:set.T /href asset /a.//"/ ! /sp /tag &lt;br /tag > /nsp<br>"/literal /block // let /keyword unusedNon = // toseq(// Non // //#\:set.T:set.T:set.T /href \ /a // //#asset:seq.T:set.T /href asset /a.rightsides<br> // //#-:set.T:T:set.T /href-/a leftside.g // //#sub:seq.T:int:T /href sub /a 1 /block), /block // //#checkrules:seq.pegrule:seq.word /href checkrules /a.g<br> // //#/href+/a (// if /keyword // //#isempty:seq.T:boolean /href isempty /a.unusedNon // then /keyword //""/literal<br>// else /keyword //"/sp /tag &lt;br /tag > /nsp Unused non-terminals::(unusedNon)"/literal)<br> // //#/href+/a //"/sp /tag &lt;br /tag > /nsp Non-terminals::(// //#sort>alpha:seq.T:seq.T /href sort>alpha /a.toseq.Non)/sp /tag &lt;br /tag > /nsp Terminals::(// //#sort>alpha:seq.T:seq.T /href sort>alpha /a.toseq.terms)"/literal<br> // //#/href+/a // //#%:int:seq.pegrule:seq.word /href % /a(5, g)

 <p>Function // %:int:seq.pegrule:seq.word /id // #PEGrules /href /a %(format:int, newg:seq.pegrule) seq.word<br>//{1 as string 2-as table 3-as table with action 4-as txt 6-as code}/comment<br>// let /keyword action = [//"/action"/literal, //""/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //""/literal, //""/literal, // //#/href dq /a // //#/href+/a //"="/literal] // //#sub:seq.T:int:T /href sub /a format<br>// let /keyword part = [//"/sp /tag &lt;br /tag > /nsp /"/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //"/sp /tag &lt;br /tag > /nsp"/literal, //"/"/literal, //"/"/literal, //"/sp /tag &lt;br /tag > /nsp,:(// //#/href dq /a)/"/literal] // //#sub:seq.T:int:T /href sub /a format<br>// let /keyword rule = //[// //"/sp /tag &lt;br /tag > /nsp"/literal<br>, //"/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>, //"/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>, //"/sp /tag &lt;br /tag > /nsp:(// //#escapeformat:word /href escapeformat /a)/sp /tag &lt;br /tag > /nsp:(// //#escapeformat:word /href escapeformat /a)"/literal<br>, //"/sp /tag &lt;br /tag > /nsp"/literal<br>, //"/sp /tag &lt;br /tag > /nsp,:(// //#/href dq /a)"/literal /block]<br> // //#sub:seq.T:int:T /href sub /a format /block // let /keyword arrow = [//""/literal, //"/tag &lt;/td> /sp /tag &lt;td /tag > /nsp"/literal, //"/tag &lt;/td> /sp /tag &lt;th /tag > /nsp"/literal, //"←"/literal, //"←"/literal, //""/literal] // //#sub:seq.T:int:T /href sub /a format<br>// for /keyword txt0 = //""/literal, r ∈ newg<br>// do /keyword // // for /keyword txt1 = //""/literal, e ∈ parts.r<br>// do /keyword // txt1<br> // //#/href+/a (part.e<br> // //#/href+/a action<br> // //#/href+/a (// if /keyword // //#isempty:seq.T:boolean /href isempty /a.action // then /keyword //""/literal // else /keyword replacement.e)<br> // //#/href+/a part), /block txt0 // //#>>:seq.T:int:seq.T /href >> /a n.part<br> // //#/href+/a (rule<br> // //#/href+/a (// if /keyword kind.r // //#/href ∈ /a //"*+"/literal // then /keyword [kind.r] // else /keyword //""/literal)<br> // //#/href+/a // //#%:word:seq.word /href % /a.leftside.r<br> // //#/href+/a arrow<br> // //#/href+/a txt1), /block // if /keyword format // //#/href ∈ /a [2, 3] // then /keyword //"left /tag &lt;/th> /sp /tag &lt;th /tag > /nsp right /tag &lt;/th> /sp /tag &lt;th /tag > /nsp action /tag &lt;/th> /tag &lt;/tr>:(txt0)/tag &lt;/table> /sp /tag &lt;table /tag > /nsp /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>// else /keyword if format // //#=:int:int:boolean /href = /a 4 // then /keyword //"function genPEG(attributeType:word)seq.boolean[:(// //#subseq:seq.T:int:int:seq.T /href subseq /a(txt0, 3, n.txt0 // //#/href-/a 3))]"/literal<br>// else /keyword txt0 // //#>>:seq.T:int:seq.T /href >> /a 1

 <p>function // checkrules:seq.pegrule:seq.word /id // #PEGrules /href /a checkrules(g:seq.pegrule) seq.word<br>// let /keyword small = // //#smallest:seq.pegrule:set.oneRule /href smallest /a.g<br>// for /keyword acc = //""/literal, r ∈ g<br>// do /keyword // // if /keyword kind.r ∉ //"*+"/literal // then /keyword //""/literal<br>// else /keyword // // for /keyword message = //""/literal, p ∈ parts.r<br>// do /keyword // // for /keyword isempty = true, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, e ∈ part.p<br>// while /keyword isempty<br>// do /keyword // // if /keyword last // //#/href ∈ /a //"!"/literal // then /keyword next(true, e)<br>// else /keyword // // let /keyword t = // //#lookup:set.T:T:set.T /href lookup /a(small, oneRule(e, //""/literal, true)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.t // then /keyword next(false, e)<br>// else /keyword next(// //#isempty:seq.T:boolean /href isempty /a.right.t // //#sub:set.T:int:T /href sub /a 1, e), /block /block // if /keyword isempty // then /keyword message // //#/href+/a //"illegal rule *:(leftside.r):(part.p)/sp /tag &lt;br /tag > /nsp"/literal // else /keyword message, /block acc // //#/href+/a message, /block /block acc

 <p>function // >1:pegrule:pegrule:ordering /id // #PEGrules /href /a >1(a:pegrule, b:pegrule) ordering<br>leftside.a // //#/href >1 /a leftside.b // //#∧:ordering:ordering:ordering /href ∧ /a kind.a // //#/href ∈ /a //"!"/literal // //#>1:T:T:ordering /href >1 /a kind.a // //#/href ∈ /a //"!"/literal

 <p>function // =:tableEntry:tableEntry:boolean /id // #PEGrules /href /a =(a:tableEntry, b:tableEntry) boolean<br>action.a // //#=:state:state:boolean /href = /a action.b<br> // //#∧:boolean:boolean:boolean /href ∧ /a Fstate.a // //#=:state:state:boolean /href = /a Fstate.b<br> // //#∧:boolean:boolean:boolean /href ∧ /a Fstate.a // //#=:state:state:boolean /href = /a Fstate.b

 <p>Function // makeTbl:seq.pegrule:boolean:seq.tableEntry /id // #PEGrules /href /a makeTbl(gin:seq.pegrule, recover:boolean) seq.tableEntry<br>// let /keyword small = // // if /keyword recover // then /keyword // //#smallest:seq.pegrule:set.oneRule /href smallest /a.gin<br>// else /keyword // //#empty::set.T:set.T /href empty:set.oneRule /a /block // let /keyword gset = // //#asset:seq.T:set.T /href asset /a.gin<br>// for /keyword lambdas = //""/literal, r ∈ gin<br>// do /keyword // // if /keyword // //#isempty:seq.T:boolean /href isempty /a.part.(parts.r) // //#sub:seq.T:int:T /href sub /a 1 // then /keyword lambdas // //#/href+/a leftside.r<br>// else /keyword lambdas /block // for /keyword // table = [// tableEntry(// // //#NT:int:state /href NT /a.2<br>, //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#Match:state /href Match /a<br>, // //#Failure:state /href Failure /a<br>, //""/literal /block)/block]<br>, reduce0 = 2<br>, s ∈ gin /block // do /keyword // // for /keyword isAll* = kind.s // //#/href ∈ /a //"*+"/literal, p ∈ parts.s // while /keyword isAll* // do /keyword replacement.p = //"/All"/literal<br>// for /keyword // lastnextstate2 = // //#/href NT /a<br>, nextstate2 = begin.s<br>, ruletable = table<br>, partno = 1<br>, lastpart = (parts.s) // //#sub:seq.T:int:T /href sub /a 1<br>, p ∈ parts.s /block // do /keyword // // let /keyword reduce = partno // //#+:int:int:int /href+/a reduce0 // //#/href-/a 1<br>// for /keyword nextpart = nextstate2, e ∈ part.p<br>// do /keyword // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword nextpart // else /keyword nextpart // //#+:state:int:state /href+/a 1,<br>// for /keyword // parttable = ruletable<br>, thisstate = nextstate2<br>, last = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, count = 1<br>, e ∈ part.p /block // do /keyword // // if /keyword e // //#/href ∈ /a //"!"/literal // then /keyword next(parttable, thisstate, e, count // //#+:int:int:int /href+/a 1)<br>// else /keyword // // let /keyword success1 = // // if /keyword count // //#=:int:int:boolean /href = /a n.part.p // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword // //#!Reduce:state /href !Reduce /a<br>// else /keyword if replacement.p = //"/All"/literal // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // if /keyword isAll* // then /keyword // //#/href Discard* /a.begin.s // else /keyword // //#All*:state /href All* /a<br>// else /keyword // //#All:state /href All /a /block // else /keyword if kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // //#Reduce*:int:state:state /href Reduce* /a(reduce, begin.s)<br>// else /keyword // //#Reduce:int:state /href Reduce /a.reduce /block // else /keyword // // let /keyword tmp = (part.p) // //#sub:seq.T:int:T /href sub /a (count // //#+:int:int:int /href+/a 1),<br>// if /keyword tmp // //#/href ∈ /a lambdas // then /keyword // // for /keyword x = 2, r ∈ gin // while /keyword leftside.r ≠ tmp // do /keyword x // //#+:int:int:int /href+/a n.parts.r,<br>// //#Lambda:int:state:state /href Lambda /a(// x<br>, // if /keyword count // //#+:int:int:int /href+/a 2 ≤ n.part.p // then /keyword thisstate // //#+:state:int:state /href+/a 2<br>// else /keyword // //#Reduce:int:state /href Reduce /a.reduce /block)/block // else /keyword thisstate // //#+:state:int:state /href+/a 1 /block /block // let /keyword failmatch = // // if /keyword n.parts.s // //#=:int:int:boolean /href = /a partno // then /keyword // // if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword // //#!Fail:state /href !Fail /a<br>// else /keyword if isAll* // then /keyword // //#All:state /href All /a<br>// else /keyword if kind.s // //#/href ∈ /a //"*+"/literal // then /keyword // //#Success*:state /href Success* /a<br>// else /keyword // //#Fail:state /href Fail /a /block // else /keyword if // //#isempty:seq.T:boolean /href isempty /a.part.(parts.s) // //#sub:seq.T:int:T /href sub /a (partno // //#+:int:int:int /href+/a 1) // then /keyword // //#Reduce:int:state /href Reduce /a(reduce // //#+:int:int:int /href+/a 1)<br>// else /keyword nextpart /block // for /keyword // RecoverEnding = //""/literal<br>, last0 = //"?"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, w ∈ // if /keyword recover // then /keyword part.p // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (count // //#/href-/a 1) // else /keyword //""/literal /block // do /keyword // next(// // if /keyword w // //#/href ∈ /a //"!"/literal // //#∨:boolean:boolean:boolean /href ∨ /a last0 // //#/href ∈ /a //"!"/literal // then /keyword RecoverEnding<br>// else /keyword RecoverEnding // //#/href+/a // //#smallest:set.oneRule:word:seq.word /href smallest /a(small, w)<br>, w /block)/block // let /keyword C = // // if /keyword e // //#/href ∈ /a //"any Any"/literal // then /keyword tableEntry(// //#MatchAny:state /href MatchAny /a, //"?"/literal // //#sub:seq.T:int:T /href sub /a 1, success1, failmatch, RecoverEnding)<br>// else /keyword // // let /keyword look = // //#lookup:set.T:T:set.T /href lookup /a(gset, pegrule(last, e, empty:seq.pegpart, 0, // //#/href NT /a)),<br>// if /keyword // //#isempty:set.T:boolean /href isempty /a.look // then /keyword // // if /keyword last // //#/href ∈ /a //"!"/literal // then /keyword tableEntry(// //#!T:state /href !T /a, e, failmatch, success1, RecoverEnding)<br>// else /keyword tableEntry(// //#/href T /a, e, success1, failmatch, RecoverEnding)/block // else /keyword // tableEntry(// // if /keyword kind.look // //#sub:set.T:int:T /href sub /a 1 // //#/href ∈ /a //"*+"/literal // then /keyword // //#/href NT* /a.begin.look // //#sub:set.T:int:T /href sub /a 1<br>// else /keyword // //#/href NT /a.begin.look // //#sub:set.T:int:T /href sub /a 1<br>, leftside.look // //#sub:set.T:int:T /href sub /a 1<br>, success1<br>, failmatch<br>, RecoverEnding /block), /block /block /block // let /keyword newpt = // // if /keyword partno // //#=:int:int:boolean /href = /a 1<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.lastpart, 1, count // //#/href-/a 1)<br> ≠ // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.p, 1, count // //#/href-/a 1) // then /keyword parttable<br>// else /keyword //{look for first rule that shared prefix with current rule}<br>// for /keyword // accT = empty:seq.int<br>, kidx2 = // //#index:state:int /href index /a.thisstate<br>, pt ∈ // //#reverse:seq.T:seq.T /href reverse /a.// //#subseq:seq.T:int:int:seq.T /href subseq /a(parts.s, 1, partno // //#/href-/a 1)/block // while /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.pt, 1, count)<br> = // //#subseq:seq.T:int:int:seq.T /href subseq /a(part.p, 1, count)<br>// do /keyword // // let /keyword newk = kidx2 // //#/href-/a n.part.pt,<br>next(accT // //#/href+/a newk, newk)/block //{part shares prefix with previous part so avoid backtracking. }/comment<br>// if /keyword // //#isempty:seq.T:boolean /href isempty /a.accT // then /keyword // // let /keyword zidx = // //#index:state:int /href index /a.thisstate // //#/href-/a n.part.lastpart<br>// let /keyword z = parttable // //#sub:seq.T:int:T /href sub /a zidx,<br>// if /keyword action.z // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // // //#/href replace /a(// parttable<br>, zidx<br>, tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, thisstate, recover.z)/block)/block // else /keyword if // //#action:state:state /href action /a.action.z // //#/href ∈ /a [// //#/href NT /a, // //#/href NT* /a]<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#index:state:int /href index /a.action.z // //#=:int:int:boolean /href = /a // //#index:state:int /href index /a.action.C // then /keyword // // let /keyword look = // //#lookup:set.T:T:set.T /href lookup /a(gset, pegrule(last, match.z, empty:seq.pegpart, 0, // //#/href NT /a)),<br>// //#/href replace /a(parttable, zidx, tableEntry(action.z, match.z, Sstate.z, thisstate, recover.z))/block // else /keyword parttable /block // else /keyword if // //#action:state:state /href action /a.action.C<br> ∉ [// //#/href T /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword parttable<br>// else /keyword // // let /keyword kidx = accT // //#sub:seq.T:int:T /href sub /a n.accT<br>// let /keyword z = parttable // //#sub:seq.T:int:T /href sub /a kidx,<br>// if /keyword action.z // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // // //#/href replace /a(// parttable<br>, kidx<br>, // if /keyword count // //#=:int:int:boolean /href = /a 1<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#action:state:state /href action /a.action.parttable // //#sub:seq.T:int:T /href sub /a (kidx // //#/href-/a 1)<br> ∉ [// //#/href NT /a, // //#/href NT* /a] // then /keyword tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, Fstate.C, recover.z)<br>// else /keyword tableEntry(// //#T':state /href T' /a, match.z, Sstate.z, thisstate, recover.z)/block)/block // else /keyword if count // //#=:int:int:boolean /href = /a n.part.p // //#∧:boolean:boolean:boolean /href ∧ /a e // //#/href ∈ /a lambdas // then /keyword // // for /keyword newtbl1 = parttable, l ∈ accT<br>// do /keyword // // let /keyword tidx = l // //#+:int:int:int /href+/a 1<br>// let /keyword z3 = parttable // //#sub:seq.T:int:T /href sub /a tidx,<br>// //#/href replace /a(newtbl1, tidx, tableEntry(action.z3, match.z3, Sstate.z3, Sstate.C, recover.z3)), /block newtbl1 /block // else /keyword //{action.action.z = NT}<br>// let /keyword newFstate = // // if /keyword // //#action:state:state /href action /a.Fstate.C<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword // //#/href S' /a.Fstate.C<br>// else /keyword Fstate.C /block // for /keyword newtbl1 = parttable, l ∈ accT<br>// do /keyword // // let /keyword e2 = parttable // //#sub:seq.T:int:T /href sub /a l,<br>// if /keyword // //#index:state:int /href index /a.Fstate.z // //#=:int:int:boolean /href = /a // //#index:state:int /href index /a.Fstate.e2<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#action:state:state /href action /a.Fstate.e2 ∉ [// //#Fail:state /href Fail /a] // then /keyword // // assert /keyword // //#action:state:state /href action /a.Fstate.e2<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a, // //#/href S' /a] // report /keyword //"ProBLEM:(Fstate.e2)"/literal,<br>// //#/href replace /a(// newtbl1<br>, l<br>, tableEntry(// action.e2<br>, match.e2<br>, Sstate.e2<br>, // if /keyword // //#action:state:state /href action /a.Fstate.C<br> // //#/href ∈ /a [// //#Idx:state /href Idx /a, // //#/href NT /a, // //#/href NT* /a] // then /keyword // //#/href S' /a.Fstate.C<br>// else /keyword Fstate.C<br>, recover.e2 /block)/block)/block // else /keyword newtbl1, /block newtbl1, /block /block /block /block next(newpt // //#/href+/a C, thisstate // //#+:state:int:state /href+/a 1, e, count // //#+:int:int:int /href+/a 1), /block /block next(nextstate2, nextpart, parttable, partno // //#+:int:int:int /href+/a 1, p), /block next(ruletable, reduce0 // //#+:int:int:int /href+/a (// if /keyword kind.s // //#/href ∈ /a //"!"/literal // then /keyword 0 // else /keyword n.parts.s))/block // for /keyword table1 = table, r ∈ gin<br>// do /keyword // // if /keyword kind.r // //#/href ∈ /a //"+"/literal // then /keyword // // let /keyword thisrule = // // //#subseq:seq.T:int:int:seq.T /href subseq /a(// table1<br>, // //#index:state:int /href index /a.begin.r<br>, // //#index:state:int /href index /a.begin.r // //#+:int:int:int /href+/a nostates.r // //#/href-/a 1 /block), /block // //#fixPlus:seq.tableEntry:seq.tableEntry:seq.tableEntry:seq.tableEntry /href fixPlus /a(// // //#subseq:seq.T:int:int:seq.T /href subseq /a(table1, 1, // //#index:state:int /href index /a.begin.r // //#/href-/a 1)<br>, thisrule<br>, table1 // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (// //#index:state:int /href index /a.begin.r // //#+:int:int:int /href+/a n.thisrule // //#/href-/a 1)/block)/block // else /keyword table1, /block // //#removeIdx:seq.tableEntry:seq.tableEntry /href removeIdx /a.table1

 <p>function // fixPlus:seq.tableEntry:seq.tableEntry:seq.tableEntry:seq.tableEntry /id // #PEGrules /href /a fixPlus(<br>table0:seq.tableEntry<br>, thisrule:seq.tableEntry<br>, table1:seq.tableEntry<br>) seq.tableEntry<br>//{Change rule in table to handle first match and adds states to table handle following parts}/comment<br>// let /keyword adjust = n.thisrule // //#+:int:int:int /href+/a n.table1<br>// let /keyword low = n.table0 // //#+:int:int:int /href+/a 1<br>// let /keyword high = n.table0 // //#+:int:int:int /href+/a n.thisrule<br>// for /keyword firstPart = table0, afterPart = table1, e ∈ thisrule<br>// do /keyword // // let /keyword S = Sstate.e<br>// let /keyword newS = // // if /keyword S // //#/href ∈ /a [// //#Success*:state /href Success* /a, // //#All:state /href All /a] // then /keyword // //#Fail:state /href Fail /a<br>// else /keyword if // //#action:state:state /href action /a.S // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // // //#Reduce*:int:state:state /href Reduce* /a(// // //#reduceNo:state:int /href reduceNo /a.S<br>, // //#nextState:state:state /href nextState /a.S // //#+:state:int:state /href+/a adjust /block)/block // else /keyword if // //#action:state:state /href action /a.S // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a(// //#nextState:state:state /href nextState /a.S // //#+:state:int:state /href+/a adjust)<br>// else /keyword S /block // let /keyword F = Fstate.e<br>// let /keyword newF = // // if /keyword F // //#/href ∈ /a [// //#Success*:state /href Success* /a, // //#All:state /href All /a] // then /keyword // //#Fail:state /href Fail /a<br>// else /keyword F /block // let /keyword afterS = // //#adjust:state:int:int:int:state /href adjust /a(S, adjust, low, high),<br>// let /keyword afterF = // //#adjust:state:int:int:int:state /href adjust /a(F, adjust, low, high),<br>next(// firstPart // //#/href+/a tableEntry(action.e, match.e, newS, newF, recover.e)<br>, afterPart // //#/href+/a tableEntry(action.e, match.e, afterS, afterF, recover.e)/block), /block firstPart // //#/href+/a afterPart

 <p>function // adjust:state:int:int:int:state /id // #PEGrules /href /a adjust(s:state, adjust:int, low:int, high:int) state<br>// if /keyword // //#between:int:int:int:boolean /href between /a(// //#index:state:int /href index /a.s, low, high) // then /keyword // // if /keyword // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Idx:state /href Idx /a // then /keyword s // //#+:state:int:state /href+/a adjust<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // // //#Reduce*:int:state:state /href Reduce* /a(// // //#reduceNo:state:int /href reduceNo /a.s<br>, // //#nextState:state:state /href nextState /a.s // //#+:state:int:state /href+/a adjust /block)/block // else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a(// //#nextState:state:state /href nextState /a.s // //#+:state:int:state /href+/a adjust)<br>// else /keyword s /block // else /keyword s

 <p>function // removeIdx:seq.tableEntry:seq.tableEntry /id // #PEGrules /href /a removeIdx(tbl:seq.tableEntry) seq.tableEntry<br>// for /keyword acc = empty:seq.tableEntry, e ∈ tbl<br>// do /keyword // acc<br> // //#/href+/a tableEntry(// // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(action.e, tbl)<br>, match.e<br>, // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(Sstate.e, tbl)<br>, // //#removeIdx:state:seq.tableEntry:state /href removeIdx /a(Fstate.e, tbl)<br>, recover.e /block), /block acc

 <p>function // removeIdx:state:seq.tableEntry:state /id // #PEGrules /href /a removeIdx(s:state, tbl:seq.tableEntry) state<br>//{Remove Idx from table. The action of tableEntries will be !T T T' NT NT* or MatchAny.If Idx instruction points to the ith element in the table, it will be changed to !T.i, T.i, T'.i, NT.i, NT*.i to include the kind of the table element.The instruction S', Idx, Discard*, NT, Reduce*, also contains a pointer into the table so they also will be updated. }/comment<br>// if /keyword // //#index:state:int /href index /a.s // //#=:int:int:boolean /href = /a 0<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#action:state:state /href action /a.s<br> ∉ [// // //#/href S' /a<br>, // //#Idx:state /href Idx /a<br>, // //#/href Discard* /a<br>, // //#/href NT /a<br>, // //#/href NT* /a<br>, // //#Reduce*:state /href Reduce* /a<br>, // //#Lambda:state /href Lambda /a /block] // then /keyword s<br>// else /keyword // // let /keyword tblaction = // // //#action:state:state /href action /a.action.tbl // //#sub:seq.T:int:T /href sub /a // //#index:state:int /href index /a.s /block // let /keyword action = // // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#NT:int:state /href NT /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#NT*:int:state /href NT* /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href T /a // then /keyword // //#/href T /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#MatchAny:state /href MatchAny /a // then /keyword // //#MatchAny:int:state /href MatchAny /a.// //#index:state:int /href index /a.s<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#T':state /href T' /a // then /keyword // //#T':int:state /href T' /a.// //#index:state:int /href index /a.s<br>// else /keyword // // assert /keyword tblaction // //#=:state:state:boolean /href = /a // //#!T:state /href !T /a // report /keyword //"RemoveIdx Problem: Unexpected action in PEG table"/literal,<br>// //#!T:int:state /href !T /a.// //#index:state:int /href index /a.s, /block /block // if /keyword // //#action:state:state /href action /a.s // //#/href ∈ /a [// //#/href S' /a] // then /keyword // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#T':state /href T' /a // then /keyword action // else /keyword // //#/href S' /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#/href ∈ /a [// //#Idx:state /href Idx /a] // then /keyword // // if /keyword tblaction // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#/href NT /a.action<br>// else /keyword if tblaction // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#/href NT* /a.action<br>// else /keyword action /block // else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href Discard* /a // then /keyword // //#/href Discard* /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword // //#/href NT /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#/href NT* /a // then /keyword // //#/href NT* /a.action<br>// else /keyword if // //#action:state:state /href action /a.s // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword // //#Reduce*:int:state:state /href Reduce* /a(// //#reduceNo:state:int /href reduceNo /a.s, action)<br>// else /keyword if // //#action:state:state /href action /a.// //#nextState2:state:state /href nextState2 /a.// //#Lambda:state /href Lambda /a<br> // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword s<br>// else /keyword // //#Lambda:int:state:state /href Lambda /a(// //#reduceNo:state:int /href reduceNo /a.s, action)/block

 <p>function // %:pegpart:seq.word /id // #PEGrules /href /a %(p:pegpart) seq.word //"/sp /tag &lt;br /tag > /nsp:(part.p)"/literal

 <p>Function // replaceWords:seq.word:seq.word:seq.word /id // #PEGrules /href /a replaceWords(str:seq.word, subs:seq.word) seq.word<br>//{subs is of format w1 r1, w2 r2,... , wn rn where w1 is a word and r1 is zero or more words./sp /tag &lt;br /tag > /nsp<br>Any occurrence of wi in str is replaced with ri /sp /tag &lt;br /tag > /nsp<br>Note that commas cannot occur in ri /sp /tag &lt;br /tag > /nsp<br>If wn rn contains /1 then any word w in str not eq to one of w1.. w(n-i)is replace with wn rn with the /1 replaced by w. }/comment<br>// for /keyword d1 = 0, d2 = 0, w ∈ // //#reverse:seq.T:seq.T /href reverse /a.subs<br>// while /keyword w ∉ //","/literal<br>// do /keyword next(d1 // //#+:int:int:int /href+/a 1, // if /keyword w // //#/href ∈ /a //"/1 $"/literal // then /keyword d1 // else /keyword d2)<br>// let /keyword z = subs // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a (n.subs // //#/href-/a d1)<br>// let /keyword zidx = d1 // //#/href-/a d2<br>// let /keyword subs0 = // if /keyword d2 // //#=:int:int:boolean /href = /a 0 // then /keyword subs // //#/href+/a //","/literal // else /keyword subs // //#>>:seq.T:int:seq.T /href >> /a d1<br>// for /keyword acc = //""/literal, w ∈ str<br>// do /keyword // // for /keyword w2 = [w], replace = //""/literal, matched = false, e ∈ subs0<br>// while /keyword // //#not:boolean:boolean /href not /a.matched<br>// do /keyword // // if /keyword e // //#/href ∈ /a //","/literal // then /keyword // // if /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(replace, 1, 1) = [w] // then /keyword next(replace // //#&lt;&lt;:seq.T:int:seq.T /href &lt;&lt; /a 1, //""/literal, true)<br>// else /keyword next(w2, // if /keyword // //#isempty:seq.T:boolean /href isempty /a.replace // then /keyword //","/literal // else /keyword //""/literal, false)/block // else /keyword next(w2, replace // //#/href+/a e, false), /block acc<br> // //#/href+/a (// if /keyword d2 // //#=:int:int:boolean /href = /a 0 // //#∨:boolean:boolean:boolean /href ∨ /a matched // then /keyword w2<br>// else /keyword // //#/href replace /a(z, zidx, w)), /block acc

 <p>Function // postprocess:seq.tableEntry:seq.word:seq.tableEntry /id // #PEGrules /href /a postprocess(table:seq.tableEntry, subs:seq.word) seq.tableEntry<br>// if /keyword // //#isempty:seq.T:boolean /href isempty /a.subs // then /keyword table<br>// else /keyword // // for /keyword newtable = empty:seq.tableEntry, e ∈ table<br>// do /keyword // newtable<br> // //#/href+/a (// if /keyword action.e // //#/href ∈ /a [// //#/href T /a, // //#!T:state /href !T /a, // //#T':state /href T' /a] // then /keyword // // let /keyword m = // //#replaceWords:seq.word:seq.word:seq.word /href replaceWords /a([match.e], subs),<br>// if /keyword m = [match.e] // then /keyword e<br>// else /keyword tableEntry(action.e, m // //#sub:seq.T:int:T /href sub /a 1, Sstate.e, Fstate.e, recover.e)/block // else /keyword e), /block newtable /block

 <p>Function // isNonTerminal:word:seq.pegrule:boolean /id // #PEGrules /href /a isNonTerminal(e:word, g:seq.pegrule) boolean<br>// for /keyword // isT = e ∉ //"any Any"/literal // //#∨:boolean:boolean:boolean /href ∨ /a e // //#/href ∈ /a //"!"/literal<br>, r ∈ g /block // while /keyword isT<br>// do /keyword e ≠ leftside.r,<br>// //#not:boolean:boolean /href not /a.isT

 <p>Function // NTcount:pegpart:seq.pegrule:int /id // #PEGrules /href /a NTcount(p:pegpart, gin:seq.pegrule) int<br>// for /keyword count = 0, e ∈ part.p<br>// do /keyword // if /keyword // //#isNonTerminal:word:seq.pegrule:boolean /href isNonTerminal /a(e, gin) // then /keyword count // //#+:int:int:int /href+/a 1 // else /keyword count,<br>count

 <p>Function // %table:seq.tableEntry:seq.word /id // #PEGrules /href /a %table(t:seq.tableEntry) seq.word<br>// for /keyword acc = //""/literal, rowno = 1, a ∈ t<br>// do /keyword // next(// acc<br> // //#/href+/a (// if /keyword // //#action:state:state /href action /a.action.a // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword //"/sp /tag &lt;br /tag > /nsp:(rowno):(action.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Sstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Fstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(recover.a)/tag &lt;/td> /tag &lt;/tr> /sp /tag &lt;tr /tag > /nsp /sp /tag &lt;td /tag > /nsp"/literal<br>// else /keyword //"/sp /tag &lt;br /tag > /nsp:(rowno):(action.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(// //#escapeformat:word /href escapeformat /a):([match.a]):(// //#escapeformat:word /href escapeformat /a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Sstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(Fstate.a)/tag &lt;/td> /sp /tag &lt;td /tag > /nsp:(recover.a)/tag &lt;/td> /tag &lt;/tr>"/literal)<br>, rowno // //#+:int:int:int /href+/a 1 /block), /block //"PEG Rules:(acc)/tag &lt;/table> /sp /tag &lt;p /tag > /nsp"/literal

 <p>Function // >1:state:state:ordering /id // #PEGrules /href /a >1(a:state, b:state) ordering toint.a // //#>1:T:T:ordering /href >1 /a toint.b

 <p>Function // %:state:seq.word /id // #PEGrules /href /a %(s:state) seq.word<br>// let /keyword action = // //#action:state:state /href action /a.s,<br>// if /keyword s // //#=:state:state:boolean /href = /a // //#Match:state /href Match /a // then /keyword //"Match"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword //"Reduce.:(// //#reduceNo:state:int /href reduceNo /a.s)"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Reduce*:state /href Reduce* /a // then /keyword //"Reduce*(:(// //#reduceNo:state:int /href reduceNo /a.s),:(// //#nextState:state:state /href nextState /a.s))"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#Lambda:state /href Lambda /a // then /keyword //"Lambda(:(// //#reduceNo:state:int /href reduceNo /a.s),:(// //#nextState2:state:state /href nextState2 /a.s))"/literal<br>// else /keyword if action // //#=:state:state:boolean /href = /a // //#/href NT /a<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#action:state:state /href action /a.// //#nextState:state:state /href nextState /a.s<br> // //#=:state:state:boolean /href = /a // //#/href NT /a // then /keyword //"NT.:(// //#index:state:int /href index /a.// //#nextState:state:state /href nextState /a.s)"/literal<br>// else /keyword if action // //#/href ∈ /a [// //#/href Discard* /a, // //#/href NT /a, // //#/href S' /a] // then /keyword // // //#decode:state:seq.word /href decode /a.action<br> // //#/href+/a //"."/literal<br> // //#/href+/a // //#%:state:seq.word /href % /a.// //#nextState:state:state /href nextState /a.s /block // else /keyword if // //#index:state:int /href index /a.s // //#=:int:int:boolean /href = /a 0 // then /keyword // //#decode:state:seq.word /href decode /a.action<br>// else /keyword // // //#decode:state:seq.word /href decode /a.action<br> // //#/href+/a //"."/literal<br> // //#/href+/a // //#%:int:seq.word /href % /a.// //#index:state:int /href index /a.s /block

 <p>function // actionBits:int /id // #PEGrules /href /a actionBits int 5

 <p>function // reduceBits:int /id // #PEGrules /href /a reduceBits int 15

 <p>function // shiftIndex:int /id // #PEGrules /href /a shiftIndex int<br>// //#actionBits:int /href actionBits /a<br> // //#+:int:int:int /href+/a // //#reduceBits:int /href reduceBits /a<br> // //#+:int:int:int /href+/a // //#actionBits:int /href actionBits /a

 <p>function // state:state:int:int:state:state /id // #PEGrules /href /a state(action:state, tblidx:int, reduceNo:int, tblaction:state) state<br>//{OPTION INLINE}/comment<br>state.toint(// // //#tobits:int:bits /href tobits /a.tblidx<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a 2 // //#*:int:int:int /href * /a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.tblaction<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.reduceNo // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a // //#actionBits:int /href actionBits /a<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.action /block)

 <p>function // state:state:int:state /id // #PEGrules /href /a state(action:state, tblidx:int) state<br>state.toint(// // //#tobits:int:bits /href tobits /a.tblidx<br> // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a (// //#reduceBits:int /href reduceBits /a // //#+:int:int:int /href+/a 2 // //#*:int:int:int /href * /a // //#actionBits:int /href actionBits /a)<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.// //#action:state:state /href action /a.action /block)

 <p>Function // index:state:int /id // #PEGrules /href /a index(s:state) int<br>toint(// //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a // //#shiftIndex:int /href shiftIndex /a)

 <p>Function // reduceNo:state:int /id // #PEGrules /href /a reduceNo(s:state) int<br>toint(// // //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a // //#actionBits:int /href actionBits /a<br> // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#reduceBits:int /href reduceBits /a /block)

 <p>Function // action:state:state /id // #PEGrules /href /a action(s:state) state<br>state.toint(bits.toint.s // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#actionBits:int /href actionBits /a)

 <p>Function // NT:state:state /id // #PEGrules /href /a NT(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href NT /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // NT:int:state /id // #PEGrules /href /a NT(index:int) state // //#state:state:int:int:state:state /href state /a(// //#/href NT /a, index, 0, // //#/href NT /a)

 <p>Function // NT*:int:state /id // #PEGrules /href /a NT*(index:int) state // //#state:state:int:int:state:state /href state /a(// //#/href NT /a, index, 0, // //#/href NT /a)

 <p>Function // NT*:state:state /id // #PEGrules /href /a NT*(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href NT /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // S':state:state /id // #PEGrules /href /a S'(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href S' /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // T:int:state /id // #PEGrules /href /a T(i:int) state // //#state:state:int:state /href state /a(// //#/href T /a, i)

 <p>Function // T':int:state /id // #PEGrules /href /a T'(i:int) state // //#state:state:int:int:state:state /href state /a(// //#T':state /href T' /a, i, 0, // //#T':state /href T' /a)

 <p>Function // MatchAny:int:state /id // #PEGrules /href /a MatchAny(i:int) state // //#state:state:int:state /href state /a(// //#MatchAny:state /href MatchAny /a, i)

 <p>Function // !T:int:state /id // #PEGrules /href /a !T(i:int) state // //#state:state:int:state /href state /a(// //#!T:state /href !T /a, i)

 <p>Function // Reduce:int:state /id // #PEGrules /href /a Reduce(partno:int) state<br>// //#state:state:int:int:state:state /href state /a(// //#Reduce:state /href Reduce /a, 0, partno, state.0)

 <p>Function // Reduce*:int:state:state /id // #PEGrules /href /a Reduce*(partno:int, state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#Reduce*:state /href Reduce* /a<br>, // //#index:state:int /href index /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)

 <p>Function // Lambda:int:state:state /id // #PEGrules /href /a Lambda(partno:int, state:state) state<br>// if /keyword // //#action:state:state /href action /a.state // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword // // //#state:state:int:int:state:state /href state /a(// // //#Lambda:state /href Lambda /a<br>, // //#reduceNo:state:int /href reduceNo /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)/block // else /keyword // // //#state:state:int:int:state:state /href state /a(// // //#Lambda:state /href Lambda /a<br>, // //#index:state:int /href index /a.state<br>, partno<br>, // //#action:state:state /href action /a.state /block)/block

 <p>Function // nextState:state:state /id // #PEGrules /href /a nextState(s:state) state<br>// let /keyword k = // //#actionBits:int /href actionBits /a // //#+:int:int:int /href+/a // //#reduceBits:int /href reduceBits /a,<br>state.toint(// // //#tobits:int:bits /href tobits /a.toint.s // //#>>:bits:int:bits /href >> /a k<br> // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.// //#actionBits:int /href actionBits /a<br> // //#∨:bits:bits:bits /href ∨ /a // //#tobits:int:bits /href tobits /a.toint.s // //#∧:bits:bits:bits /href ∧ /a // //#mask:int:bits /href mask /a.k // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a k /block)

 <p>Function // nextState2:state:state /id // #PEGrules /href /a nextState2(s:state) state<br>// let /keyword t = // //#nextState:state:state /href nextState /a.s,<br>// if /keyword // //#action:state:state /href action /a.t // //#=:state:state:boolean /href = /a // //#Reduce:state /href Reduce /a // then /keyword // //#Reduce:int:state /href Reduce /a.// //#index:state:int /href index /a.s<br>// else /keyword t

 <p>Function // Discard*:state:state /id // #PEGrules /href /a Discard*(state:state) state<br>// //#state:state:int:int:state:state /href state /a(// // //#/href Discard* /a<br>, // //#index:state:int /href index /a.state<br>, 0<br>, // //#action:state:state /href action /a.state /block)

 <p>function //+:state:int:state /id // #PEGrules /href /a +(s:state, i:int) state<br>state(// toint.s<br> // //#+:int:int:int /href+/a toint(// //#tobits:int:bits /href tobits /a.i // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a // //#shiftIndex:int /href shiftIndex /a)/block)

 <p>Function // startstate:state /id // #PEGrules /href /a startstate state // //#NT:int:state /href NT /a.1

 <p>Function // Match:state /id // #PEGrules /href /a Match state // //#Reduce:state /href Reduce /a

 <p>Function // /All:seq.word /id // #PEGrules /href /a /All seq.word //"/All"/literal

 <p>The state T' is like T but does not rollback result on failure. Similarly actionP but does not rollback result on failure.

 <p>function // genEnum:seq.seq.word /id // #PEGrules /href /a genEnum seq.seq.word<br>[//"newType: state names: Failure Reduce Idx MatchAny T Fail Success* !T Discard* All Discard NT !Reduce !Fail Reduce* Lambda All* NT* S' T'"/literal]

 <p>&lt;&lt;&lt;&lt; Below is auto generated code >>>>

 <p>type state is toint:int

 <p>Export /keyword toint(state) int

 <p>Export /keyword state(i:int) state

 <p>Export /keyword type:state

 <p>Function // =:state:state:boolean /id // #PEGrules /href /a =(a:state, b:state) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>Function // Failure:state /id // #PEGrules /href /a Failure state state.0

 <p>Function // Reduce:state /id // #PEGrules /href /a Reduce state state.1

 <p>Function // Idx:state /id // #PEGrules /href /a Idx state state.2

 <p>Function // MatchAny:state /id // #PEGrules /href /a MatchAny state state.3

 <p>Function // T:state /id // #PEGrules /href /a T state state.4

 <p>Function // Fail:state /id // #PEGrules /href /a Fail state state.5

 <p>Function // Success*:state /id // #PEGrules /href /a Success* state state.6

 <p>Function // !T:state /id // #PEGrules /href /a !T state state.7

 <p>Function // Discard*:state /id // #PEGrules /href /a Discard* state state.8

 <p>Function // All:state /id // #PEGrules /href /a All state state.9

 <p>Function // Discard:state /id // #PEGrules /href /a Discard state state.10

 <p>Function // NT:state /id // #PEGrules /href /a NT state state.11

 <p>Function // !Reduce:state /id // #PEGrules /href /a !Reduce state state.12

 <p>Function // !Fail:state /id // #PEGrules /href /a !Fail state state.13

 <p>Function // Reduce*:state /id // #PEGrules /href /a Reduce* state state.14

 <p>Function // Lambda:state /id // #PEGrules /href /a Lambda state state.15

 <p>Function // All*:state /id // #PEGrules /href /a All* state state.16

 <p>Function // NT*:state /id // #PEGrules /href /a NT* state state.17

 <p>Function // S':state /id // #PEGrules /href /a S' state state.18

 <p>Function // T':state /id // #PEGrules /href /a T' state state.19

 <p>Function // decode:state:seq.word /id // #PEGrules /href /a decode(code:state) seq.word<br>// let /keyword discard = //[// // //#Failure:state /href Failure /a<br>, // //#Reduce:state /href Reduce /a<br>, // //#Idx:state /href Idx /a<br>, // //#MatchAny:state /href MatchAny /a<br>, // //#/href T /a<br>, // //#Fail:state /href Fail /a<br>, // //#Success*:state /href Success* /a<br>, // //#!T:state /href !T /a<br>, // //#/href Discard* /a<br>, // //#All:state /href All /a<br>, // //#Discard:state /href Discard /a<br>, // //#/href NT /a<br>, // //#!Reduce:state /href !Reduce /a<br>, // //#!Fail:state /href !Fail /a<br>, // //#Reduce*:state /href Reduce* /a<br>, // //#Lambda:state /href Lambda /a<br>, // //#All*:state /href All* /a<br>, // //#/href NT* /a<br>, // //#/href S' /a<br>, // //#T':state /href T' /a /block]/block // let /keyword i = toint.code,<br>// if /keyword // //#between:int:int:int:boolean /href between /a(i, 0, 19) // then /keyword // // let /keyword r = //[// //"Failure Reduce Idx MatchAny T Fail Success* !T Discard* All Discard NT !Reduce !Fail Reduce* Lambda All* NT* S' T'"/literal<br> // //#sub:seq.T:int:T /href sub /a (i // //#+:int:int:int /href+/a 1)/block], /block // if /keyword r ≠ //"?"/literal // then /keyword r // else /keyword //"state."/literal // //#/href+/a // //#toword:int:word /href toword /a.i /block // else /keyword //"state."/literal // //#/href+/a // //#toword:int:word /href toword /a.i

 <p>// // kernal /id Module /keyword kernal

 <p>Export /keyword type:boolean

 <p>Export /keyword type:char

 <p>Export /keyword toint(char) int

 <p>Export /keyword char(int) char

 <p>Export /keyword word(int) word

 <p>Export /keyword type:ordering

 <p>Export /keyword toint(ordering) int

 <p>Export /keyword type:word

 <p>Export /keyword rawvalue(word) int

 <p>type char is toint:int

 <p>type ordering is toint:int

 <p>Function // EQ:ordering /id // #kernal /href /a EQ ordering ordering.1

 <p>Function // GT:ordering /id // #kernal /href /a GT ordering ordering.2

 <p>Function // LT:ordering /id // #kernal /href /a LT ordering ordering.0

 <p>Function // =:char:char:boolean /id // #kernal /href /a =(a:char, b:char) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>Function // =:word:word:boolean /id // #kernal /href /a =(a:word, b:word) boolean<br>//{OPTION COMPILETIME}/comment<br>rawvalue.a // //#=:int:int:boolean /href = /a rawvalue.b

 <p>Function // >1:ordering:ordering:ordering /id // #kernal /href /a >1(a:ordering, b:ordering) ordering<br>//{possible results are: EQ GT LT}/comment<br>toint.a // //#>1:T:T:ordering /href >1 /a toint.b

 <p>Function // =:ordering:ordering:boolean /id // #kernal /href /a =(a:ordering, b:ordering) boolean toint.a // //#=:int:int:boolean /href = /a toint.b

 <p>---------

 <p>Builtin /keyword representation(a:real) int

 <p>Function //-:int:int /id // #kernal /href /a -(i:int) int 0 // //#/href-/a i

 <p>Builtin /keyword // >1

 <p>Builtin /keyword //+

 <p>Builtin /keyword //-

 <p>Builtin /keyword // *

 <p>Builtin /keyword // /

 <p>Builtin /keyword // =

 <p>Function // abs:int:int /id // #kernal /href /a abs(x:int) int // if /keyword x // //#&lt;:int:int:boolean /href &lt; /a 0 // then /keyword 0 // //#/href-/a x // else /keyword x

 <p>Function // mod:int:int:int /id // #kernal /href /a mod(x:int, y:int) int<br>// if /keyword x // //#&lt;:int:int:boolean /href &lt; /a 0 // then /keyword x // //#/href-/a x // //#/:int:int:int /href / /a y // //#*:int:int:int /href * /a y // //#+:int:int:int /href+/a y // else /keyword x // //#/href-/a x // //#/:int:int:int /href / /a y // //#*:int:int:int /href * /a y

 <p>Builtin /keyword // >

 <p>Function // &lt;:int:int:boolean /id // #kernal /href /a &lt;(a:int, b:int) boolean b // //#>:int:int:boolean /href > /a a

 <p>Function // between:int:int:int:boolean /id // #kernal /href /a between(i:int, lower:int, upper:int) boolean i ≥ lower // //#∧:boolean:boolean:boolean /href ∧ /a i ≤ upper

 <p>Function // sup:int:int:int /id // #kernal /href /a sup(x:int, n:int) int<br>//{* nth power of i}/comment<br>// if /keyword n // //#=:int:int:boolean /href = /a 0 // then /keyword 1<br>// else /keyword if n // //#=:int:int:boolean /href = /a 1 // then /keyword x<br>// else /keyword if n // //#=:int:int:boolean /href = /a 2 // then /keyword x // //#*:int:int:int /href * /a x<br>// else /keyword if n // //#=:int:int:boolean /href = /a 3 // then /keyword x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x<br>// else /keyword // // assert /keyword n // //#>:int:int:boolean /href > /a 3 // report /keyword //"negative powers are not implemented"/literal<br>// for /keyword // acc = x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x // //#*:int:int:int /href * /a x<br>, k = 4 /block // while /keyword k // //#&lt;:int:int:boolean /href &lt; /a n<br>// do /keyword next(acc // //#*:int:int:int /href * /a x, k // //#+:int:int:int /href+/a 1),<br>acc /block

 <p>Function // max:int:int:int /id // #kernal /href /a max(a:int, b:int) int // if /keyword a // //#>:int:int:boolean /href > /a b // then /keyword a // else /keyword b

 <p>Function // min:int:int:int /id // #kernal /href /a min(a:int, b:int) int // if /keyword a // //#&lt;:int:int:boolean /href &lt; /a b // then /keyword a // else /keyword b

 <p>--------

 <p>type boolean is tointx:int

 <p>Builtin /keyword // true

 <p>Builtin /keyword // false

 <p>Builtin /keyword // not

 <p>Builtin /keyword // =

 <p>Function // ∧:boolean:boolean:boolean /id // #kernal /href /a ∧(a:boolean, b:boolean) boolean // if /keyword a // then /keyword b // else /keyword false

 <p>Function // ∨:boolean:boolean:boolean /id // #kernal /href /a ∨(a:boolean, b:boolean) boolean // if /keyword a // then /keyword true // else /keyword b

 <p>Builtin /keyword // stacktrace

 <p>type word is rawvalue:int

 <p>-----------

 <p>Export /keyword type:timestamp

 <p>Export /keyword seconds(timestamp) int

 <p>Export /keyword timestamp(int) timestamp

 <p>type timestamp is seconds:int

 <p>// // toWords /id Module /keyword toWords

 <p>use UTF8

 <p>use bits

 <p>use seq.byte

 <p>use seq.int

 <p>use standard

 <p>use seq.word

 <p>use seq.seq.word

 <p>use seq.tblrec

 <p>use seq1.seq.word

 <p>Function // towords:UTF8:seq.word /id // #toWords /href /a towords(a:UTF8) seq.word<br>//{assumes no paragraph breaks in a}/comment<br>// let /keyword b = // //#breakparagraph:seq.byte:seq.seq.word /href breakparagraph /a.toseqbyte.a,<br>// if /keyword // //#isempty:seq.T:boolean /href isempty /a.b // then /keyword empty:seq.word // else /keyword b // //#sub:seq.T:int:T /href sub /a 1

 <p>Function // breakparagraph:seq.byte:seq.seq.word /id // #toWords /href /a breakparagraph(bytes:seq.byte) seq.seq.word<br>//{breaks file into seq of paragraphs. Paragraphs are delimited by one or blank lines.}/comment<br>// //#test:seq.byte:seq.tblrec:seq.seq.word /href test /a(bytes, // //#tableText:seq.tblrec /href tableText /a)

 <p>Function // fromHTML:seq.byte:seq.seq.word /id // #toWords /href /a fromHTML(bytes:seq.byte) seq.seq.word<br>//{input is broken into paragraphs when each paragraph is either an HTML element or is text. Paragraphs of text end with a double quote.}/comment<br>// //#test:seq.byte:seq.tblrec:seq.seq.word /href test /a(bytes, // //#tableHTML:seq.tblrec /href tableHTML /a)

 <p>type tblrec is kind:int, chr:char

 <p>function // handleCharRef:seq.char:char:seq.char /id // #toWords /href /a handleCharRef(chars:seq.char, ch:char) seq.char<br>// if /keyword ch // //#=:char:char:boolean /href = /a // //#char1:seq.word:char /href char1 /a.//";"/literal // then /keyword // // let /keyword list = // //#decodeword:word:seq.char /href decodeword /a.//"&lt;&amp;"/literal // //#sub:seq.T:int:T /href sub /a 1<br>// for /keyword // acc = empty:seq.char<br>, idx = 1<br>, e ∈ [// // //#decodeword:word:seq.char /href decodeword /a.//"&amp;lt"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#decodeword:word:seq.char /href decodeword /a.//"&amp;amp"/literal // //#sub:seq.T:int:T /href sub /a 1 /block]/block // do /keyword // // if /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(chars, n.chars // //#/href-/a n.e // //#+:int:int:int /href+/a 1, n.chars)<br> // //#=:seq.T:seq.T:boolean /href = /a e // then /keyword // next(// // //#subseq:seq.T:int:int:seq.T /href subseq /a(chars, n.e // //#+:int:int:int /href+/a 1, n.e)<br> // //#/href+/a list // //#sub:seq.T:int:T /href sub /a idx<br>, idx // //#+:int:int:int /href+/a 1 /block)/block // else /keyword next(acc, idx // //#+:int:int:int /href+/a 1), /block // if /keyword // //#isempty:seq.T:boolean /href isempty /a.acc // then /keyword chars // //#/href+/a ch // else /keyword acc /block // else /keyword chars // //#/href+/a ch

 <p>function // test:seq.byte:seq.tblrec:seq.seq.word /id // #toWords /href /a test(bytes:seq.byte, classify:seq.tblrec) seq.seq.word<br>// let /keyword period/colon = 1<br>//{period or colon is pending waiting for next character}/comment<br>// for /keyword // tag = false<br>, state0 = 0<br>, paragraph0 = empty:seq.seq.word<br>, chars0 = empty:seq.char<br>, gather = bits.0<br>, expect = 0<br>, words0 = //""/literal<br>, b ∈ bytes // //#/href+/a // //#tobyte:int:byte /href tobyte /a.32 /block // do /keyword // // let /keyword tabrec = classify // //#sub:seq.T:int:T /href sub /a (// //#toint:byte:int /href toint /a.b // //#+:int:int:int /href+/a 1)<br>// let /keyword bits = // //#tobits:int:bits /href tobits /a.// //#toint:byte:int /href toint /a.b<br>// let /keyword kind = kind.tabrec<br>// let /keyword ch = chr.tabrec,<br>// for /keyword state = state0, paragraph = paragraph0, words = words0, chars = chars0, e ∈ [1]<br>// do /keyword //{???? make sure this for does not use loop in final code.}<br>// if /keyword state // //#=:int:int:boolean /href = /a 0 // then /keyword next(state, paragraph, words, chars)<br>// else /keyword if state // //#=:int:int:boolean /href = /a period/colon // then /keyword // // let /keyword newwords = // // //#encodeword:seq.char:word /href encodeword /a(chars0 // //#/href+/a (// if /keyword ch // //#=:char:char:boolean /href = /a {space}char.32 // then /keyword [char.32] // else /keyword empty:seq.char)), /block next(0, paragraph, words // //#/href+/a newwords, empty:seq.char)/block // else /keyword if state // //#=:int:int:boolean /href = /a 2 // then /keyword //{found first LF and looking for second LF}<br>// let /keyword newstate = // // if /keyword kind // //#=:int:int:boolean /href = /a // //#Space:int /href Space /a // then /keyword // if /keyword ch // //#=:char:char:boolean /href = /a {LF}char.10 // then /keyword 3 // else /keyword 2<br>// else /keyword 0, /block next(newstate, paragraph, words, chars)/block // else /keyword // // assert /keyword state // //#=:int:int:boolean /href = /a 3 // report /keyword //"State problem"/literal,<br>// if /keyword kind // //#=:int:int:boolean /href = /a // //#Space:int /href Space /a // then /keyword{remain in state 3}next(state, paragraph, words, chars)<br>// else /keyword //{finish paragraph}<br>next(// 0<br>, // if /keyword // //#isempty:seq.T:boolean /href isempty /a.words // then /keyword paragraph<br>// else /keyword paragraph // //#/href+/a [words]<br>, //""/literal<br>, chars /block), /block /block /block // if /keyword kind // //#=:int:int:boolean /href = /a // //#Char&amp;&lt;:int /href Char&amp;&lt; /a // then /keyword //{starting a tag}<br>// let /keyword newwords = // // if /keyword n.chars // //#=:int:int:boolean /href = /a 0 // then /keyword words<br>// else /keyword words // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.chars, /block // if /keyword ch // //#=:char:char:boolean /href = /a // //#char1:seq.word:char /href char1 /a.//">"/literal // then /keyword //{assert ch ∈(decodeword."&lt;!doctypehml"sub 1+char.32)report"ch:(tag)"+encodeword.[ch]}<br>// if /keyword tag // then /keyword // // let /keyword newpara = // paragraph<br> // //#/href+/a (// if /keyword // //#subseq:seq.T:int:int:seq.T /href subseq /a(chars, 1, 2)<br> // //#=:seq.T:seq.T:boolean /href = /a // //#decodeword:word:seq.char /href decodeword /a.//"&lt;/"/literal // //#sub:seq.T:int:T /href sub /a 1 // then /keyword[words] // //#/href+/a [// //#encodeword:seq.char:word /href encodeword /a(chars // //#/href+/a ch)]<br>// else /keyword [words] // //#/href+/a [[// //#encodeword:seq.char:word /href encodeword /a.chars] // //#/href+/a //">"/literal]), /block next(false, state, newpara, empty:seq.char, bits.0, 0, //""/literal)/block // else /keyword if // //#isempty:seq.T:boolean /href isempty /a.words<br> // //#∨:boolean:boolean:boolean /href ∨ /a // //#char1:seq.word:char /href char1 /a.words ≠ // //#char1:seq.word:char /href char1 /a.//"&lt;"/literal // then /keyword //{???? A more general solution is needed to determine whether a '>' marks the end of an element tag. Does not handle the case where the first word of text is a less than.}<br>next(false, 0, paragraph, chars // //#/href+/a ch, bits.0, 0, words)/block // else /keyword // // let /keyword newpara = // paragraph // //#/href+/a [words // //#/href+/a [// //#encodeword:seq.char:word /href encodeword /a.chars] // //#/href+/a //">"/literal], /block next(false, 0, newpara, empty:seq.char, bits.0, 0, //""/literal)/block /block // else /keyword if ch // //#=:char:char:boolean /href = /a // //#char1:seq.word:char /href char1 /a.//"&lt;"/literal<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#not:boolean:boolean /href not /a.// //#isempty:seq.T:boolean /href isempty /a.newwords<br> // //#∧:boolean:boolean:boolean /href ∧ /a // //#last:seq.T:T /href last /a.newwords ∉ //">"/literal // then /keyword next(true, 0, paragraph // //#/href+/a [newwords // //#/href+/a // //#/href dq /a], [ch], bits.0, 0, //""/literal)<br>// else /keyword next(true, 0, paragraph, [ch], bits.0, 0, newwords)/block // else /keyword if kind // //#=:int:int:boolean /href = /a // //#Space:int /href Space /a // then /keyword // // if /keyword tag // then /keyword // // let /keyword newpara = // paragraph<br> // //#/href+/a (// if /keyword // //#isempty:seq.T:boolean /href isempty /a.words0 // then /keyword empty:seq.seq.word<br>// else /keyword [words0]), /block next(// false<br>, state<br>, newpara<br>, empty:seq.char<br>, bits.0<br>, 0<br>, [// //#encodeword:seq.char:word /href encodeword /a.chars]/block)/block // else /keyword // // let /keyword newwords = // // if /keyword n.chars // //#=:int:int:boolean /href = /a 0 // then /keyword words<br>// else /keyword words // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.chars /block // let /keyword newstate = // // if /keyword ch // //#=:char:char:boolean /href = /a {LF}char.10 // //#∧:boolean:boolean:boolean /href ∧ /a state // //#=:int:int:boolean /href = /a 0 // then /keyword 2<br>// else /keyword state, /block next(tag, newstate, paragraph, empty:seq.char, bits.0, 0, newwords)/block /block // else /keyword if kind // //#=:int:int:boolean /href = /a 0 // then /keyword // // if /keyword tag // then /keyword // next(// ch ≠ // //#char1:seq.word:char /href char1 /a.//";"/literal<br>, 0<br>, paragraph<br>, // //#handleCharRef:seq.char:char:seq.char /href handleCharRef /a(chars, ch)<br>, bits.0<br>, 0<br>, words /block)/block // else /keyword next(tag, 0, paragraph, chars // //#/href+/a ch, bits.0, 0, words)/block // else /keyword if kind // //#=:int:int:boolean /href = /a // //#ThreeByte:int /href ThreeByte /a // then /keyword next(tag, 0, paragraph, chars, 0xF // //#∧:bits:bits:bits /href ∧ /a bits, 2, words)<br>// else /keyword if kind // //#=:int:int:boolean /href = /a // //#TwoByte:int /href TwoByte /a // then /keyword next(tag, 0, paragraph, chars, 0x1F // //#∧:bits:bits:bits /href ∧ /a bits, 1, words)<br>// else /keyword if kind // //#=:int:int:boolean /href = /a // //#FourByte:int /href FourByte /a // then /keyword next(tag, 0, paragraph, chars, 0x7 // //#∧:bits:bits:bits /href ∧ /a bits, 3, words)<br>// else /keyword if kind // //#=:int:int:boolean /href = /a // //#More:int /href More /a // then /keyword // // let /keyword newbits = gather // //#&lt;&lt;:bits:int:bits /href &lt;&lt; /a 6 // //#∨:bits:bits:bits /href ∨ /a 0x3F // //#∧:bits:bits:bits /href ∧ /a bits,<br>// if /keyword expect // //#=:int:int:boolean /href = /a 1 // then /keyword next(tag, 0, paragraph, chars // //#/href+/a char.toint.newbits, bits.0, 0, words)<br>// else /keyword // // assert /keyword expect // //#>:int:int:boolean /href > /a 0 // report /keyword //"error"/literal,<br>next(tag, 0, paragraph, chars, newbits, expect // //#/href-/a 1, words)/block /block // else /keyword if kind // //#=:int:int:boolean /href = /a // //#StandAlone:int /href StandAlone /a // then /keyword // // let /keyword newwords = // // if /keyword n.chars // //#=:int:int:boolean /href = /a 0 // then /keyword words<br>// else /keyword words // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.chars, /block next(// tag<br>, 0<br>, paragraph<br>, empty:seq.char<br>, bits.0<br>, 0<br>, newwords // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.[ch]/block)/block // else /keyword if kind // //#=:int:int:boolean /href = /a // //#Period:int /href Period /a // then /keyword // // let /keyword newwords = // // if /keyword n.chars // //#=:int:int:boolean /href = /a 0 // then /keyword words<br>// else /keyword words // //#/href+/a // //#encodeword:seq.char:word /href encodeword /a.chars, /block next(tag, period/colon, paragraph, [ch], bits.0, 0, newwords)/block // else /keyword // // assert /keyword false // report /keyword //"kind:(kind)"/literal,<br>next(tag, 0, paragraph, chars, bits.0, 0, words), /block /block // if /keyword // //#isempty:seq.T:boolean /href isempty /a.words0 // then /keyword paragraph0<br>// else /keyword // // let /keyword html = // kind.classify // //#sub:seq.T:int:T /href sub /a (toint.// //#char1:seq.word:char /href char1 /a.//"&lt;"/literal // //#+:int:int:int /href+/a 1)<br> // //#=:int:int:boolean /href = /a // //#Char&amp;&lt;:int /href Char&amp;&lt; /a, /block paragraph0 // //#/href+/a [// if /keyword html // then /keyword words0 // //#/href+/a // //#/href dq /a // else /keyword words0]/block

 <p>function // Invalid:int /id // #toWords /href /a Invalid int 1

 <p>function // More:int /id // #toWords /href /a More int 2

 <p>function // TwoByte:int /id // #toWords /href /a TwoByte int 3

 <p>function // ThreeByte:int /id // #toWords /href /a ThreeByte int 4

 <p>function // FourByte:int /id // #toWords /href /a FourByte int 5

 <p>function // StandAlone:int /id // #toWords /href /a StandAlone int 6

 <p>function // Space:int /id // #toWords /href /a Space int 7

 <p>function // Period:int /id // #toWords /href /a Period int 8

 <p>function // Char&amp;&lt;:int /id // #toWords /href /a Char&amp;&lt; int 9

 <p>function // tableHTML:seq.tblrec /id // #toWords /href /a tableHTML seq.tblrec<br>//{auto generated}/comment<br>[//{00}tblrec(0, char.0)<br>, {01}tblrec(0, char.1)<br>, {02}tblrec(0, char.2)<br>, {03}tblrec(0, char.3)<br>, {04}tblrec(0, char.4)<br>, {05}tblrec(0, char.5)<br>, {06}tblrec(0, char.6)<br>, {07}tblrec(0, char.7)<br>, {08}tblrec(0, char.8)<br>, {09}tblrec(0, char.9)<br>, {0A}tblrec(// //#Space:int /href Space /a, char.10)<br>, {0B}tblrec(0, char.11)<br>, {0C}tblrec(0, char.12)<br>, {0D}tblrec(// //#Space:int /href Space /a, char.13)<br>, {0E}tblrec(0, char.14)<br>, {0F}tblrec(0, char.15)<br>, {10}tblrec(0, char.16)<br>, {11}tblrec(0, char.17)<br>, {12}tblrec(0, char.18)<br>, {13}tblrec(0, char.19)<br>, {14}tblrec(0, char.20)<br>, {15}tblrec(0, char.21)<br>, {16}tblrec(0, char.22)<br>, {17}tblrec(0, char.23)<br>, {18}tblrec(0, char.24)<br>, {19}tblrec(0, char.25)<br>, {1A}tblrec(0, char.26)<br>, {1B}tblrec(0, char.27)<br>, {1C}tblrec(0, char.28)<br>, {1D}tblrec(0, char.29)<br>, {1E}tblrec(0, char.30)<br>, {1F}tblrec(0, char.31)<br>, {20}tblrec(// //#Space:int /href Space /a, char.32)<br>, {21}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"!"/literal)<br>, {22}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.// //#/href dq /a)<br>, {23}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"#"/literal)<br>, {24}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"$"/literal)<br>, {25}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"%"/literal)<br>, {26}tblrec(// //#Char&amp;&lt;:int /href Char&amp;&lt; /a, // //#char1:seq.word:char /href char1 /a.//"&amp;"/literal)<br>, {27}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"'"/literal)<br>, {28}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"("/literal)<br>, {29}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//")"/literal)<br>, {2A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"*"/literal)<br>, {2B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"+"/literal)<br>, {2C}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//","/literal)<br>, {2D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"-"/literal)<br>, {2E}tblrec(// //#Period:int /href Period /a, // //#char1:seq.word:char /href char1 /a.//"."/literal)<br>, {2F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"/"/literal)<br>, {30}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"0"/literal)<br>, {31}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"1"/literal)<br>, {32}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"2"/literal)<br>, {33}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"3"/literal)<br>, {34}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"4"/literal)<br>, {35}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"5"/literal)<br>, {36}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"6"/literal)<br>, {37}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"7"/literal)<br>, {38}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"8"/literal)<br>, {39}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"9"/literal)<br>, {3A}tblrec(// //#Period:int /href Period /a, // //#char1:seq.word:char /href char1 /a.//":"/literal)<br>, {3B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//";"/literal)<br>, {3C}tblrec(// //#Char&amp;&lt;:int /href Char&amp;&lt; /a, // //#char1:seq.word:char /href char1 /a.//"&lt;"/literal)<br>, {3D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"="/literal)<br>, {3E}tblrec(// //#Char&amp;&lt;:int /href Char&amp;&lt; /a, // //#char1:seq.word:char /href char1 /a.//">"/literal)<br>, {3F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"?"/literal)<br>, {40}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"@"/literal)<br>, {41}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"A"/literal)<br>, {42}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"B"/literal)<br>, {43}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"C"/literal)<br>, {44}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"D"/literal)<br>, {45}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"E"/literal)<br>, {46}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"F"/literal)<br>, {47}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"G"/literal)<br>, {48}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"H"/literal)<br>, {49}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"I"/literal)<br>, {4A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"J"/literal)<br>, {4B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"K"/literal)<br>, {4C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"L"/literal)<br>, {4D}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"M"/literal)<br>, {4E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"N"/literal)<br>, {4F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"O"/literal)<br>, {50}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"P"/literal)<br>, {51}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Q"/literal)<br>, {52}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"R"/literal)<br>, {53}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"S"/literal)<br>, {54}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"T"/literal)<br>, {55}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"U"/literal)<br>, {56}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"V"/literal)<br>, {57}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"W"/literal)<br>, {58}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"X"/literal)<br>, {59}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Y"/literal)<br>, {5A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Z"/literal)<br>, {5B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"["/literal)<br>, {5C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"\"/literal)<br>, {5D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"]"/literal)<br>, {5E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"^"/literal)<br>, {5F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"_"/literal)<br>, {60}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"`"/literal)<br>, {61}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"a"/literal)<br>, {62}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"b"/literal)<br>, {63}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"c"/literal)<br>, {64}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"d"/literal)<br>, {65}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"e"/literal)<br>, {66}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"f"/literal)<br>, {67}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"g"/literal)<br>, {68}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"h"/literal)<br>, {69}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"i"/literal)<br>, {6A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"j"/literal)<br>, {6B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"k"/literal)<br>, {6C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"l"/literal)<br>, {6D}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"m"/literal)<br>, {6E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"n"/literal)<br>, {6F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"o"/literal)<br>, {70}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"p"/literal)<br>, {71}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"q"/literal)<br>, {72}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"r"/literal)<br>, {73}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"s"/literal)<br>, {74}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"t"/literal)<br>, {75}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"u"/literal)<br>, {76}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"v"/literal)<br>, {77}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"w"/literal)<br>, {78}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"x"/literal)<br>, {79}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"y"/literal)<br>, {7A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"z"/literal)<br>, {7B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"{"/literal)<br>, {7C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"|"/literal)<br>, {7D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"}"/literal)<br>, {7E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"~"/literal)<br>, {7F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//""/literal)<br>, {80}tblrec(// //#More:int /href More /a, char.128)<br>, {81}tblrec(// //#More:int /href More /a, char.129)<br>, {82}tblrec(// //#More:int /href More /a, char.130)<br>, {83}tblrec(// //#More:int /href More /a, char.131)<br>, {84}tblrec(// //#More:int /href More /a, char.132)<br>, {85}tblrec(// //#More:int /href More /a, char.133)<br>, {86}tblrec(// //#More:int /href More /a, char.134)<br>, {87}tblrec(// //#More:int /href More /a, char.135)<br>, {88}tblrec(// //#More:int /href More /a, char.136)<br>, {89}tblrec(// //#More:int /href More /a, char.137)<br>, {8A}tblrec(// //#More:int /href More /a, char.138)<br>, {8B}tblrec(// //#More:int /href More /a, char.139)<br>, {8C}tblrec(// //#More:int /href More /a, char.140)<br>, {8D}tblrec(// //#More:int /href More /a, char.141)<br>, {8E}tblrec(// //#More:int /href More /a, char.142)<br>, {8F}tblrec(// //#More:int /href More /a, char.143)<br>, {90}tblrec(// //#More:int /href More /a, char.144)<br>, {91}tblrec(// //#More:int /href More /a, char.145)<br>, {92}tblrec(// //#More:int /href More /a, char.146)<br>, {93}tblrec(// //#More:int /href More /a, char.147)<br>, {94}tblrec(// //#More:int /href More /a, char.148)<br>, {95}tblrec(// //#More:int /href More /a, char.149)<br>, {96}tblrec(// //#More:int /href More /a, char.150)<br>, {97}tblrec(// //#More:int /href More /a, char.151)<br>, {98}tblrec(// //#More:int /href More /a, char.152)<br>, {99}tblrec(// //#More:int /href More /a, char.153)<br>, {9A}tblrec(// //#More:int /href More /a, char.154)<br>, {9B}tblrec(// //#More:int /href More /a, char.155)<br>, {9C}tblrec(// //#More:int /href More /a, char.156)<br>, {9D}tblrec(// //#More:int /href More /a, char.157)<br>, {9E}tblrec(// //#More:int /href More /a, char.158)<br>, {9F}tblrec(// //#More:int /href More /a, char.159)<br>, {A0}tblrec(// //#More:int /href More /a, char.160)<br>, {A1}tblrec(// //#More:int /href More /a, char.161)<br>, {A2}tblrec(// //#More:int /href More /a, char.162)<br>, {A3}tblrec(// //#More:int /href More /a, char.163)<br>, {A4}tblrec(// //#More:int /href More /a, char.164)<br>, {A5}tblrec(// //#More:int /href More /a, char.165)<br>, {A6}tblrec(// //#More:int /href More /a, char.166)<br>, {A7}tblrec(// //#More:int /href More /a, char.167)<br>, {A8}tblrec(// //#More:int /href More /a, char.168)<br>, {A9}tblrec(// //#More:int /href More /a, char.169)<br>, {AA}tblrec(// //#More:int /href More /a, char.170)<br>, {AB}tblrec(// //#More:int /href More /a, char.171)<br>, {AC}tblrec(// //#More:int /href More /a, char.172)<br>, {AD}tblrec(// //#More:int /href More /a, char.173)<br>, {AE}tblrec(// //#More:int /href More /a, char.174)<br>, {AF}tblrec(// //#More:int /href More /a, char.175)<br>, {B0}tblrec(// //#More:int /href More /a, char.176)<br>, {B1}tblrec(// //#More:int /href More /a, char.177)<br>, {B2}tblrec(// //#More:int /href More /a, char.178)<br>, {B3}tblrec(// //#More:int /href More /a, char.179)<br>, {B4}tblrec(// //#More:int /href More /a, char.180)<br>, {B5}tblrec(// //#More:int /href More /a, char.181)<br>, {B6}tblrec(// //#More:int /href More /a, char.182)<br>, {B7}tblrec(// //#More:int /href More /a, char.183)<br>, {B8}tblrec(// //#More:int /href More /a, char.184)<br>, {B9}tblrec(// //#More:int /href More /a, char.185)<br>, {BA}tblrec(// //#More:int /href More /a, char.186)<br>, {BB}tblrec(// //#More:int /href More /a, char.187)<br>, {BC}tblrec(// //#More:int /href More /a, char.188)<br>, {BD}tblrec(// //#More:int /href More /a, char.189)<br>, {BE}tblrec(// //#More:int /href More /a, char.190)<br>, {BF}tblrec(// //#More:int /href More /a, char.191)<br>, {C0}tblrec(// //#TwoByte:int /href TwoByte /a, char.192)<br>, {C1}tblrec(// //#TwoByte:int /href TwoByte /a, char.193)<br>, {C2}tblrec(// //#TwoByte:int /href TwoByte /a, char.194)<br>, {C3}tblrec(// //#TwoByte:int /href TwoByte /a, char.195)<br>, {C4}tblrec(// //#TwoByte:int /href TwoByte /a, char.196)<br>, {C5}tblrec(// //#TwoByte:int /href TwoByte /a, char.197)<br>, {C6}tblrec(// //#TwoByte:int /href TwoByte /a, char.198)<br>, {C7}tblrec(// //#TwoByte:int /href TwoByte /a, char.199)<br>, {C8}tblrec(// //#TwoByte:int /href TwoByte /a, char.200)<br>, {C9}tblrec(// //#TwoByte:int /href TwoByte /a, char.201)<br>, {CA}tblrec(// //#TwoByte:int /href TwoByte /a, char.202)<br>, {CB}tblrec(// //#TwoByte:int /href TwoByte /a, char.203)<br>, {CC}tblrec(// //#TwoByte:int /href TwoByte /a, char.204)<br>, {CD}tblrec(// //#TwoByte:int /href TwoByte /a, char.205)<br>, {CE}tblrec(// //#TwoByte:int /href TwoByte /a, char.206)<br>, {CF}tblrec(// //#TwoByte:int /href TwoByte /a, char.207)<br>, {D0}tblrec(// //#TwoByte:int /href TwoByte /a, char.208)<br>, {D1}tblrec(// //#TwoByte:int /href TwoByte /a, char.209)<br>, {D2}tblrec(// //#TwoByte:int /href TwoByte /a, char.210)<br>, {D3}tblrec(// //#TwoByte:int /href TwoByte /a, char.211)<br>, {D4}tblrec(// //#TwoByte:int /href TwoByte /a, char.212)<br>, {D5}tblrec(// //#TwoByte:int /href TwoByte /a, char.213)<br>, {D6}tblrec(// //#TwoByte:int /href TwoByte /a, char.214)<br>, {D7}tblrec(// //#TwoByte:int /href TwoByte /a, char.215)<br>, {D8}tblrec(// //#TwoByte:int /href TwoByte /a, char.216)<br>, {D9}tblrec(// //#TwoByte:int /href TwoByte /a, char.217)<br>, {DA}tblrec(// //#TwoByte:int /href TwoByte /a, char.218)<br>, {DB}tblrec(// //#TwoByte:int /href TwoByte /a, char.219)<br>, {DC}tblrec(// //#TwoByte:int /href TwoByte /a, char.220)<br>, {DD}tblrec(// //#TwoByte:int /href TwoByte /a, char.221)<br>, {DE}tblrec(// //#TwoByte:int /href TwoByte /a, char.222)<br>, {DF}tblrec(// //#TwoByte:int /href TwoByte /a, char.223)<br>, {E0}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.224)<br>, {E1}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.225)<br>, {E2}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.226)<br>, {E3}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.227)<br>, {E4}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.228)<br>, {E5}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.229)<br>, {E6}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.230)<br>, {E7}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.231)<br>, {E8}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.232)<br>, {E9}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.233)<br>, {EA}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.234)<br>, {EB}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.235)<br>, {EC}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.236)<br>, {ED}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.237)<br>, {EE}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.238)<br>, {EF}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.239)<br>, {F0}tblrec(// //#FourByte:int /href FourByte /a, char.240)<br>, {F1}tblrec(// //#FourByte:int /href FourByte /a, char.241)<br>, {F2}tblrec(// //#FourByte:int /href FourByte /a, char.242)<br>, {F3}tblrec(// //#FourByte:int /href FourByte /a, char.243)<br>, {F4}tblrec(// //#FourByte:int /href FourByte /a, char.244)<br>, {F5}tblrec(// //#FourByte:int /href FourByte /a, char.245)<br>, {F6}tblrec(// //#FourByte:int /href FourByte /a, char.246)<br>, {F7}tblrec(// //#FourByte:int /href FourByte /a, char.247)<br>, {F8}tblrec(// //#Invalid:int /href Invalid /a, char.248)<br>, {F9}tblrec(// //#Invalid:int /href Invalid /a, char.249)<br>, {FA}tblrec(// //#Invalid:int /href Invalid /a, char.250)<br>, {FB}tblrec(// //#Invalid:int /href Invalid /a, char.251)<br>, {FC}tblrec(// //#Invalid:int /href Invalid /a, char.252)<br>, {FD}tblrec(// //#Invalid:int /href Invalid /a, char.253)<br>, {FE}tblrec(// //#Invalid:int /href Invalid /a, char.254)<br>, {FF}tblrec(// //#Invalid:int /href Invalid /a, char.255)/block]

 <p>function // tableText:seq.tblrec /id // #toWords /href /a tableText seq.tblrec<br>//{auto generated}/comment<br>[//{00}tblrec(0, char.0)<br>, {01}tblrec(0, char.1)<br>, {02}tblrec(0, char.2)<br>, {03}tblrec(0, char.3)<br>, {04}tblrec(0, char.4)<br>, {05}tblrec(0, char.5)<br>, {06}tblrec(0, char.6)<br>, {07}tblrec(0, char.7)<br>, {08}tblrec(0, char.8)<br>, {09}tblrec(0, char.9)<br>, {0A}tblrec(// //#Space:int /href Space /a, char.10)<br>, {0B}tblrec(0, char.11)<br>, {0C}tblrec(0, char.12)<br>, {0D}tblrec(// //#Space:int /href Space /a, char.13)<br>, {0E}tblrec(0, char.14)<br>, {0F}tblrec(0, char.15)<br>, {10}tblrec(0, char.16)<br>, {11}tblrec(0, char.17)<br>, {12}tblrec(0, char.18)<br>, {13}tblrec(0, char.19)<br>, {14}tblrec(0, char.20)<br>, {15}tblrec(0, char.21)<br>, {16}tblrec(0, char.22)<br>, {17}tblrec(0, char.23)<br>, {18}tblrec(0, char.24)<br>, {19}tblrec(0, char.25)<br>, {1A}tblrec(0, char.26)<br>, {1B}tblrec(0, char.27)<br>, {1C}tblrec(0, char.28)<br>, {1D}tblrec(0, char.29)<br>, {1E}tblrec(0, char.30)<br>, {1F}tblrec(0, char.31)<br>, {20}tblrec(// //#Space:int /href Space /a, char.32)<br>, {21}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"!"/literal)<br>, {22}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.// //#/href dq /a)<br>, {23}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"#"/literal)<br>, {24}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"$"/literal)<br>, {25}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"%"/literal)<br>, {26}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"&amp;"/literal)<br>, {27}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"'"/literal)<br>, {28}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"("/literal)<br>, {29}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//")"/literal)<br>, {2A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"*"/literal)<br>, {2B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"+"/literal)<br>, {2C}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//","/literal)<br>, {2D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"-"/literal)<br>, {2E}tblrec(// //#Period:int /href Period /a, // //#char1:seq.word:char /href char1 /a.//"."/literal)<br>, {2F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"/"/literal)<br>, {30}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"0"/literal)<br>, {31}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"1"/literal)<br>, {32}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"2"/literal)<br>, {33}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"3"/literal)<br>, {34}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"4"/literal)<br>, {35}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"5"/literal)<br>, {36}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"6"/literal)<br>, {37}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"7"/literal)<br>, {38}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"8"/literal)<br>, {39}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"9"/literal)<br>, {3A}tblrec(// //#Period:int /href Period /a, // //#char1:seq.word:char /href char1 /a.//":"/literal)<br>, {3B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//";"/literal)<br>, {3C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"&lt;"/literal)<br>, {3D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"="/literal)<br>, {3E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//">"/literal)<br>, {3F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"?"/literal)<br>, {40}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"@"/literal)<br>, {41}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"A"/literal)<br>, {42}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"B"/literal)<br>, {43}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"C"/literal)<br>, {44}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"D"/literal)<br>, {45}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"E"/literal)<br>, {46}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"F"/literal)<br>, {47}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"G"/literal)<br>, {48}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"H"/literal)<br>, {49}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"I"/literal)<br>, {4A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"J"/literal)<br>, {4B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"K"/literal)<br>, {4C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"L"/literal)<br>, {4D}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"M"/literal)<br>, {4E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"N"/literal)<br>, {4F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"O"/literal)<br>, {50}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"P"/literal)<br>, {51}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Q"/literal)<br>, {52}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"R"/literal)<br>, {53}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"S"/literal)<br>, {54}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"T"/literal)<br>, {55}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"U"/literal)<br>, {56}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"V"/literal)<br>, {57}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"W"/literal)<br>, {58}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"X"/literal)<br>, {59}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Y"/literal)<br>, {5A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"Z"/literal)<br>, {5B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"["/literal)<br>, {5C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"\"/literal)<br>, {5D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"]"/literal)<br>, {5E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"^"/literal)<br>, {5F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"_"/literal)<br>, {60}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"`"/literal)<br>, {61}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"a"/literal)<br>, {62}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"b"/literal)<br>, {63}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"c"/literal)<br>, {64}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"d"/literal)<br>, {65}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"e"/literal)<br>, {66}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"f"/literal)<br>, {67}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"g"/literal)<br>, {68}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"h"/literal)<br>, {69}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"i"/literal)<br>, {6A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"j"/literal)<br>, {6B}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"k"/literal)<br>, {6C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"l"/literal)<br>, {6D}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"m"/literal)<br>, {6E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"n"/literal)<br>, {6F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"o"/literal)<br>, {70}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"p"/literal)<br>, {71}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"q"/literal)<br>, {72}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"r"/literal)<br>, {73}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"s"/literal)<br>, {74}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"t"/literal)<br>, {75}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"u"/literal)<br>, {76}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"v"/literal)<br>, {77}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"w"/literal)<br>, {78}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"x"/literal)<br>, {79}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"y"/literal)<br>, {7A}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"z"/literal)<br>, {7B}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"{"/literal)<br>, {7C}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"|"/literal)<br>, {7D}<br>tblrec(// //#StandAlone:int /href StandAlone /a, // //#char1:seq.word:char /href char1 /a.//"}"/literal)<br>, {7E}tblrec(0, // //#char1:seq.word:char /href char1 /a.//"~"/literal)<br>, {7F}tblrec(0, // //#char1:seq.word:char /href char1 /a.//""/literal)<br>, {80}tblrec(// //#More:int /href More /a, char.128)<br>, {81}tblrec(// //#More:int /href More /a, char.129)<br>, {82}tblrec(// //#More:int /href More /a, char.130)<br>, {83}tblrec(// //#More:int /href More /a, char.131)<br>, {84}tblrec(// //#More:int /href More /a, char.132)<br>, {85}tblrec(// //#More:int /href More /a, char.133)<br>, {86}tblrec(// //#More:int /href More /a, char.134)<br>, {87}tblrec(// //#More:int /href More /a, char.135)<br>, {88}tblrec(// //#More:int /href More /a, char.136)<br>, {89}tblrec(// //#More:int /href More /a, char.137)<br>, {8A}tblrec(// //#More:int /href More /a, char.138)<br>, {8B}tblrec(// //#More:int /href More /a, char.139)<br>, {8C}tblrec(// //#More:int /href More /a, char.140)<br>, {8D}tblrec(// //#More:int /href More /a, char.141)<br>, {8E}tblrec(// //#More:int /href More /a, char.142)<br>, {8F}tblrec(// //#More:int /href More /a, char.143)<br>, {90}tblrec(// //#More:int /href More /a, char.144)<br>, {91}tblrec(// //#More:int /href More /a, char.145)<br>, {92}tblrec(// //#More:int /href More /a, char.146)<br>, {93}tblrec(// //#More:int /href More /a, char.147)<br>, {94}tblrec(// //#More:int /href More /a, char.148)<br>, {95}tblrec(// //#More:int /href More /a, char.149)<br>, {96}tblrec(// //#More:int /href More /a, char.150)<br>, {97}tblrec(// //#More:int /href More /a, char.151)<br>, {98}tblrec(// //#More:int /href More /a, char.152)<br>, {99}tblrec(// //#More:int /href More /a, char.153)<br>, {9A}tblrec(// //#More:int /href More /a, char.154)<br>, {9B}tblrec(// //#More:int /href More /a, char.155)<br>, {9C}tblrec(// //#More:int /href More /a, char.156)<br>, {9D}tblrec(// //#More:int /href More /a, char.157)<br>, {9E}tblrec(// //#More:int /href More /a, char.158)<br>, {9F}tblrec(// //#More:int /href More /a, char.159)<br>, {A0}tblrec(// //#More:int /href More /a, char.160)<br>, {A1}tblrec(// //#More:int /href More /a, char.161)<br>, {A2}tblrec(// //#More:int /href More /a, char.162)<br>, {A3}tblrec(// //#More:int /href More /a, char.163)<br>, {A4}tblrec(// //#More:int /href More /a, char.164)<br>, {A5}tblrec(// //#More:int /href More /a, char.165)<br>, {A6}tblrec(// //#More:int /href More /a, char.166)<br>, {A7}tblrec(// //#More:int /href More /a, char.167)<br>, {A8}tblrec(// //#More:int /href More /a, char.168)<br>, {A9}tblrec(// //#More:int /href More /a, char.169)<br>, {AA}tblrec(// //#More:int /href More /a, char.170)<br>, {AB}tblrec(// //#More:int /href More /a, char.171)<br>, {AC}tblrec(// //#More:int /href More /a, char.172)<br>, {AD}tblrec(// //#More:int /href More /a, char.173)<br>, {AE}tblrec(// //#More:int /href More /a, char.174)<br>, {AF}tblrec(// //#More:int /href More /a, char.175)<br>, {B0}tblrec(// //#More:int /href More /a, char.176)<br>, {B1}tblrec(// //#More:int /href More /a, char.177)<br>, {B2}tblrec(// //#More:int /href More /a, char.178)<br>, {B3}tblrec(// //#More:int /href More /a, char.179)<br>, {B4}tblrec(// //#More:int /href More /a, char.180)<br>, {B5}tblrec(// //#More:int /href More /a, char.181)<br>, {B6}tblrec(// //#More:int /href More /a, char.182)<br>, {B7}tblrec(// //#More:int /href More /a, char.183)<br>, {B8}tblrec(// //#More:int /href More /a, char.184)<br>, {B9}tblrec(// //#More:int /href More /a, char.185)<br>, {BA}tblrec(// //#More:int /href More /a, char.186)<br>, {BB}tblrec(// //#More:int /href More /a, char.187)<br>, {BC}tblrec(// //#More:int /href More /a, char.188)<br>, {BD}tblrec(// //#More:int /href More /a, char.189)<br>, {BE}tblrec(// //#More:int /href More /a, char.190)<br>, {BF}tblrec(// //#More:int /href More /a, char.191)<br>, {C0}tblrec(// //#TwoByte:int /href TwoByte /a, char.192)<br>, {C1}tblrec(// //#TwoByte:int /href TwoByte /a, char.193)<br>, {C2}tblrec(// //#TwoByte:int /href TwoByte /a, char.194)<br>, {C3}tblrec(// //#TwoByte:int /href TwoByte /a, char.195)<br>, {C4}tblrec(// //#TwoByte:int /href TwoByte /a, char.196)<br>, {C5}tblrec(// //#TwoByte:int /href TwoByte /a, char.197)<br>, {C6}tblrec(// //#TwoByte:int /href TwoByte /a, char.198)<br>, {C7}tblrec(// //#TwoByte:int /href TwoByte /a, char.199)<br>, {C8}tblrec(// //#TwoByte:int /href TwoByte /a, char.200)<br>, {C9}tblrec(// //#TwoByte:int /href TwoByte /a, char.201)<br>, {CA}tblrec(// //#TwoByte:int /href TwoByte /a, char.202)<br>, {CB}tblrec(// //#TwoByte:int /href TwoByte /a, char.203)<br>, {CC}tblrec(// //#TwoByte:int /href TwoByte /a, char.204)<br>, {CD}tblrec(// //#TwoByte:int /href TwoByte /a, char.205)<br>, {CE}tblrec(// //#TwoByte:int /href TwoByte /a, char.206)<br>, {CF}tblrec(// //#TwoByte:int /href TwoByte /a, char.207)<br>, {D0}tblrec(// //#TwoByte:int /href TwoByte /a, char.208)<br>, {D1}tblrec(// //#TwoByte:int /href TwoByte /a, char.209)<br>, {D2}tblrec(// //#TwoByte:int /href TwoByte /a, char.210)<br>, {D3}tblrec(// //#TwoByte:int /href TwoByte /a, char.211)<br>, {D4}tblrec(// //#TwoByte:int /href TwoByte /a, char.212)<br>, {D5}tblrec(// //#TwoByte:int /href TwoByte /a, char.213)<br>, {D6}tblrec(// //#TwoByte:int /href TwoByte /a, char.214)<br>, {D7}tblrec(// //#TwoByte:int /href TwoByte /a, char.215)<br>, {D8}tblrec(// //#TwoByte:int /href TwoByte /a, char.216)<br>, {D9}tblrec(// //#TwoByte:int /href TwoByte /a, char.217)<br>, {DA}tblrec(// //#TwoByte:int /href TwoByte /a, char.218)<br>, {DB}tblrec(// //#TwoByte:int /href TwoByte /a, char.219)<br>, {DC}tblrec(// //#TwoByte:int /href TwoByte /a, char.220)<br>, {DD}tblrec(// //#TwoByte:int /href TwoByte /a, char.221)<br>, {DE}tblrec(// //#TwoByte:int /href TwoByte /a, char.222)<br>, {DF}tblrec(// //#TwoByte:int /href TwoByte /a, char.223)<br>, {E0}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.224)<br>, {E1}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.225)<br>, {E2}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.226)<br>, {E3}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.227)<br>, {E4}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.228)<br>, {E5}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.229)<br>, {E6}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.230)<br>, {E7}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.231)<br>, {E8}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.232)<br>, {E9}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.233)<br>, {EA}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.234)<br>, {EB}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.235)<br>, {EC}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.236)<br>, {ED}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.237)<br>, {EE}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.238)<br>, {EF}tblrec(// //#ThreeByte:int /href ThreeByte /a, char.239)<br>, {F0}tblrec(// //#FourByte:int /href FourByte /a, char.240)<br>, {F1}tblrec(// //#FourByte:int /href FourByte /a, char.241)<br>, {F2}tblrec(// //#FourByte:int /href FourByte /a, char.242)<br>, {F3}tblrec(// //#FourByte:int /href FourByte /a, char.243)<br>, {F4}tblrec(// //#FourByte:int /href FourByte /a, char.244)<br>, {F5}tblrec(// //#FourByte:int /href FourByte /a, char.245)<br>, {F6}tblrec(// //#FourByte:int /href FourByte /a, char.246)<br>, {F7}tblrec(// //#FourByte:int /href FourByte /a, char.247)<br>, {F8}tblrec(// //#Invalid:int /href Invalid /a, char.248)<br>, {F9}tblrec(// //#Invalid:int /href Invalid /a, char.249)<br>, {FA}tblrec(// //#Invalid:int /href Invalid /a, char.250)<br>, {FB}tblrec(// //#Invalid:int /href Invalid /a, char.251)<br>, {FC}tblrec(// //#Invalid:int /href Invalid /a, char.252)<br>, {FD}tblrec(// //#Invalid:int /href Invalid /a, char.253)<br>, {FE}tblrec(// //#Invalid:int /href Invalid /a, char.254)<br>, {FF}tblrec(// //#Invalid:int /href Invalid /a, char.255)/block]

 <p>// // timestamp /id Module /keyword timestamp

 <p>use UTF8

 <p>use bits

 <p>use seq.byte

 <p>use standard

 <p>use kernal

 <p>Export /keyword type:timestamp

 <p>function // subseq:UTF8:int:int:UTF8 /id // #timestamp /href /a subseq(a:UTF8, i:int, j:int) UTF8 UTF8.// //#subseq:seq.T:int:int:seq.T /href subseq /a(toseqbyte.a, i, j)

 <p>Function // tojulian:int:int:int:int /id // #timestamp /href /a tojulian(year:int, month:int, day:int) int<br>// let /keyword ayear = // if /keyword month // //#>:int:int:boolean /href > /a 2 // then /keyword year // else /keyword year // //#/href-/a 1<br>// let /keyword amonth = // if /keyword month // //#>:int:int:boolean /href > /a 2 // then /keyword month // else /keyword month // //#+:int:int:int /href+/a 12,<br>(amonth // //#+:int:int:int /href+/a 1) // //#*:int:int:int /href * /a 306001 // //#/:int:int:int /href / /a 10000<br> // //#+:int:int:int /href+/a day<br> // //#+:int:int:int /href+/a 1720994<br> // //#+:int:int:int /href+/a 2<br> // //#/href-/a ayear // //#/:int:int:int /href / /a 100<br> // //#+:int:int:int /href+/a ayear // //#/:int:int:int /href / /a 100 // //#/:int:int:int /href / /a 4<br> // //#+:int:int:int /href+/a 1461 // //#*:int:int:int /href * /a ayear // //#/:int:int:int /href / /a 4

 <p>Function // dayofyear:timestamp:int /id // #timestamp /href /a dayofyear(t:timestamp) int<br>seconds.t // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60)<br> // //#/href-/a // //#tojulian:int:int:int:int /href tojulian /a(// // //#fromJuliantointseq:int:seq.int /href fromJuliantointseq /a(seconds.t // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60))<br> // //#sub:seq.T:int:T /href sub /a 1<br>, 1<br>, 1 /block)<br> // //#+:int:int:int /href+/a 1

 <p>Function // fromJuliantointseq:int:seq.int /id // #timestamp /href /a fromJuliantointseq(dt:int) seq.int<br>// let /keyword a = //((dt // //#+:int:int:int /href+/a 1) // //#*:int:int:int /href * /a 4 // //#/href-/a 7468865)<br> // //#/:int:int:int /href / /a 146097 /block // let /keyword b = dt // //#+:int:int:int /href+/a 1 // //#+:int:int:int /href+/a 1 // //#+:int:int:int /href+/a a // //#/href-/a a // //#/:int:int:int /href / /a 4 // //#+:int:int:int /href+/a 1524<br>// let /keyword c = (b // //#*:int:int:int /href * /a 20 // //#/href-/a 2442) // //#/:int:int:int /href / /a 7305<br>// let /keyword d = b // //#/href-/a 1461 // //#*:int:int:int /href * /a c // //#/:int:int:int /href / /a 4<br>// let /keyword e = d // //#*:int:int:int /href * /a 10000 // //#/:int:int:int /href / /a 306001<br>// let /keyword m = e // //#/href-/a (// if /keyword e // //#>:int:int:boolean /href > /a 13 // then /keyword 13 // else /keyword 1),<br>[// c // //#/href-/a (// if /keyword m // //#>:int:int:boolean /href > /a 2 // then /keyword 4716 // else /keyword 4715)<br>, m<br>, d // //#/href-/a e // //#*:int:int:int /href * /a 306001 // //#/:int:int:int /href / /a 10000 /block]

 <p>Function // timestamplit:UTF8:timestamp /id // #timestamp /href /a timestamplit(t:UTF8) timestamp<br>//{assumes t is in format 2019-12-12T12:48:11}/comment<br>// let /keyword year = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 1, 4)<br>// let /keyword month = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 6, 7)<br>// let /keyword day = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 9, 10)<br>// let /keyword hour = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 12, 13)<br>// let /keyword minutes = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 15, 16)<br>// let /keyword second = // //#intlit:UTF8:int /href intlit /a.// //#subseq:UTF8:int:int:UTF8 /href subseq /a(t, 18, 19)<br>// let /keyword date = // //#tojulian:int:int:int:int /href tojulian /a(year, month, day),<br>timestamp(//((date // //#*:int:int:int /href * /a 24 // //#+:int:int:int /href+/a hour) // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a minutes)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a second /block)

 <p>Function // totimestamp:int:int:int:int:int:int:timestamp /id // #timestamp /href /a totimestamp(<br>year:int<br>, month:int<br>, day:int<br>, hour:int<br>, minute:int<br>, second:int<br>) timestamp<br>timestamp(//((// //#tojulian:int:int:int:int /href tojulian /a(year, month, day) // //#*:int:int:int /href * /a 24<br> // //#+:int:int:int /href+/a hour)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a minute)<br> // //#*:int:int:int /href * /a 60<br> // //#+:int:int:int /href+/a second /block)

 <p>Function // decompose:timestamp:seq.int /id // #timestamp /href /a decompose(ts:timestamp) seq.int<br>//{returns sequence of year, month, day, hour, minute, second}/comment<br>// let /keyword a = seconds.ts // //#mod:int:int:int /href mod /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60)<br>// let /keyword seconds = a // //#mod:int:int:int /href mod /a 60<br>// let /keyword minutes = a // //#/:int:int:int /href / /a 60 // //#mod:int:int:int /href mod /a 60<br>// let /keyword hours = a // //#/:int:int:int /href / /a 3600,<br>// //#fromJuliantointseq:int:seq.int /href fromJuliantointseq /a(seconds.ts // //#/:int:int:int /href / /a (24 // //#*:int:int:int /href * /a 60 // //#*:int:int:int /href * /a 60))<br> // //#/href+/a [hours, minutes, seconds]

 <p>Function // print:timestamp:seq.word /id // #timestamp /href /a print(ts:timestamp) seq.word<br>// let /keyword d = // //#decompose:timestamp:seq.int /href decompose /a.ts,<br>[// // //#/href merge /a.[// // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 1<br>, //"-"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 2<br>, //"-"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 3<br>, //"."/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 4<br>, //":"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 5<br>, //":"/literal // //#sub:seq.T:int:T /href sub /a 1<br>, // //#toword:int:word /href toword /a.d // //#sub:seq.T:int:T /href sub /a 6 /block]/block]

 <p>Export /keyword seconds(t:timestamp) int

 <p>Export /keyword timestamp(seconds:int) timestamp

 <p>// // stateFunctions /id Module /keyword stateFunctions

 <p>use kernal

 <p>Builtin /keyword // spacecount

 <p>Builtin /keyword // clock

 <p>Builtin /keyword // randomint

 <p>Builtin /keyword // currenttime

 <p>  