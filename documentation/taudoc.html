<!doctype html> <html lang="en"> <meta charset="utf-8"> <head> <p> <link rel="stylesheet" href="../daws/codeExample.css"> <p> <br> <link rel="stylesheet" href="../daws/codeexample.css"></head><body> <p> <h1>The Tau Programming Language</h1> <p> <p>Programming languages today look pretty much the same as they did 30 years ago. Today, they may have a few more features, but they are not substantially better as a notation for thought. I have created another programming language in an attempt to introduce a new way of thinking about programming. <p>This new language is different because there is: <ul> <li>No assignment operator. <p> <li>No loop/while statement <p> <li>No function type. <p> <li>Only uses program state in a very controlled way. <p> <li>Words are the basic text element instead of characters. <p> <li>Heavy use of sequences. <p> <li>Introduces a new control structure for iterating through loops. </ul> <p> <p>Functional programming languages have no assignment operator or loop statements, but tend to be based on the lambda calculus, which uses higher-order functions. We only include the basic operations for functions—declaring, calling, and binding an unbound function to an actual function in an instantiation of a parameterized module. <p>Functional languages tend to use recursion to replace loop control structures. The full power of recursion is seldom needed. We introduce a new control structure to cover many simple uses of recursion. <p>Instructions for downloading and installing Tau in <a href="installdoc.html">here</a> to try out the examples below for yourself. <h2>Basic Structure</h2> <p> <p>Tau is word-based rather than character-based. A source file for Tau is UTF-8 encoded. Blank lines in the file break the file into a sequence of paragraphs. Spaces separate words. Some characters, such as '+', form a word of a single character even when there is no space before or after. Paragraphs are further grouped into <em>modules</em>. <h3>Converting UTF-8 to a sequence of paragraphs</h3> <p> <p>Tau transforms the bytes a UTF-8 encoded file into a sequence of paragraphs by classifying the bytes into 5 groups. <ol> <li>The LF group is the ASCII linefeed character. <p> <li>The Space group is the ASCII space and the carriage return. The carriage return is added to handle the end-of-line representation in DOS. <p> <li>The StandAlone group is the ASCII characters()+,-..:=[]{}and the double quote. <p> <li>The other group, which contains any byte not included in the other three groups. </ol> <p> <p>By considering the class of each byte(the current byte)and the next byte(the Lookahead), the bytes can be a sequence of paragraphs with each paragraph containing a sequence of words. Each word will be a sequence of Unicode code points. The table below lists the action to take for each combination of the current class and the lookahead class. For a combination not present in the table, just advance to the next byte without taking any other action. <table> <tr> <th>Current</th> <th>Lookahead</th> <th>Action</th></tr> <tr> <td>LF</td> <td>space</td> <td>Keep LF as current</td></tr> <tr> <td>LF</td> <td>LF</td> <td>End of paragraph. The words since the last form the contents of the paragraph. Empty paragraphs are removed. </td></tr> <tr> <td>other</td> <td>other</td> <td>part of word</td></tr> <tr> <td>other</td> <td>not other</td> <td>end of word</td></tr> <tr> <td>Kstandalone</td> <td>any</td> <td>if current is. or: and the Lookahead is space then the word of the current followed by the space is formed.Otherwise, the word of the current is formed. </td></tr></table> <p> <h3>PEG grammars</h3> <p> <p>We will be us in Parsing Expression Grammar(PEG)to describe the syntax of Tau. See Wikipedia for an introduction to PEG. We are using a similar syntax to that of Wikipedia, but will not include the operators: ? and &amp;. Also, * is moved from the right side to the left side of the rule and parentheses are not meta characters. Here is how strings with balance parentheses would be represented: <table> <tr> <td></td></tr> <tr> <td>Start</td> <td>←(N)</td></tr> <tr> <td>* N</td> <td>← Start</td></tr> <tr> <td></td> <td>/ !(!)any</td></tr></table> <p> <p>The non-terminals are <em>Start</em>, <em>N</em>, <em>any</em>. The non-terminal, <em>any</em>, will match any terminal. The terminals explicitly used are the open and close parentheses. The terminal alphabet could be much larger. <h3>Structure of Tau source file</h3> <p> <p>Here is a PEG grammar describing the structure of a Tau source file where <em>emptyline</em> represents one or more blank lines: <table> <tr> <td></td></tr> <tr> <td>* Modules</td> <td>← Module ModName <em>emptyline</em> Body</td></tr> <tr> <td></td> <td>/ Module ModName.T <em>emptyline</em> Body</td></tr> <tr> <td></td> <td>/ module ModName <em>emptyline</em> Body</td></tr> <tr> <td></td> <td>/ module ModName.T <em>emptyline</em> Body</td></tr> <tr> <td>* Body</td> <td>← Function FName Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ function FName Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ use ModName <em>emptyline</em></td></tr> <tr> <td></td> <td>/ use ModName.Type <em>emptyline</em></td></tr> <tr> <td></td> <td>/ Export type:Type Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ Export Fname Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ type TypeName is Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ Builtin Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ builtin Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ unbound Words <em>emptyline</em></td></tr> <tr> <td></td> <td>/ ! Module Words <em>emptyline</em></td></tr> <tr> <td>* Words</td> <td>← any</td></tr> <tr> <td>Type</td> <td>← TypeName.Type / int / real / word / boolean / TypeName</td></tr> <tr> <td>ModName</td> <td>← Id</td></tr> <tr> <td>FuncName</td> <td>← Id</td></tr> <tr> <td>TypeName</td> <td>← Id</td></tr> <tr> <td>Id</td> <td>← !, !]!)!:!.! dq any</td></tr></table> <p> <p>Any text matching the"/ ! Module Words"rule above is treated as a comment and can be omitted without changing the semantics. This will be any paragraph not beginning with one of the following words: Module, module, Function, function, use, Export, type, Builtin, builtin, unbound. This grammar does not specify the detailed syntax of paragraphs. <p>Each module defines a set of functions and types. Paragraphs beginning with Function, function, and type declare functions and types. Only functions and types that are exported can be used outside of a module. The Export clause will export a function or type. If the F in the function definition is capitalized, it will be exported. <p>The use clause determines which functions from other modules are available. <p>The module <em>standard</em> defines often-used functions and types. A full list of functions is in this document itself, which can be fed directly to a Tau compiler. In this document, modules with names ending in a question mark, like in the next paragraph, are introduced solely for the purpose of allowing this document to compile. The following paragraphs define a module that exports some functions and types from the module standard. <p> <span class="keyword" id="standard?">Module</span> keyword standard? <p>This module re-exports some common functions from the module standard. The use paragraph below makes visible in the module standard?, the functions and types in the module standard. The type <em>int</em> is always visible and cannot be exported. <p>use standard <p> <span class="keyword">Export</span> keyword type:boolean <p> <span class="keyword">Export</span> keyword true boolean <p> <span class="keyword">Export</span> keyword false boolean <p> <span class="keyword">Export</span> keyword ∧(boolean, boolean) boolean <br>{The second operatand is evaluated if and only if the first operatand does not determine the result} <p> <span class="keyword">Export</span> keyword ∨(boolean, boolean) boolean <br>{The second operatand is evaluated if and only if the first operatand does not determine the result} <p> <span class="keyword">Export</span> keyword +(int, int) int{this exports the infix operator+} <p> <span class="keyword">Export</span> keyword type:word <p> <span class="keyword">Export</span> keyword type:seq.int <p> <span class="keyword">Export</span> keyword type:seq.word <p> <span class="keyword">Export</span> keyword type:ordering{For working with total orderings} <p> <span class="keyword">Export</span> keyword LT ordering <p> <span class="keyword">Export</span> keyword EQ ordering <p> <span class="keyword">Export</span> keyword GT ordering <p> <a id=">1:int:int:ordering" href="#standard?">Function</a> >1(a:int, b:int) ordering <span class="keyword">if</span> keyword a > b <span class="keyword">then</span> keyword GT <span class="keyword">else</span> keyword if a = b <span class="keyword">then</span> keyword EQ <span class="keyword">else</span> keyword LT <p> <span class="keyword">Export</span> keyword ∧(a:ordering, b:ordering) ordering{if a = EQ then b else a} <p> <span class="keyword">Export</span> keyword %(n:int) seq.word <br>{By convention functions that begin with a % and have a return type of seq.word, supply a human-readable representation of its last argument.} <p> <span class="keyword">Export</span> keyword %(w:word) seq.word <h3>Converting words to UTF8</h3> <p> <p>A sequence of tau words must be converted back to UTF-8 to communicate with the outside world. When a file is read, whitespace is stripped, and it must be added back. <p>The basic rules for adding spaces is to add a space after each word except when: <ul> <li>If the word is+-.. : then the space before and after the word is suppressed. <p> <li>If the word is)]}, then the space before the word is suppressed. <p> <li>If the word is([{then the space after the word is suppressed. "</ul> <p> <p>There is a set of additional commands that provide additional formatting. Examples are given in the table below. <table> <tr> <th>Example</th> <th>with format</th> <th>note</th></tr> <tr> <td></td></tr> <tr> <td>first //p second</td> <td>first //p second</td> <td>paragraph break</td></tr> <tr> <td>first //br second</td> <td>first //br second</td> <td>line break</td></tr> <tr> <td>* ///keyword example *</td> <td>*example *</td> <td>removes space before and after word.</td></tr> <tr> <td>///keyword &lt;hr> /td&lt;hr></td> <td>///keyword also does not escape &lt; &amp; in &lt;hr> for html output.</td></tr> <tr> <td>a ///keyword"b"c</td> <td>a"b"c</td> <td>spacing around quotes</td></tr> <tr> <td>/keyword/rmbr /td/tag &amp;#32; /keyword/td/br /cell/td Toggles whether to interpret commands.</td></tr></table> <p> <p>The above rules are represented by the grammar below. The non-terminal <em>N</em> indicates that there is no pending space following the word.and <em>S</em> indicates that a space is pending. <table> <tr> <td></td> <td></td> <td>Action</td></tr> <tr> <td>N</td> <td>← S BA</td> <td>Do not add pending space to S</td></tr> <tr> <td></td> <td>← S A</td> <td>Add pending space to S</td></tr> <tr> <td></td> <td>← BA</td></tr> <tr> <td></td> <td>← A</td></tr> <tr> <td>+S</td> <td>B</td> <td>Do not add pending space</td></tr> <tr> <td></td> <td>← ! BA ! A any</td> <td>Add pending space</td></tr> <tr> <td>A</td> <td>←(/[/{</td> <td>suppress space(A)fter</td></tr> <tr> <td>B</td> <td>←)/]/}/, /"/"</td> <td>suppress space(B)efore</td></tr> <tr> <td>BA</td> <td>←+/-/./. /:/: </td> <td>suppress space(B)before and(A)fter</td></tr></table> <p> <p>There are a set of commands that alter these rules <table> <tr> <td>CN</td> <td>← NSBA</td> <td></td></tr> <tr> <td></td> <td>← <em></em></td> <td>if last char is not space add one.</td></tr> <tr> <td></td> <td>← ///em ! / escapeformat any</td> <td></td></tr> <tr> <td></td> <td>← / br</td> <td>add a line break.</td></tr> <tr> <td></td> <td>← <em></em></td> <td>add a paragraph break.</td></tr> <tr> <td></td> <td>← ec N</td> <td></td></tr> <tr> <td></td> <td>← CS NSBA</td> <td></td></tr> <tr> <td></td> <td>← CS A</td> <td></td></tr> <tr> <td></td> <td>← CS</td> <td></td></tr> <tr> <td></td> <td>← NSBA</td> <td></td></tr> <tr> <td></td> <td>← A</td> <td></td></tr> <tr> <td>+CS</td> <td>← NSB</td> <td></td></tr> <tr> <td></td> <td>← <em></em></td> <td></td></tr> <tr>← ! BA ! B! <strong>!</strong> <em>!</em> ! <br>! ec !any/td</tr></table> <p> <p>Line breaks are handled by inserting formatting words. The simplest formatting rules are  /br for a line break and  /p for a paragraph break. <p>An opening quote mark should be treated differently than a closing quote mark and the ASCII character set does not distinguish between opening and closing quote marks. Adding <em></em> will force a space after a word and <em>will</em> suppress the space before and after the next word. The spacing around an open quote mark can be expressed as <em></em> <em>"</em> to get"firstWord without the space after the quote mark. <p>The format words are interpreted differently when producing plain text or HTML. For example, produces LF LF for plain text and &lt;p> for HTML. Different functions are provided to do this. When creating output files from seq.word, if the file extension is HTML, the output is HTML; otherwise, plain text. <h2>Expressions</h2> <p> <p>We would like an expression such as a+3 * b sup 2 sup-2 to be evaluated to what a mathematician would expect. Adding parentheses specifies the order of evaluation: a+(3 *((b sup(2 sup-2)). The binary operators+and * are left associative, and sup is right associative. The following is a PEG grammar for simple expressions. The order of evaluation is obscured by this grammar since left recursion must be eliminated. The left associative of+and * are taken care of in further processing, but the grammar takes care of the right associative nature of sup. <table> <tr> <td></td></tr> <tr> <td>E</td> <td>← Sum</td></tr> <tr> <td>Sum</td> <td>← Product Sum'</td></tr> <tr> <td>* Sum'</td> <td>←-Product /+Product</td></tr> <tr> <td>Product</td> <td>← Unary Product'</td></tr> <tr> <td>* Product'</td> <td>← * Unary</td></tr> <tr> <td>Unary</td> <td>←-Unary / Power</td></tr> <tr> <td>Power</td> <td>← Atom Power'</td></tr> <tr> <td>* Power'</td> <td>←sub Unary / sup Unary</td></tr> <tr> <td>Atom</td> <td>←(E)/ Id</td></tr> <tr> <td>Id</td> <td>← !, !)!:!.! dq any</td></tr></table> <p> <p>Tau has many more binary operators than the above grammar handles. Below is the full list. Operators on the same line are of the same precedence. <p>sup sub <br>unary minus <br>* / mod ∪ ∩ \ <br>+-∈ ∉ <br>= &lt; > >1 >2 ≤ ≥ ≠ >> &lt;&lt; <br>∧ <br>∨ ⊻ <br> <p>Note that the operators ∪, ∩, and \ used for set union, intersection, and difference all share the same precedence. Here is the syntax for a procedure call and an if expression: <table> <tr> <td></td></tr> <tr> <td>Unary</td> <td>←-Unary / Id.Unary / Power</td></tr> <tr> <td>Atom</td> <td>←(E)</td></tr> <tr> <td></td> <td>/ if E then E IF else E</td></tr> <tr> <td></td> <td>/ Name(EL)</td></tr> <tr> <td></td> <td>/ Name</td></tr> <tr> <td>Name</td> <td>← Id</td></tr> <tr> <td>EL</td> <td>← E EL'</td></tr> <tr> <td>* EL'</td> <td>←, E</td></tr> <tr> <td>* IF</td> <td>← else if E then E</td></tr></table> <p> <p>A function call with a single argument can be expressed in one of two ways: <span class="block">f1.a or f1(a)</span> block. This allows expressions to be written with fewer parentheses. Note how the order of evaluation differs in the following expression: <span class="block">not(a ∧ b)≠(not.a ∧ b)</span> block <p>The operators ≤ ≥ ≠ are syntactical abbreviations for not(a > b), not(a &lt; b), not(a = b), respectively. <p>Declaring Funcions/h2 <p>Here are examples of two function definitions: <p> <a id="quadratic:int:int:int:int:int" href="#standard?">function</a> quadratic(a:int, b:int, c:int, x:int) int a + b * x + c * x sup 2 <p> <a id="quadratic:real:real:real:real:real" href="#standard?">Function</a> quadratic(a:real, b:real, c:real, x:real) real <br>a + b * x + c * x sup 2 <p>The following paragraph is needed for the second function to compile: <p>use real <p>If two functions differ in name, number of parameters, or types of the parameters, they are considered distinct functions. Capitalizing the first letter of a Function implies the function is exported from the module. If the first letter is lowercase, the function is not exported unless an Export clause for the function is included, like: <p> <span class="keyword">Export</span> keyword quadratic(a:int, b:int, c:int, x:int) int <p>Here is the syntax for function definitions. It includes a non-terminal, <em>Declare</em>, which we define later. <table> <tr> <td></td></tr> <tr> <td>S</td> <td>← function Name(FPL)Type Declare' E</td></tr> <tr> <td></td> <td>/ function Name Type Declare' E</td></tr> <tr> <td></td> <td>/ Function Name(FPL)Type Declare' E</td></tr> <tr> <td></td> <td>/ Function Name Type Declare' E</td></tr> <tr> <td>FPL</td> <td>← FP FPL'</td></tr> <tr> <td>* FPL'</td> <td>←, FP</td></tr> <tr> <td>FP</td> <td>← any:Type / Type</td></tr> <tr> <td>* Declare' Declare</td></tr></table> <p> <p>A expression can always be viewed as a series of function calls. For the first function defined above, the values of the parameters can be viewed as the functions with no parameters with the function name being the parameter name and the function result type being the parameter type. <p>The value of the integer literal 2 can be viewed as the function <p> <a id="2" href="#standard?">Function</a> 2 int 2 <p>The infix binary operators are the functions that are defined in the Module standard <p> <span class="keyword">Export</span> keyword +(int, int) int <p> <span class="keyword">Export</span> keyword *(int, int) int <p> <span class="keyword">Export</span> keyword sup(int, int) int <p>Any expression has exactly one type that can be determined from the subexpression using the return type of the functions called. <p>When calling a function, the types of the actual arguments MUST match the types specified in the function's definition. <p>When defining a function, the type of the expression must match the return type of the function. <h2>Literals</h2> <p> <p>Below is a grammar that shows how characters are combined to form three types of literals with the names <em>int</em>, <em>bits</em> and <em>real</em>. Examples of int are 0 1 1000 1234. Exampes of bits are 0x1 0x0000 0X0a 0X0B. Examples of real are 0.0 1.0 1000.0 and 1234.456. Unlike most other PEG grammars in this document the grammar below has an alphabet of characters rather than words. <table> <tr> <td></td></tr> <tr> <td>Digit</td> <td>← 0 / 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8 / 9</td></tr> <tr> <td>* Digit'</td> <td>← Digit</td></tr> <tr> <td>int</td> <td>← Digit'</td></tr> <tr> <td>HexDigit</td> <td>← Digit / A / B / C / D / E / F / a / b / c / d / e / f</td></tr> <tr> <td>* HexDigit'</td> <td>← HexDigit</td></tr> <tr> <td>bits</td> <td>← 0 X Digit Digit' / 0 x Digit Digit'</td></tr> <tr> <td>real</td> <td>← Digit Digit'.Digit Digit'</td></tr></table> <p> <p>Strings in Tau are defined as a sequence of words(seq.word). An example literal for a sequence of words is"this is a sample string of 8 words"A simple grammar for strings would be <span class="block">String ←"Str2"* Str2 ← !"any</span> block <p>But Tau allows a string to include an expression of type <em>seq</em>.word. The example literal above could also be represented as"this is a:("sample string")of 8 words"So the grammar becomes <table> <tr> <td>String</td> <td>←</td> <td>"String' Str2"</td></tr> <tr> <td>* String'</td> <td>←</td> <td>:(E)</td></tr> <tr> <td></td> <td>/</td> <td>Str2</td></tr> <tr> <td>+Str2</td> <td>←</td> <td>!"!:any</td></tr></table> <p> <p>There are two functions named <em>dq</em> in the standard package. The first takes no arguments and returns the sequence of one word consisting of a single doublequote character. The second function takes a sequence of words as an argument and returns the args with a double quote added to the beginning and end. <p>These function allow a double quote within a string. For example: <span class="block">"hello world without quotes;:(dq)hello world:(dq)with quotes"</span> block is the same as writing <span class="block">"hello world without quotes;"+dq+"hello world"+dq+"with quotes"</span> block Since:(...)can receive any expression we could also write"hello world without quotes:(dq."hello world")with quotes"Since":("functions as an escape in strings, it can be include within a string as":(":")("Note that just the /: is escaped as":(":(")"will raise an error because the escape in the inner qoute is not properly formed. <h2>Declarations</h2> <p> <p>This section explains the constructs used in the following function: <p> <a id="exampeDeclarations" href="#standard?">Function</a> exampeDeclarations int <br> <span class="keyword">let</span> keyword a = 33 <br> <span class="comment">{comment as declaration{nested comment}}</span> comment <br> <span class="keyword">let</span> keyword b = 444 <br> <span class="keyword">for</span> keyword sum = 0, product = 1, e ∈ <span class="literal">"1 2 3 4 mark 5 6"</span> literal <br> <span class="keyword">while</span> keyword e ∉ <span class="literal">"mark"</span> literal <br> <span class="keyword">do</span> keyword next(sum + toint.e, product * {comment within expression}toint.e) <br> <span class="keyword">assert</span> keyword product = 24 ∧ b = 444 <span class="keyword">report</span> keyword <span class="literal">"Problem occured. Expect 24 but got:(product)"</span> literal, <br>sum + product <table> <tr> <td></td></tr> <tr> <td>Declare</td> <td>← let any = E comma?</td></tr> <tr> <td></td> <td>/ assert E report E comma?</td></tr> <tr> <td></td> <td>/ Comment comma?</td></tr> <tr> <td></td> <td>/ for Accum AccumList', any ∈ E do E comma?</td></tr> <tr> <td></td> <td>/ for Accum AccumList', any ∈ E while E do E comma?</td></tr> <tr> <td></td> <td>/ for Accum AccumList' while E do E comma?</td></tr> <tr> <td>* AccumList' cell ←, Accum</td></tr> <tr> <td>Accum</td> <td>← any = E</td></tr> <tr> <td>Comment</td> <td>←{N}</td></tr> <tr> <td>* N</td> <td>← Comment / str1</td></tr> <tr> <td>comma? ←, /</td></tr></table> <p> <p>A let declaration in a function allows an name to be given to the value of an expression so the name references the value in the following expressions. A let statement DOES NOT define a variable that can change values. <p>Comments are enclosed in curly brackets:{}and can be nested. Comments are traditionally defined at the lexical level. In tau, they are treated as prefix operators so they can be easily included in a parse tree. Comments can appear as declarations or as unary operators within expressions. <p>The assert construct evaluates the first expression, which must be of type boolean. If the first expression is false, the second expression is evaluated and must be of type seq.word. The value of the second expression is thrown, and the evaluation of the function stops. If the first expression evaluates to true, execution continues as if the assert was omitted from the function. <p>In the for construct in exampleDeclaration, sum and product are accumulators. Each accummulator is given an initial value. For each value e in the sequence, new values are calculated for each accumlator by the pseudo function next which also advances to the next value in the sequence if they are any. If a while expression is present it's type must be boolean, and is evaluated just after e is assign a value. If it is false the evaluation of the for construct is stopped. <p>The sequence can be omitted from a for construct but then a while expression is required. <p>Only the values of the accumlators are available outside the for construct.In the exampleDeclaration the identifiers sum product and e will take on the values <table> <tr> <td></td></tr> <tr> <td> <strong>sum</strong></td> <td> <strong>product</strong></td> <td> <strong>e</strong></td></tr> <tr> <td>0</td> <td>1</td> <td>1</td></tr> <tr> <td>1</td> <td>1</td> <td>2</td></tr> <tr> <td>3</td> <td>2</td> <td>3</td></tr> <tr> <td>6</td> <td>6</td> <td>4</td></tr> <tr> <td>10</td> <td>24</td> <td>undefined</td></tr></table> <p> <p>If only one accumulation is declared then the next function can be dropped, for example: <p> <a id="sum:seq.int:int" href="#standard?">function</a> sum(s:seq.int) int <br> <span class="keyword">for</span> keyword accumulator = 0, e ∈ s <span class="keyword">do</span> keyword accumulator + e, <br>accumulator <p>The optional comma in declarations can usually be left out, but there are exceptions. In the following function the comma cannot be left out or a error will occur as <p> <a id="neccessaryComma" href="#standard?">Function</a> neccessaryComma int <br> <span class="keyword">let</span> keyword b = 1, <br>-b <h2>Sequences</h2> <p> <p>A sequence is a function whose domain is the integers and whose range is some type. A literal for a sequence of integers is coded as[2, 4, 8, 16, 32]and has a type of seq.type. <p>A sequence of characters in double quotes does not represent a sequence of characters but a sequence of words. “Hello World!” represent two words. <p>Sequences have the following functions defined in a parameteized module named seq.T where T can be any type. <p> <span class="keyword" id="seq?">Module</span> keyword seq?.T <p>use seq.T <p> <span class="keyword">Export</span> keyword n(seq.T) int{the length of the sequence.} <p> <span class="keyword">Export</span> keyword sub(a:seq.T, i:int) T <br>{Return ith element of sequence. a sub 1 is the first element} <p> <span class="keyword">Export</span> keyword empty:seq.T seq.T{Returns the sequence of type seq.T with zero elements} <p> <span class="keyword">Export</span> keyword +(a:seq.T, b:seq.T) seq.T{Concatenation operator} <p> <span class="keyword">Export</span> keyword subseq(s:seq.T, start:int, stop:int) seq.T{Obtain sub-sequence} <p> <span class="keyword">Export</span> keyword =(a:seq.T, b:seq.T) boolean <br>{Test to see if a and b represent the same sequence.This function requires a function =(T, T)boolean} <p>The module standard exports the above functions with T replace by the type word <p>The function below is an example of using these functions. <p> <span class="keyword" id="testseq">Module</span> keyword testseq <p>use standard <p> <a id="testseq.word" href="#testseq">Function</a> testseq seq.word <br> <span class="keyword">let</span> keyword s1 = <span class="literal">"This is a test sequence with 9 words."</span> literal, <br> <span class="keyword">if</span> keyword n.s1 = 9 <br> ∧ s1 sub 3 = <span class="literal">"a"</span> literal sub 1 <br> ∧ s1 sub n.s1 = 'words <br> ∧ subseq(s1, 4, 5) = <span class="literal">"test sequence"</span> literal <br> ∧ subseq(s1, 4, 3) = empty:seq.word <br> ∧ subseq(s1, 1, 5) + subseq(s1, 6, n.s1) = s1 <br> ∧ [ <span class="literal">"Hello"</span> literal sub 1, <span class="literal">"World!"</span> literal sub 1] = <span class="literal">"Hello World!"</span> literal <br> ∧ empty:seq.word = <span class="literal">""</span> literal <br> ∧ subseq([11, 12, 13, 14], 1, 2) = [11, 12] <span class="keyword">then</span> keyword <span class="literal">"PASS"</span> literal <br> <span class="keyword">else</span> keyword <span class="literal">"FAIL"</span> literal <h2>User Types</h2> <p> <p>The module below defines a user defined type. <p> <span class="keyword" id="point2d">Module</span> keyword point2d <p>The follow paragraph that begins with use allows reference to functions defined in another module. In this case, the standard library functions. <p>use standard <p>Here is a simple type definition that introduces a new type with two components and supplies functions to create a point2d and access its components. <p>type point2d is x:int, y:int <p>To allow the type name to be used outside this module we export the type using a special syntax that omits the return type of the Export: <p> <span class="keyword">Export</span> keyword type:point2d <p>To allow the constructor for points to be used outside the module we export it: <p> <span class="keyword">Export</span> keyword point2d(a:int, b:int) point2d <p>Access to the fields outside the module is granted with: <p> <span class="keyword">Export</span> keyword x(point2d) int <p> <span class="keyword">Export</span> keyword y(point2d) int <p>The following two paragraphs defines an addition and subtraction function on the type point2d. If a function starts with function instead of Function the function is also not available outside the module. <p> <a id="+:point2d:point2d:point2d" href="#point2d">Function</a> +(a:point2d, b:point2d) point2d point2d(x.a + x.b, y.a + y.b) <p> <a id="-:point2d:point2d:point2d" href="#point2d">Function</a> -(a:point2d, b:point2d) point2d point2d(x.a - x.b, y.a - y.b) <p> <a id="%:point2d:seq.word" href="#point2d">Function</a> %(p:point2d) seq.word <span class="literal">"(:(x.p),:(y.p))"</span> literal <p> <a id="testpoint.word" href="#point2d">Function</a> testpoint seq.word %(point2d(2, 3) + point2d(4, 5)) <h2> <span class="keyword" id="to">Module</span> keyword to run tests in this document</h2> <p> <p> <span class="keyword" id="testdoc">Module</span> keyword testdoc <p>use standard <p>use file <p>use testseq <p>use point2d <p>use testlistset <p>use testdict <p>use exampleEncoding <p>use geotest <p> <a id="testdoc:seq.file:seq.word" href="#testdoc">Function</a> testdoc(input:seq.file) seq.word <br> <span class="comment">{COMMAND}</span> comment <br> <span class="literal">"testseq:(testseq)point2d:(testpoint)testlistset:(testlistset)testdict:(testdict)exampleEncoding:(testExampleEncoding)geotest:(geotest)"</span> literal <h2>Parameterized Module</h2> <p> <p>A type can have a single type parameter named T. The T can be used anywhere a type can be used. <p>Generic unbound functions on the type T may be included by using the word unbound as the defining expression. When the parameterized type is used, there must exist a function with the same signature as the unbound one, where T is replaced with the actual type for T. <p>The following defines a parameterized set implemented as a sequence <p> <span class="keyword" id="listset">Module</span> keyword listset.T <p>use standard <p>use seq.T <p> <span class="keyword">unbound</span> keyword =(T, T) boolean <p>type listset is toseq:seq.T <p> <span class="keyword">Export</span> keyword type:listset.T <p> <span class="keyword">Export</span> keyword toseq(s:listset.T) seq.T <p> <a id="empty:listset.T.T" href="#listset">Function</a> empty:listset.T listset.T listset.empty:seq.T <p> <a id="∈:T:listset.T:boolean" href="#listset">Function</a> ∈(ele:T, s:listset.T) boolean ele ∈ toseq.s <p> <a id="+:listset.T:T:listset.T" href="#listset">Function</a> +(s:listset.T, ele:T) listset.T <br> <span class="keyword">if</span> keyword ele ∈ s <span class="keyword">then</span> keyword s <span class="keyword">else</span> keyword listset([ele] + toseq.s) <p> <a id="tolistset:seq.T:listset.T" href="#listset">Function</a> tolistset(s:seq.T) listset.T <br> <span class="comment">{construct a listset from a sequence.(The compiler does not generate any code for this function since it is just a type change)}</span> comment <br> <span class="keyword">for</span> keyword acc = empty:listset.T, ele ∈ s <span class="keyword">do</span> keyword acc + ele, <br>acc <p> <a id="∪:listset.T:listset.T:listset.T" href="#listset">Function</a> ∪(a:listset.T, b:listset.T) listset.T <br> <span class="comment">{This union is constructed so if an element is in both a and b, the representation in a is used in the result}</span> comment <br> <span class="keyword">for</span> keyword acc = a, ele ∈ toseq.b <span class="keyword">do</span> keyword acc + ele, <br>acc <p> <span class="keyword">Export</span> keyword isempty(seq.T) boolean <p> <span class="keyword">Export</span> keyword sub(seq.T, int) T <p> <a id="lookup:listset.T:T:seq.T" href="#listset">Function</a> lookup(s:listset.T, ele:T) seq.T lookup(toseq.s, ele) <p>The purpose of the last three function of the above module will become clear below. <p> <span class="keyword" id="testlistset">Module</span> keyword testlistset <p>use standard <p>use listset.word <p> <a id="testlistset.word" href="#testlistset">Function</a> testlistset seq.word <br> <span class="keyword">let</span> keyword set1 = tolistset. <span class="literal">"A A B C A C B"</span> literal <br> <span class="keyword">let</span> keyword set2 = tolistset. <span class="literal">"D B E"</span> literal, <br> <span class="keyword">if</span> keyword toseq.set1 = <span class="literal">"C B A"</span> literal <br> ∧ <span class="literal">"C"</span> literal sub 1 ∈ set1 <br> ∧ <span class="literal">"D"</span> literal sub 1 ∉ set1 <br> ∧ toseq(set1 ∪ set2) = <span class="literal">"D E C B A"</span> literal <span class="keyword">then</span> keyword <span class="literal">"PASS"</span> literal <br> <span class="keyword">else</span> keyword <span class="literal">"FAIL"</span> literal <p>Sets can be used to implement dictionaries. A dictionary contains entries. Each entry contains a key and a data component. A type is declared to represent an entry. In this example, the key will be an integer, and the data will be a sequence of words. Entries will be equal if and only if the keys are equal. <p>type myentry is key:int, data:seq.word <p> <a id="=:myentry:myentry:boolean" href="#testlistset">function</a> =(a:myentry, b:myentry) boolean key.a = key.b <p>A set of entries will be a dictionary. From the mathematical view of the set, each entry is a representation of an integer. The integer 3 could be represented by myentry(3,"X"), myentry(3,"A B C")or an infinite number of other possibilities. But only one representation will be used in any listset.myentry. <p>Looking up an entry in the dictionary is just looking up the representation used in the set. The last function in the <em>listset</em> module does just that. The A ∪ B function in the listset module is carefully crafted so that if an element is in both A and B, the representation used in A is used in the result. Thus listset.[myentry(3,"X")]∪ B will redefine the entry in B if it exists. The expression B+myentry(3,"X")or B ∪[myentry(3,"X")]will not redefine the entry in B. By convention, the result of a binary operation on sets uses the representation of in the left operand--not the one on the right. <p> <span class="keyword" id="testdict">Module</span> keyword testdict <p>use standard <p>use seq.myentry <p>use listset.myentry <p>type myentry is key:int, data:seq.word <p> <a id="=:myentry:myentry:boolean" href="#testdict">function</a> =(a:myentry, b:myentry) boolean key.a = key.b <p> <a id="lookup:listset.myentry:int:seq.myentry" href="#testdict">function</a> lookup(a:listset.myentry, i:int) seq.myentry lookup(a, myentry(i, <span class="literal">""</span> literal)) <p> <a id="print:listset.myentry:seq.word" href="#testdict">function</a> print(a:listset.myentry) seq.word <br> <span class="keyword">for</span> keyword txt = <span class="literal">""</span> literal, ele ∈ toseq.a <span class="keyword">do</span> keyword txt + <span class="literal">"("</span> literal + toword.key.ele + <span class="literal">","</span> literal + data.ele + <span class="literal">"),"</span> literal, <br>txt >> 1 <p> <a id="testdict.word" href="#testdict">Function</a> testdict seq.word <br> <span class="keyword">let</span> keyword dict = tolistset.[myentry(1, <span class="literal">"add"</span> literal), myentry(2, <span class="literal">"sub"</span> literal), myentry(3, <span class="literal">"mult"</span> literal)] <br> <span class="keyword">let</span> keyword dict2 = tolistset.[myentry(2, <span class="literal">"subtract"</span> literal), myentry(4, <span class="literal">"divide"</span> literal)] <br> <span class="keyword">let</span> keyword l1 = lookup(dict, 4), <br> <span class="keyword">if</span> keyword print.dict = <span class="literal">"(3, mult),(2, sub),(1, add)"</span> literal <br> ∧ print.dict2 = <span class="literal">"(4, divide),(2, subtract)"</span> literal <br> ∧ isempty.lookup(dict, 4) <br> ∧ data.lookup(dict, 2) sub 1 = <span class="literal">"sub"</span> literal <br> ∧ print(dict2 ∪ dict) = <span class="literal">"(1, add),(3, mult),(4, divide),(2, subtract)"</span> literal <span class="keyword">then</span> keyword <span class="literal">"PASS testdict"</span> literal <br> <span class="keyword">else</span> keyword <span class="literal">"FAIL testdict"</span> literal <p>For the type listset.word, the unbound function = in the listset module is bound to the function =(word, word)in the standard module. For the type listset.myentry, then unbound = is bound to =(a:myentry, b:myentry)boolean <h2>>>.T in Parameterized Module. </h2> <p> <p>When defining graphs consisting of nodes and edges, the nodes and edges may be of different types. For example, the nodes may be of type T and the edges have a label of type seq.word. <p> <span class="keyword" id="edge">Module</span> keyword edge.T <p>use standard <p>type edge is tail:T, head:T, label:seq.word <p>In the parameterized graph module in the Tau release, the parameter is itself a parameterized type representing the graph edge type. So, within the graph module, T represents the edge type, and >>.T references the node type. That is, >>.T references the parameter of the parameter of the graph module. <p>The following function would also be needed in the edge module to be used by the graph module <p> <a id="arc:T:edge.T" href="#edge">Function</a> arc(node:T) edge.T <br> <span class="comment">{used by module graph.edge.T when looking up edges}</span> comment <br>edge(node, node, <span class="literal">""</span> literal) <p> <span class="keyword">Export</span> keyword head(node:edge.T) T{used by module graph.edge.T} <p> <span class="keyword">Export</span> keyword tail(node:edge.T) T{used by module graph.edge.T} <h2>Bindings</h2> <p> <p>Consider the following example code: <p> <span class="keyword" id="B">Module</span> keyword B <p> <a id="TWO" href="#B">Function</a> TWO int 2 <p> <span class="keyword" id="A">Module</span> keyword A <p>use B <p>use standard <p> <a id="f1:int:int" href="#A">Function</a> f1(p1:int) int <br> <span class="keyword">let</span> keyword l1 = p1 * TWO, <br>p1 * l1 - THREE <p> <a id="THREE" href="#A">function</a> THREE int 3 <p>Parameters implicitly declare an access function. Example: function p1 int <p>Parameters are only visible in the expression that defines the body. For example, p1 is only visible in the body of f1. <p>The names of functions are visible. <p>Functions from another module B are visible in module A, if they are declared using Function rather than function, or they are exported and the module A includes a paragraph use B. The function TWO is visible in module A and B. <p>A word of all digits implicitly declares an access function: function 3 int <p>Let definitions are only visible within the second expression in the let statement. Let definitions declare an access function: function l1 &lt;the type of the first expression of the let>. The definition itself returns the type of the second expression. <p>A function call f1(&lt;exp1>, &lt;exp2>,...)must match exactly one visible function defintion in name, number of parameters and types of the expressions of the arguments. <p>The type of the expression that defines a function much match the return type of the function. <h2>Order of evaluation</h2> <p> <p>The arguments of a function are evaluated from left to right before the function is called. <p>Not all arguments need to be evaluated. Consider i > 0 ∧ 300 / i &lt; 10 where ∧ is defined as: <span class="block">function ∧(a:boolean, b:boolean)boolean if a then b else false</span> block The compiler will do inline expansion and the above expression becomes <span class="block">if i > 0 then 300 / i &lt; 10 else false</span> block If i = 0 then the expression 300 / i &lt; 10 is never evaluated. <p>This behavior is required for the ∧ operator on booleans. <h2>Encodings</h2> <p> <p>A type can be mapped to positive integers in an encoding. <p>The parameterized module <em>encoding</em>.T defines the following functions for working with encodings. <p> <span class="keyword" id="encode?">Module</span> keyword encode?.T <p>use encoding.T <p> <span class="keyword">Export</span> keyword encode(T) encoding.T{will return the encoding} <p> <span class="keyword">Export</span> keyword decode(encoding.T) T{will return the value that was encoded} <p> <span class="keyword">Export</span> keyword findencode(T) seq.T <br>{will return the empty sequence if the value has not been mapped or a sequence containing the value that was mapped.} <p> <span class="keyword">Export</span> keyword encodingdata:T seq.T{list of values that have been encoded.} <p> <span class="keyword">Export</span> keyword valueofencoding(encoding.T) int{the integer value of the encoding} <p>Since the encoding can be shared by multiple processes, modifying the encoding is a critical section. Also, the mapping may contain encodings not assigned by the current process. <p>Encodings do not exist until a process references them; once referenced, the process owns the encoding. <p>A child process shares any encodings that its parents' process has. <p>A process does not share the encodings it owns with siblings or parents. <p> <span class="keyword" id="exampleEncoding">Module</span> keyword exampleEncoding <p>This is an example use of an encoding that encodes sub-expression of a postfix expression and then produces code that evaluates any common sub-expressions only once. <p>use standard <p>use seq.encoding.myencoding <p>use encoding.myencoding <p>use stack.encoding.myencoding <p>We need a type to encode: <p>type myencoding is op:word, operands:seq.encoding.myencoding <p>We must define a hash function and = function of the type myendcoding. <p> <a id="hash:myencoding:int" href="#exampleEncoding">function</a> hash(m:myencoding) int hash.op.m <p> <a id="=:myencoding:myencoding:boolean" href="#exampleEncoding">function</a> =(a:myencoding, b:myencoding) boolean op.a = op.b ∧ operands.a = operands.b <p>Note that for a and b of the type myencoding, a = b implies hash(a)= hash(b). This must be true for the hash to work correctly. The hash function in this example could be improved by including operands in the argument. <p> <a id="testExampleEncoding.word" href="#exampleEncoding">Function</a> testExampleEncoding seq.word <br> <span class="keyword">let</span> keyword R = <span class="literal">"R1 R2 R3 R4 R5 R6 R7 R8 R9 R11 R12 R13"</span> literal <br> <span class="keyword">let</span> keyword postfix = <span class="literal">"5 3 4+* 3 4+* 6 3 4+*+7+"</span> literal <br> <span class="comment">{encode every subexpression of the postfix expression. If a sub-expression is used more that once it will have the same encoding every time it is used. /rmbr/br Below a stack is used. The definition is in core.}</span> comment <br> <span class="keyword">let</span> keyword encodingofpostfix = <span class="block"> <span class="keyword">for</span> keyword stk = empty:stack.encoding.myencoding, w ∈ postfix <br> <span class="keyword">do</span> keyword <span class="block"> <span class="keyword">if</span> keyword w ∈ <span class="literal">"+*"</span> literal <span class="keyword">then</span> keyword push(pop.pop.stk, encode.myencoding(w, top(stk, 2))) <br> <span class="keyword">else</span> keyword push(stk, encode.myencoding(w, empty:seq.encoding.myencoding)),</span> block top.stk</span> block <span class="comment">{all the encodings are now in encodingdata:myencoding. It is now easy to print out instruction that will evaluate common subexpressions only once}</span> comment <br> <span class="keyword">for</span> keyword acc = <span class="literal">""</span> literal, idx = 1, e ∈ encodingdata:myencoding <br> <span class="keyword">do</span> keyword <span class="block"> <span class="keyword">let</span> keyword newacc = <span class="block">acc <br> + <span class="literal">"/br"</span> literal <br> + R sub idx <br> + <span class="literal">"="</span> literal <br> + <span class="keyword">if</span> keyword op.e ∈ <span class="literal">"+, *"</span> literal <span class="keyword">then</span> keyword[R sub valueofencoding.(operands.e) sub 1, op.e, R sub valueofencoding.(operands.e) sub 2] <br> <span class="keyword">else</span> keyword [op.e],</span> block next(newacc, idx + 1),</span> block acc <p>The testexample output is: R1 = 5 <br>R2 = 3 <br>R3 = 4 <br>R4 = R2+R3 <br>R5 = R1 * R4 <br>R6 = R5 * R4 <br>R7 = 6 <br>R8 = R7 * R4 <br>R9 = R6+R8 <br>R11 = 7 <br>R12 = R9+R11 <p>Consider the sequence of calls, C, in the execution of the program to the function encode. Let S be the sequence of T where S_i is the value passed as parameter in call C_i Let E be the sequence of results where E_i = the result of call C_i. <p>Then S_i = S_j if and only if encoding(E_i)= encoding(E_j)and decode(E_i)is identical to S_j where j = min t where S_t = E_i and encoding(E_i)> 0 <h2>Process statement</h2> <p> <p>Processes are included in Tau for three reasons. <p>Running multiple processes on multi-core processors can produce results more quickly. <p>Processes allow temporary space used to calculate the result to be reclaimed. This is the only way for heap space to be reclaimed Processes allow temporary space used for calculations to be reclaimed. This is the only method for heap space to be reclaimed in Tau.in Tau. <p>Processes capture and report abnormal events. The following code snippet shows how to capture an abnormal event. <p> <span class="keyword" id="testprocess">Module</span> keyword testprocess <p>use process.int <p>use standard <p> <a id="myprocess:int:int" href="#testprocess">function</a> myprocess(a:int) int <br> <span class="keyword">assert</span> keyword a > 0 <span class="keyword">report</span> keyword <span class="literal">"invalid"</span> literal, <br>a sup 3 <p> <a id="useprocess:int:int" href="#testprocess">function</a> useprocess(i:int) int <br> <span class="comment">{Note that the result type of this function matches the parameter in the use clause above. This provides access to the pseudo-function process below and allows a spawned process of type process.int to be created from the function myprocess}</span> comment <br> <span class="keyword">let</span> keyword a = process.myprocess.i, <br> <span class="keyword">if</span> keyword aborted.a <span class="keyword">then</span> keyword <span class="block"> <span class="keyword">assert</span> keyword message.a = <span class="literal">"invalid"</span> literal <span class="keyword">report</span> keyword <span class="literal">"new message"</span> literal, <br>0</span> block <span class="keyword">else</span> keyword result.a <p>The following functions interact with the spawned process and block to wait for the spawned process to finish. <p> <span class="keyword" id="process?">Module</span> keyword process?.T <p>use process.T <p>use standard <p> <span class="keyword">Export</span> keyword aborted(process.T) boolean <br>{true if the process was aborted as with an assert statement} <p> <span class="keyword">Export</span> keyword message(process.T) seq.word{message return when process was aborted} <p> <span class="keyword">Export</span> keyword result(process.T) T{result return upon successful completion. } <p>The spawning process cannot terminate until all of it child process complete, because it may have allocated space and passed it to a child process as a parameter. <h2>Defining Sequences</h2> <p> <p>Sometimes it is useful to define a new sequence type. Here we defined a geometric sequence moduled after the arithmetic seq define in seq1.T <p> <span class="keyword" id="geometricseq">Module</span> keyword geometricseq.T <p>All sequences must be in a parameterized Module. <p>use standard <p>We need some operations on T. <p> <span class="keyword">unbound</span> keyword *(T, T) T <p> <span class="keyword">unbound</span> keyword sup(T, int) T <p>type geometricseq is sequence, step:T, start:T <p>The above type is recognized as a sequence as the first element of the type is sequence. <p>A function <em>length</em>(myseq)is implicitly defined to access the length of geometricseq <p>As with any parameterized module, a type definition must contain an element that uses T so that multiple instances of the module do not produce duplicate symbols. <p>Every sequence must have a#function defined on it: <p> <a id="sequenceIndex:geometricseq.T:int:T" href="#geometricseq">Function</a> sequenceIndex(s:geometricseq.T, i:int) T start.s * (step.s) sup (i - 1) <p>We need a constructor of our sequence. Note the use of a toseq function. This is defined implicitly by the sequence type definition to change the type from geometricseq.T to seq.T <p> <a id="geoseq:int:T:T:seq.T" href="#geometricseq">Function</a> geoseq(length:int, step:T, start:T) seq.T <br>toseq.geometricseq(length, step, start) <p> <span class="keyword" id="geotest">Module</span> keyword geotest <p>use standard <p>use geometricseq.real <p>use geometricseq.int <p>use real <p> <a id="geotest.word" href="#geotest">Function</a> geotest seq.word <br> <span class="literal">"first 10 powers of 2 ="</span> literal <br> + %.geoseq(10, 2, 2) <br> + <span class="literal">"/br first 10 powers of 0.5 ="</span> literal <br> + %.geoseq(10, 0.5, 0.5) <p>The following are needed to define %(seq.int)and %(seq.real). <p>use seq1.int <p>use seq1.real <p> <a id="%:real:seq.word" href="#geotest">Function</a> %(a:real) seq.word %(10, a) <p>End of module geotest. <h2>Tail Recursion</h2> <p> <p>A function is tail-recursive if the last function called is itself. A compiler can take advantage of this and reuse the activation record on the call stack, reducing the space the stack consumes during execution. <p>Sometimes a recursive function can be rewritten to be tail-recursive. Consider the following function: <p>use seq.int <p> <a id="reverse2:seq.int:seq.int" href="#geotest">function</a> reverse2(l:seq.int) seq.int <br> <span class="keyword">if</span> keyword isempty.l <span class="keyword">then</span> keyword l <span class="keyword">else</span> keyword reverse2.subseq(l, 2, n.l) + l sub 1 <p>The last call in this function is to+. Here is a rewritten version that is tail recursive: <p> <a id="reverse3:seq.int:seq.int:seq.int" href="#geotest">function</a> reverse3(l:seq.int, accumalator:seq.int) seq.int <br> <span class="keyword">if</span> keyword isempty.l <span class="keyword">then</span> keyword accumalator <br> <span class="keyword">else</span> keyword reverse3(subseq(l, 2, n.l), accumalator + l sub 1) <p> <a id="reverse3:seq.int:seq.int" href="#geotest">function</a> reverse3(l:seq.int) seq.int reverse3(l, empty:seq.int) <p>Now reverse3 is the last function called. <p>Making the function tail-recursive is not the only way to reduce stack usage. The follow version uses O(ln n)instead of O(n)where n is the length of the sequence. <p> <a id="reverse4:seq.int:seq.int" href="#geotest">function</a> reverse4(l:seq.int) seq.int <br> <span class="keyword">if</span> keyword n.l &lt; 2 <span class="keyword">then</span> keyword l <br> <span class="keyword">else</span> keyword reverse4.subseq(l, n.l / 2 + 1, n.l) + reverse4.subseq(l, 1, n.l / 2) <p>Perhaps the best way to reverse a sequence is to use <p> <a id="reverse5:seq.int:seq.int" href="#geotest">Function</a> reverse5(s:seq.int) seq.int <br> <span class="keyword">for</span> keyword acc = empty:seq.int, e ∈ s <span class="keyword">do</span> keyword [e] + acc, <br>acc <p>In this case, the tau compiler will remove the bounds checking when indexing the sequence. If the sequence was built up out of smaller sequences, it may also break the sequence into the smaller parts and process them separately. <p>END  