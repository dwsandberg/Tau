
<* section Installing Tau   *>

Make sure clang is installed.   For Mac OS Clang is available if the command line tools are installed.

Down load zip file from GitHub  (Repository is dwsandberg/Tau

Unzip to a directory   which we will call <Tau>.  This directory will become the working directory for tau.    You are free to choose another name.  

Modify < PATH > environment variable to include absolute path to <Tau>/bin. 

Open terminal and change direcotry to <Tau>.

Run "bash bin/taubuild.sh release.bld".  This is likely to generate a warning message about the llvm spec. 


<* section HelloWorld *>

A HelloWorld example is inculded in <Tau>/tests.  The code itself is in 
 The text file <Tau>/tau/HelloWorld.ls that contains:

Module HelloWorld

use standard

Function hello  seq.word
{ENTRYPOINT} "Hello World!"

The build file is in the text file  <Tau>/HelloWorld/helloworld.bld that contains 
<* block

define hello HelloWorld
/br define makelib stdlib makelib
/br define open shell open  

makelib HelloWorld.lib +HelloWorld HelloWorld.ls 
/br uses=stdlib
/br exports=HelloWorld

hello hello.html

open xx.txt hello.html *>

To create the program,  from terminal run: <* block  bash bin/taubuild.sh helloworld/helloworld.bld  *> 

This will create a program with the name of <Tau>/built/HelloWorld.lib from the source code.
 Then the program is executed and the output is placed in 
<Tau>/built/hello.html.
Finally a web browser  is opened on  the file <Tau>/built/hello.html.


HelloWorld.lib can also be run from the prompt: <* block tau HelloWord hello  *> This will display "Hello World!" in the web browser. 

<* section Some useful tools *>


alias usegraph="tau tools usegraph"

alias transform="tau tools transform"

A function can be profiled to see where the time is being spent in a program.  An example of doing this is given 
/< a href ="./profileExampleSrc.html" >here. /< /a>  Which produces the output
/< a href ="./profileExample.html" >here. /< /a> 


The /keyword htmlcode cmd create html from source files pretty prints the file and adds syntax highlighting and a module index.  It is useful for examining source code.  For example 
</ block htmlcode +built core.libsrc *> 

<* section Introduction to intermediate code produced by compiler *>

This section provides a brief explanation of the control structure used in the intermediate code. The follow function for calculating factorials is used as an example.

Function fact2(a:int,result:int) int
 if a =1   then result
 else if a=0 then result else  fact2(a-1,result * a)


The intermediate code is represented by a sequence of symbols. The text representation of a symbol does not contain all the information
in a symbol. The function fact2 is represented by the text. " helloworld:test2 (int, int) int"
The module of the symbol is represented but not the library. Each type also has module and library
but only the name of the type is given. 

  The local variables are represented by % followed by a number, for example   %2.  Local variables  also have name associated with 
  them that is not in the text representation. 

The body of fact2 can be rewritten as a sequence of statments using explicit gotos. All the statements are wrap up in a block.   
<* block Block(
  /br if  a=1 then goto(+1) else goto(+2)
   /br,Exit(result)  
   /br,if  a=0  then goto(+1) else goto(+2) 
   /br,Exit( result)
   /br,Exit( fact2(a-1,result * a))
  ) *>
/strong goto(+n) means do not execute the next n-1 statements and continue with the following statement.
/strong Exit means skip executing all the follow statements in the block. 


A further rewrite gets closer to the intermediate code. The rewrite starts the block with Start (<type
of value returned by block>). Each statement is expressed in postfix notation. The /ldq if <exp> then
goto (a) else goto (b)" becomes /ldq <postfix exp> Br2 (a, b)". The end of the block is indicated by
EndBlock The parameter names become %1 and %2
 <* block
 /br   Start(int) 
 /br   %1 1 =  Br2(1,2) 
 /br   %2 Exit 
 /br   %1 0 = Br2(1,2)
 /br   %2 Exit
 /br   %1 1 - %2 %1 *  fact2 Exit 
 /br   EndBlock *>
  
  This function is tail recursive and the recursion 
  can be removed by using a loop.  The values that change each time through the loop are 
  capture in loop variables. The loop will use two additon symbols called Loop and Continue. 
  

The first step in calling a function is to assign its arguments to new locals. If one considers the
symbol <* block loop:3 (int, int) int*> to be a function declaration <* block function loop (%3:int, %4:int)*>, then the first
step is same as the first step in calling a function. Also the /strong Continue /strong 2 can be consider a function call 

    
   The Start(int) is replaced with   /strong Loop   and the  "fact2 Exit" is replaced with a /strong CONTINE 2 to get 
   <* block 
 /br  %1 %2 Loop:3(int,int)int
 /br   %3 1 =  Br2(1,2) 
 /br  %4 Exit 
 /br  %3 0 = Br2(1,2)
 /br  %4 Exit
 /br  %3 %3 1 - %4 %3 * Continue 2
 /br  EndBlock *>
  
 Finally by replacing function names with the full symbol description, the text representation of the intermediate code is
  <* block
  %1 %2 Loop:3(int, int)int 
/br %3 1=(int, int)boolean Br2(1, 2) 
/br %4 Exit 
/br %3 0=(int, int)boolean Br2(1, 2) 
/br %4 Exit 
/br %3 1-(int, int)int %4 %3 *(int, int)int Continue 2 
/br EndBlock *>  








<* section HelloWorld with dynamic libraries *>
The Mac OS X implementation also allows  dynamic libraries to be created instead of programs.
The command is    <* block ltau stdlib HelloWorld x   *> 

In this command /em ltau refers to a script in <tau>/bin.  The next word, /em stdlib 
, refers to a dynamic library <tau>/stdlib.dylib which tau will load 
and pass the rest of the command line as an argument to stdlib. 

The library stdlib takes /em "HelloWorld" and creates another dynamic library <tau>/Helloworld.dylib
from the src in <tau>/HelloWorld.  Helloworld.dylib is then loaded and
the entrypoint function is call with any remaining arguments, which in this case is "x"
If no args are present, then execute stops with the creation of HelloWorld.dylib.

Once HelloWorld.dylib is created, the program can be run with
<* block ltau  HelloWorld arg *> without any compiling taking place.


4. Many text editors allow scripts to be run.  To change HelloWorld into a script
add as the first line  of the  HelloWorld.ls,  the line
<* block #!/bin/sh  tau stdlib  HelloWorld *> followed by a blank line. 
Your text editor may run HelloWorld as a script without setting the execute bit. 
To set the execute bit, use <* block chmod +x HelloWorld/HelloWorld.ls *>


<* section Installing Web Assembly Cross Compiler *>

Since wasm files cannot be served from filesystem a web server is required. 
OSX has an Apache web server pre-installed.  The details of how to configure the
Apache web server is not hard but the details vary with OS so only the gist of what needs to 
be done is given here.

Set up a virtual host Below is an example configuretion.  The quotes strings
will need to be updated with absolute path of you <Tau> directory.
<* block 
<VirtualHost *:80>
    ServerName  myhost.local
/br    DocumentRoot "/Users/david/Tau"
/br    <Directory   "/Users/david/Tau" >
<* block       Options FollowSymLinks Multiviews
/br       MultiviewsMatch Any
/br       AllowOverride None
/br       Require all granted
*>   </Directory>
/br   ScriptAliasMatch ^/cgi-bin/((?!(?i:webobjects)).*$) "/Users/david/Tau/bin/$1"
/br    ErrorLog "/private/var/log/apache2/myhost-error_log"
/br    CustomLog "/private/var/log/apache2/myhost-access_log" common  
/br </VirtualHost>
*>

The /em wtau command defaults the /em tauwebserver environment variable to https://myhost.local. 
The environ variable tauwebserver must be set if the virtual host name is different or it
does not use SSL. 

To avoid file permission problems add the group of the web server
as one of your groups.  Make that your default group.
Change the user to your user name to avoid permission problems.
An alternative is to run the web server under you user.

Since files are cached by browse change cache control to retrieve new copy when file is changed on server.  To do this add the
directive  <* block set Cache-Control no-cache *> to the <IfModule headers_module> section of the configuration file.

The  <Tau>/bin/putfile.cgi is needed to write files back to the server.

Restart the Apache web server. 

To see if all is working properly run the command <* block 
wtau     wtests wtests  *>
This should open a web browser  with page with a button. 
Push the button to run the test.  All the test should pass.

  /< hr>  
<* section Documentation below is not complete. *>

section vhost

edit vhost and  dulicate the localhost line and change localhost to myhost.test

uncomment vhost line in httpd.conf

edit httpd-vhosts.conf

---

sudo ssh-keygen -f server.key -m PEM

section security

 Is the user who he claims to be?
 
 Is the user authorized for action provided ?
 
Token
  createdate  user action signature 
  
  hour*60+10*second of time of creation --gives 4 digit decimal number
  
  Authenticator
    table of  user(key) password(hashed)  email phone  
    
    table of user tempkey
    
    table of  user action 
    
 Login
    
    user presents user password tempkey Authenticator
    
    Authenticator: if password matches  sends  email with random code (saving randome code user tempkey
    and time send)
    
    Users: presents  user password tempkey  code
  
    Authenticator sends token to user with action "create token"
   
 User request for token
      sends temp key and code
  
Request for signature verification 
     just send token



