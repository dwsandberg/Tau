#!/usr/local/bin/tau

Module genlex

run genlex genhash

run genlex findhash

use oseq.seq.word

use oseq.word

use real

use seq.int

use seq.lexaction1

use seq.seq.word

use seq.triple

use set.int

use set.word

use stdlib

use tree.word



type lexaction1 is record w:word, tokenno:int, label:word

function tokenlist seq.word 
 // tokenlist is from parser generator // 
".-is)]= > {:} comment,([_^∧ ∨ T # if * $wordlist then else let assert report @ A E G F W P N L I K" 


function actionlist seq.lexaction1 
 // most frequently used words in programs // 
  let mostfrequentwords ="// &quot,(). :+_seq = a int if-then else Function let word 0 i T ][ 2 use function mytype @ empty inst "
  let wordstoinclude = mostfrequentwords + toseq(asset(tokenlist +"= < > ? ≤ ≠ ≥ >> << in +-∈ ∋ * / mod ∪ ∩_^") - asset.mostfrequentwords)
  @(+, tolexaction, empty:seq.lexaction1, wordstoinclude)

function tolexaction(next:word)lexaction1 
 // use supplied procedure to convert a word into a lex action // 
  if next in"&quot //"
  then lexaction1(next, 0, next)
  else let token = if next in". ,():"
   then next 
   else if next in" < > ? ≤ ≠ ≥ >> <<"
   then">"_1 
   else if next in"in +-∈ ∋"
   then"-"_1 
   else if next in"* / mod ∪ ∩"
   then"*"_1 
   else if next in"_^"
   then"_"_1 
   else if next in".)]= {:},([ ∧ ∨ # if then else let assert report @ is"
   then next 
   else if hasdigit.next then"I"_1 else"W"_1 
  lexaction1(next, findindex(token, tokenlist), next)

function hashsemiperfect(w:word)int 
 let x = decode.w 
  1 +(length.x * 131 + 1999 * x_1 + 164 * last.x)mod 106

106 131 197 164 1

function hashsemiperfect2(w:word)int 
 let x = decode.w 
  1 +(length.x * 131 + 197 * x_1 + 164 * last.x)mod 106

function tonohash(l:lexaction1)seq.word 
 let a = totext.l 
  {"&br if next = &quot"+ a_4 +"&quot_1 then"+ a +"else"}

Function totext(l:lexaction1)seq.word 
 let w = if w.l ="&quot"_1 then merge("&"+"quot")else w.l 
  let label = if label.l ="&quot"_1 then merge("&"+"quot")else label.l 
  {"lexaction(&quot"+ w +"&quot_1,"+ toword.tokenno.l +", &quot"+ label +"&quot_1)"}

Function genhash seq.word gen.true


Function gen(hash:boolean)seq.word 
 let alist = actionlist 
  let firstpart ="function consumeinput(b:stepresult, next:word)stepresult &br // generated by genlex module in tools //"
  +"&br let Wtoken ="+ toword.findindex("W"_1, tokenlist)+
  "&br let Itoken ="+ toword.findindex("I"_1, tokenlist)+
  "&br let commenttoken ="+ toword.findindex("comment"_1, tokenlist)+
  "&br let stringtoken ="+ toword.findindex("$wordlist"_1, tokenlist)+"&br if tokenstate.b ≠ 0 then 
  &br if tokenstate.b = stringtoken then &br if next = &quot"+ merge.["&"_1,"quot"_1]+"&quot_1 then 
  &br BB(stringtoken, tree(&quot $wordlist &quot_1, @(+, tree, empty:seq.tree.word, string.b)),  stk.b,place.b,input.b)&br else // add to string // 
  &br stepresult(stk.b, place.b + 1, input.b, tokenstate.b, string.b + if next = merge([ &quot & &quot_1, &quot quot &quot_1])then &quot"+ merge.["&"_1,"quot"_1]+"&quot_1 else next)
  &br else if next = &quot // &quot_1 then 
  &br BB(commenttoken, tree(&quot comment &quot_1, @(+, tree, empty:seq.tree.word, string.b)),  stk.b,place.b,input.b)
  &br else // add to string // stepresult(stk.b, place.b + 1, input.b, tokenstate.b, string.b + next)&br else"
  let lastpart ="&br if w.act ≠ next then BB(if hasdigit.next then Itoken else Wtoken, tree(next),  stk.b,place.b,input.b)
  &br else if tokenno.act = 0 then &br if next = &quot"+ merge("&"+"quot")+"&quot_1 then // start word list // stepresult(stk.b, place.b + 1, input.b, stringtoken, &quot &quot)
  &br else // start comment // stepresult(stk.b, place.b + 1, input.b, commenttoken, &quot &quot)
  &br else BB(tokenno.act, tree.label.act,  stk.b,place.b,input.b)"
  firstpart +(if hash 
   then assert hashsemiperfect("let"_1)= hashsemiperfect("."_1)report"we expect one collision"
    let j = find("."_1, alist, 1) let k = find("//"_1, alist, 1)
    let jj=subseq(alist, 1, j - 1)+ subseq(alist, j + 1, length.alist)
    let kk=subseq(jj, 1, k - 1)+ subseq(jj, k + 1, length.jj)
    let tab = @(item, identity, constantseq(106, defaultaction), kk)
    {"let act = if next = &quot.&quot_1 then"+ totext(alist_j)+
      "&br else if next = &quot // &quot_1 then" + totext(alist_k)+
     "&br else let x = decode(next)&br ["+ @(seperator."&br,", identity,"", tab)+"]_(1 +(length.x * 131 + 1999 * x_1 + 164 * last.x)mod 106)"} 
   else"let act ="+ @(+, tonohash,"", actionlist)+ defaultaction)+ lastpart

function find(w:word, s:seq.lexaction1, i:int)int 
 if w(s_i)= w then i else find(w, s, i + 1)

function item(tab:seq.seq.word, l:lexaction1)seq.seq.word 
 if w.l ="."_1 
  then tab 
  else assert tab_hashsemiperfect.w.l = defaultaction report"unexpected collision between"+ w.l +"and"+ tab_hashsemiperfect.w.l 
  replace(tab, hashsemiperfect.w.l, totext.l)

function xx(w:word)seq.word [ toword.hashsemiperfect.w, w]

function defaultaction seq.word {"lexaction(&quot. &quot_1, 0, &quot. &quot_1)"}

Function findhash seq.word 
 // look for a semiperfect hash function // 
  // crashes when search larger range of primes // 
  let b = @(+, w,"", actionlist)
  let t = @(+, astriple, empty:seq.triple, actionlist)
  let y = sort.@(+, xx, empty:seq.seq.word, b)
  {"actual hash values &br"+ @(seperator.", &br", identity,"", y)+"&br size of table, x, y, z, number of collisions"+ @(+, searchhash(subseq(findprimes(3, 220), 30, 400)+ [ 164, 1999], t, 0,""),"", arithseq(20, 1, 101))}

type triple is record a:int, b:int, c:int

function astriple(l:lexaction1)triple 
 let x = decode.w.l 
  triple(length.x, x_1, last.x)

function try(x:int, y:int, z:int, m:int, t:triple)int {(a.t * x + y * b.t + z * c.t)mod m }

Function searchhash(p:seq.int, b:seq.triple, i:int, result:seq.word, m:int)seq.word 
 let base = length.p 
  let x = p_(i mod base + 1)
  let y = p_(i / base mod base + 1)
  let tmp = i / base / base 
  if tmp ≥ base 
  then result 
  else let z = p_(tmp + 1)
  let l = length.b - length.toseq.@(+, try(x, y, z, m), empty:set.int, b)
  if l < 6 
  then searchhash(p, b, i + 1, result +"&br"+ @(+, toword,"", [ m, x, y, z, l]), m)
  else searchhash(p, b, i + 1, result, m)

function findprimes(start:int, end:int)seq.int 
 @(+, isprime3, empty:seq.int, arithseq((end - start + 2)/ 2, 2, start))

function isprime3(i:int)seq.int if isprime.i then [ i]else empty:seq.int

function isprime(i:int)boolean 
 if i mod 2 = 0 
  then i = 2 
  else let a = intpart.sqrt.int2real.i 
  let b =(a + i / a)/ 2 
  subisprime(i, 3, b)

function subisprime(i:int, f:int, b:int)boolean 
 if f > b then true else if i mod f = 0 then false else subisprime(i, f + 2, b)

